(() => {
    var lM = Object.defineProperty;
    var Nd = Object.getOwnPropertySymbols;
    var cM = Object.prototype.hasOwnProperty,
        uM = Object.prototype.propertyIsEnumerable;
    var Mc = (Rt, dt, Et) => dt in Rt ? lM(Rt, dt, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: Et
        }) : Rt[dt] = Et,
        Bd = (Rt, dt) => {
            for (var Et in dt || (dt = {})) cM.call(dt, Et) && Mc(Rt, Et, dt[Et]);
            if (Nd)
                for (var Et of Nd(dt)) uM.call(dt, Et) && Mc(Rt, Et, dt[Et]);
            return Rt
        };
    var ee = (Rt, dt, Et) => (Mc(Rt, typeof dt != "symbol" ? dt + "" : dt, Et), Et);
    var WM = function(Rt) {
        "use strict";
        /**
         * @license
         * Copyright 2010-2021 Three.js Authors
         * SPDX-License-Identifier: MIT
         */
        const dt = "133",
            Et = 0,
            bc = 1,
            Od = 2,
            wc = 1,
            Ud = 2,
            Zr = 3,
            Vi = 0,
            nt = 1,
            vi = 2,
            Sc = 1,
            On = 0,
            Jr = 1,
            to = 2,
            Tc = 3,
            Ec = 4,
            kd = 5,
            Wi = 100,
            Gd = 101,
            Hd = 102,
            Ac = 103,
            Lc = 104,
            Vd = 200,
            Wd = 201,
            qd = 202,
            Xd = 203,
            Rc = 204,
            Cc = 205,
            jd = 206,
            Yd = 207,
            Zd = 208,
            Jd = 209,
            $d = 210,
            Kd = 0,
            Qd = 1,
            ep = 2,
            no = 3,
            tp = 4,
            np = 5,
            ip = 6,
            rp = 7,
            qs = 0,
            sp = 1,
            ap = 2,
            xi = 0,
            op = 1,
            lp = 2,
            cp = 3,
            Pc = 4,
            up = 5,
            Dc = 300,
            Xs = 301,
            js = 302,
            io = 303,
            ro = 304,
            Ys = 306,
            so = 307,
            xn = 1e3,
            Ct = 1001,
            Zs = 1002,
            st = 1003,
            ao = 1004,
            oo = 1005,
            lt = 1006,
            Ic = 1007,
            qi = 1008,
            Un = 1009,
            hp = 1010,
            fp = 1011,
            Js = 1012,
            dp = 1013,
            $s = 1014,
            yn = 1015,
            Xi = 1016,
            pp = 1017,
            mp = 1018,
            gp = 1019,
            $r = 1020,
            _p = 1021,
            yi = 1022,
            ct = 1023,
            vp = 1024,
            xp = 1025,
            yp = ct,
            ji = 1026,
            Kr = 1027,
            Mp = 1028,
            bp = 1029,
            wp = 1030,
            Sp = 1031,
            Tp = 1032,
            Ep = 1033,
            Fc = 33776,
            zc = 33777,
            Nc = 33778,
            Bc = 33779,
            Oc = 35840,
            Uc = 35841,
            kc = 35842,
            Gc = 35843,
            Ap = 36196,
            Hc = 37492,
            Vc = 37496,
            Lp = 37808,
            Rp = 37809,
            Cp = 37810,
            Pp = 37811,
            Dp = 37812,
            Ip = 37813,
            Fp = 37814,
            zp = 37815,
            Np = 37816,
            Bp = 37817,
            Op = 37818,
            Up = 37819,
            kp = 37820,
            Gp = 37821,
            Hp = 36492,
            Vp = 37840,
            Wp = 37841,
            qp = 37842,
            Xp = 37843,
            jp = 37844,
            Yp = 37845,
            Zp = 37846,
            Jp = 37847,
            $p = 37848,
            Kp = 37849,
            Qp = 37850,
            em = 37851,
            tm = 37852,
            nm = 37853,
            im = 2200,
            rm = 2201,
            sm = 2202,
            Qr = 2300,
            Yi = 2301,
            lo = 2302,
            Zi = 2400,
            Ji = 2401,
            Ks = 2402,
            co = 2500,
            Wc = 2501,
            am = 0,
            om = 1,
            qc = 2,
            vt = 3e3,
            Ot = 3001,
            uo = 3007,
            ho = 3002,
            lm = 3003,
            Xc = 3004,
            jc = 3005,
            Yc = 3006,
            cm = 3200,
            um = 3201,
            kn = 0,
            hm = 1,
            fo = 7680,
            fm = 519,
            Mi = 35044,
            es = 35048,
            Zc = "300 es";
        class bi {
            addEventListener(e, t) {
                this._listeners === void 0 && (this._listeners = {});
                const n = this._listeners;
                n[e] === void 0 && (n[e] = []), n[e].indexOf(t) === -1 && n[e].push(t)
            }
            hasEventListener(e, t) {
                if (this._listeners === void 0) return !1;
                const n = this._listeners;
                return n[e] !== void 0 && n[e].indexOf(t) !== -1
            }
            removeEventListener(e, t) {
                if (this._listeners === void 0) return;
                const i = this._listeners[e];
                if (i !== void 0) {
                    const r = i.indexOf(t);
                    r !== -1 && i.splice(r, 1)
                }
            }
            dispatchEvent(e) {
                if (this._listeners === void 0) return;
                const n = this._listeners[e.type];
                if (n !== void 0) {
                    e.target = this;
                    const i = n.slice(0);
                    for (let r = 0, s = i.length; r < s; r++) i[r].call(this, e);
                    e.target = null
                }
            }
        }
        let Qs = 1234567;
        const ts = Math.PI / 180,
            ns = 180 / Math.PI,
            pt = [];
        for (let a = 0; a < 256; a++) pt[a] = (a < 16 ? "0" : "") + a.toString(16);
        const dm = typeof crypto != "undefined" && "randomUUID" in crypto;

        function Xt() {
            if (dm) return crypto.randomUUID().toUpperCase();
            const a = Math.random() * 4294967295 | 0,
                e = Math.random() * 4294967295 | 0,
                t = Math.random() * 4294967295 | 0,
                n = Math.random() * 4294967295 | 0;
            return (pt[a & 255] + pt[a >> 8 & 255] + pt[a >> 16 & 255] + pt[a >> 24 & 255] + "-" + pt[e & 255] + pt[e >> 8 & 255] + "-" + pt[e >> 16 & 15 | 64] + pt[e >> 24 & 255] + "-" + pt[t & 63 | 128] + pt[t >> 8 & 255] + "-" + pt[t >> 16 & 255] + pt[t >> 24 & 255] + pt[n & 255] + pt[n >> 8 & 255] + pt[n >> 16 & 255] + pt[n >> 24 & 255]).toUpperCase()
        }

        function Pt(a, e, t) {
            return Math.max(e, Math.min(t, a))
        }

        function po(a, e) {
            return (a % e + e) % e
        }

        function pm(a, e, t, n, i) {
            return n + (a - e) * (i - n) / (t - e)
        }

        function mm(a, e, t) {
            return a !== e ? (t - a) / (e - a) : 0
        }

        function is(a, e, t) {
            return (1 - t) * a + t * e
        }

        function gm(a, e, t, n) {
            return is(a, e, 1 - Math.exp(-t * n))
        }

        function _m(a, e = 1) {
            return e - Math.abs(po(a, e * 2) - e)
        }

        function vm(a, e, t) {
            return a <= e ? 0 : a >= t ? 1 : (a = (a - e) / (t - e), a * a * (3 - 2 * a))
        }

        function xm(a, e, t) {
            return a <= e ? 0 : a >= t ? 1 : (a = (a - e) / (t - e), a * a * a * (a * (a * 6 - 15) + 10))
        }

        function ym(a, e) {
            return a + Math.floor(Math.random() * (e - a + 1))
        }

        function Mm(a, e) {
            return a + Math.random() * (e - a)
        }

        function bm(a) {
            return a * (.5 - Math.random())
        }

        function wm(a) {
            return a !== void 0 && (Qs = a % 2147483647), Qs = Qs * 16807 % 2147483647, (Qs - 1) / 2147483646
        }

        function Sm(a) {
            return a * ts
        }

        function Tm(a) {
            return a * ns
        }

        function mo(a) {
            return (a & a - 1) == 0 && a !== 0
        }

        function Jc(a) {
            return Math.pow(2, Math.ceil(Math.log(a) / Math.LN2))
        }

        function $c(a) {
            return Math.pow(2, Math.floor(Math.log(a) / Math.LN2))
        }

        function Em(a, e, t, n, i) {
            const r = Math.cos,
                s = Math.sin,
                o = r(t / 2),
                l = s(t / 2),
                c = r((e + n) / 2),
                u = s((e + n) / 2),
                h = r((e - n) / 2),
                f = s((e - n) / 2),
                d = r((n - e) / 2),
                m = s((n - e) / 2);
            switch (i) {
                case "XYX":
                    a.set(o * u, l * h, l * f, o * c);
                    break;
                case "YZY":
                    a.set(l * f, o * u, l * h, o * c);
                    break;
                case "ZXZ":
                    a.set(l * h, l * f, o * u, o * c);
                    break;
                case "XZX":
                    a.set(o * u, l * m, l * d, o * c);
                    break;
                case "YXY":
                    a.set(l * d, o * u, l * m, o * c);
                    break;
                case "ZYZ":
                    a.set(l * m, l * d, o * u, o * c);
                    break;
                default:
                    console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i)
            }
        }
        var go = Object.freeze({
            __proto__: null,
            DEG2RAD: ts,
            RAD2DEG: ns,
            generateUUID: Xt,
            clamp: Pt,
            euclideanModulo: po,
            mapLinear: pm,
            inverseLerp: mm,
            lerp: is,
            damp: gm,
            pingpong: _m,
            smoothstep: vm,
            smootherstep: xm,
            randInt: ym,
            randFloat: Mm,
            randFloatSpread: bm,
            seededRandom: wm,
            degToRad: Sm,
            radToDeg: Tm,
            isPowerOfTwo: mo,
            ceilPowerOfTwo: Jc,
            floorPowerOfTwo: $c,
            setQuaternionFromProperEuler: Em
        });
        class X {
            constructor(e = 0, t = 0) {
                this.x = e, this.y = t
            }
            get width() {
                return this.x
            }
            set width(e) {
                this.x = e
            }
            get height() {
                return this.y
            }
            set height(e) {
                this.y = e
            }
            set(e, t) {
                return this.x = e, this.y = t, this
            }
            setScalar(e) {
                return this.x = e, this.y = e, this
            }
            setX(e) {
                return this.x = e, this
            }
            setY(e) {
                return this.y = e, this
            }
            setComponent(e, t) {
                switch (e) {
                    case 0:
                        this.x = t;
                        break;
                    case 1:
                        this.y = t;
                        break;
                    default:
                        throw new Error("index is out of range: " + e)
                }
                return this
            }
            getComponent(e) {
                switch (e) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    default:
                        throw new Error("index is out of range: " + e)
                }
            }
            clone() {
                return new this.constructor(this.x, this.y)
            }
            copy(e) {
                return this.x = e.x, this.y = e.y, this
            }
            add(e, t) {
                return t !== void 0 ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this)
            }
            addScalar(e) {
                return this.x += e, this.y += e, this
            }
            addVectors(e, t) {
                return this.x = e.x + t.x, this.y = e.y + t.y, this
            }
            addScaledVector(e, t) {
                return this.x += e.x * t, this.y += e.y * t, this
            }
            sub(e, t) {
                return t !== void 0 ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this)
            }
            subScalar(e) {
                return this.x -= e, this.y -= e, this
            }
            subVectors(e, t) {
                return this.x = e.x - t.x, this.y = e.y - t.y, this
            }
            multiply(e) {
                return this.x *= e.x, this.y *= e.y, this
            }
            multiplyScalar(e) {
                return this.x *= e, this.y *= e, this
            }
            divide(e) {
                return this.x /= e.x, this.y /= e.y, this
            }
            divideScalar(e) {
                return this.multiplyScalar(1 / e)
            }
            applyMatrix3(e) {
                const t = this.x,
                    n = this.y,
                    i = e.elements;
                return this.x = i[0] * t + i[3] * n + i[6], this.y = i[1] * t + i[4] * n + i[7], this
            }
            min(e) {
                return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this
            }
            max(e) {
                return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this
            }
            clamp(e, t) {
                return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this
            }
            clampScalar(e, t) {
                return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this
            }
            clampLength(e, t) {
                const n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
            }
            floor() {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
            }
            ceil() {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
            }
            round() {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this
            }
            roundToZero() {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
            }
            negate() {
                return this.x = -this.x, this.y = -this.y, this
            }
            dot(e) {
                return this.x * e.x + this.y * e.y
            }
            cross(e) {
                return this.x * e.y - this.y * e.x
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            angle() {
                return Math.atan2(-this.y, -this.x) + Math.PI
            }
            distanceTo(e) {
                return Math.sqrt(this.distanceToSquared(e))
            }
            distanceToSquared(e) {
                const t = this.x - e.x,
                    n = this.y - e.y;
                return t * t + n * n
            }
            manhattanDistanceTo(e) {
                return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
            }
            setLength(e) {
                return this.normalize().multiplyScalar(e)
            }
            lerp(e, t) {
                return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this
            }
            lerpVectors(e, t, n) {
                return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this
            }
            equals(e) {
                return e.x === this.x && e.y === this.y
            }
            fromArray(e, t = 0) {
                return this.x = e[t], this.y = e[t + 1], this
            }
            toArray(e = [], t = 0) {
                return e[t] = this.x, e[t + 1] = this.y, e
            }
            fromBufferAttribute(e, t, n) {
                return n !== void 0 && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this
            }
            rotateAround(e, t) {
                const n = Math.cos(t),
                    i = Math.sin(t),
                    r = this.x - e.x,
                    s = this.y - e.y;
                return this.x = r * n - s * i + e.x, this.y = r * i + s * n + e.y, this
            }
            random() {
                return this.x = Math.random(), this.y = Math.random(), this
            }*[Symbol.iterator]() {
                yield this.x, yield this.y
            }
        }
        X.prototype.isVector2 = !0;
        class mt {
            constructor() {
                this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
            }
            set(e, t, n, i, r, s, o, l, c) {
                const u = this.elements;
                return u[0] = e, u[1] = i, u[2] = o, u[3] = t, u[4] = r, u[5] = l, u[6] = n, u[7] = s, u[8] = c, this
            }
            identity() {
                return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
            }
            copy(e) {
                const t = this.elements,
                    n = e.elements;
                return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], this
            }
            extractBasis(e, t, n) {
                return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this
            }
            setFromMatrix4(e) {
                const t = e.elements;
                return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
            }
            multiply(e) {
                return this.multiplyMatrices(this, e)
            }
            premultiply(e) {
                return this.multiplyMatrices(e, this)
            }
            multiplyMatrices(e, t) {
                const n = e.elements,
                    i = t.elements,
                    r = this.elements,
                    s = n[0],
                    o = n[3],
                    l = n[6],
                    c = n[1],
                    u = n[4],
                    h = n[7],
                    f = n[2],
                    d = n[5],
                    m = n[8],
                    g = i[0],
                    v = i[3],
                    p = i[6],
                    _ = i[1],
                    M = i[4],
                    y = i[7],
                    b = i[2],
                    T = i[5],
                    x = i[8];
                return r[0] = s * g + o * _ + l * b, r[3] = s * v + o * M + l * T, r[6] = s * p + o * y + l * x, r[1] = c * g + u * _ + h * b, r[4] = c * v + u * M + h * T, r[7] = c * p + u * y + h * x, r[2] = f * g + d * _ + m * b, r[5] = f * v + d * M + m * T, r[8] = f * p + d * y + m * x, this
            }
            multiplyScalar(e) {
                const t = this.elements;
                return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this
            }
            determinant() {
                const e = this.elements,
                    t = e[0],
                    n = e[1],
                    i = e[2],
                    r = e[3],
                    s = e[4],
                    o = e[5],
                    l = e[6],
                    c = e[7],
                    u = e[8];
                return t * s * u - t * o * c - n * r * u + n * o * l + i * r * c - i * s * l
            }
            invert() {
                const e = this.elements,
                    t = e[0],
                    n = e[1],
                    i = e[2],
                    r = e[3],
                    s = e[4],
                    o = e[5],
                    l = e[6],
                    c = e[7],
                    u = e[8],
                    h = u * s - o * c,
                    f = o * l - u * r,
                    d = c * r - s * l,
                    m = t * h + n * f + i * d;
                if (m === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                const g = 1 / m;
                return e[0] = h * g, e[1] = (i * c - u * n) * g, e[2] = (o * n - i * s) * g, e[3] = f * g, e[4] = (u * t - i * l) * g, e[5] = (i * r - o * t) * g, e[6] = d * g, e[7] = (n * l - c * t) * g, e[8] = (s * t - n * r) * g, this
            }
            transpose() {
                let e;
                const t = this.elements;
                return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this
            }
            getNormalMatrix(e) {
                return this.setFromMatrix4(e).invert().transpose()
            }
            transposeIntoArray(e) {
                const t = this.elements;
                return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this
            }
            setUvTransform(e, t, n, i, r, s, o) {
                const l = Math.cos(r),
                    c = Math.sin(r);
                return this.set(n * l, n * c, -n * (l * s + c * o) + s + e, -i * c, i * l, -i * (-c * s + l * o) + o + t, 0, 0, 1), this
            }
            scale(e, t) {
                const n = this.elements;
                return n[0] *= e, n[3] *= e, n[6] *= e, n[1] *= t, n[4] *= t, n[7] *= t, this
            }
            rotate(e) {
                const t = Math.cos(e),
                    n = Math.sin(e),
                    i = this.elements,
                    r = i[0],
                    s = i[3],
                    o = i[6],
                    l = i[1],
                    c = i[4],
                    u = i[7];
                return i[0] = t * r + n * l, i[3] = t * s + n * c, i[6] = t * o + n * u, i[1] = -n * r + t * l, i[4] = -n * s + t * c, i[7] = -n * o + t * u, this
            }
            translate(e, t) {
                const n = this.elements;
                return n[0] += e * n[2], n[3] += e * n[5], n[6] += e * n[8], n[1] += t * n[2], n[4] += t * n[5], n[7] += t * n[8], this
            }
            equals(e) {
                const t = this.elements,
                    n = e.elements;
                for (let i = 0; i < 9; i++)
                    if (t[i] !== n[i]) return !1;
                return !0
            }
            fromArray(e, t = 0) {
                for (let n = 0; n < 9; n++) this.elements[n] = e[n + t];
                return this
            }
            toArray(e = [], t = 0) {
                const n = this.elements;
                return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e
            }
            clone() {
                return new this.constructor().fromArray(this.elements)
            }
        }
        mt.prototype.isMatrix3 = !0;

        function Kc(a) {
            if (a.length === 0) return -1 / 0;
            let e = a[0];
            for (let t = 1, n = a.length; t < n; ++t) a[t] > e && (e = a[t]);
            return e
        }

        function ea(a) {
            return document.createElementNS("http://www.w3.org/1999/xhtml", a)
        }
        let $i;
        class Ki {
            static getDataURL(e) {
                if (/^data:/i.test(e.src) || typeof HTMLCanvasElement == "undefined") return e.src;
                let t;
                if (e instanceof HTMLCanvasElement) t = e;
                else {
                    $i === void 0 && ($i = ea("canvas")), $i.width = e.width, $i.height = e.height;
                    const n = $i.getContext("2d");
                    e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height), t = $i
                }
                return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), t.toDataURL("image/jpeg", .6)) : t.toDataURL("image/png")
            }
        }
        let Am = 0;
        class at extends bi {
            constructor(e = at.DEFAULT_IMAGE, t = at.DEFAULT_MAPPING, n = Ct, i = Ct, r = lt, s = qi, o = ct, l = Un, c = 1, u = vt) {
                super();
                Object.defineProperty(this, "id", {
                    value: Am++
                }), this.uuid = Xt(), this.name = "", this.image = e, this.mipmaps = [], this.mapping = t, this.wrapS = n, this.wrapT = i, this.magFilter = r, this.minFilter = s, this.anisotropy = c, this.format = o, this.internalFormat = null, this.type = l, this.offset = new X(0, 0), this.repeat = new X(1, 1), this.center = new X(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new mt, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = u, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1
            }
            updateMatrix() {
                this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
            }
            clone() {
                return new this.constructor().copy(this)
            }
            copy(e) {
                return this.name = e.name, this.image = e.image, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.encoding = e.encoding, this
            }
            toJSON(e) {
                const t = e === void 0 || typeof e == "string";
                if (!t && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
                const n = {
                    metadata: {
                        version: 4.5,
                        type: "Texture",
                        generator: "Texture.toJSON"
                    },
                    uuid: this.uuid,
                    name: this.name,
                    mapping: this.mapping,
                    repeat: [this.repeat.x, this.repeat.y],
                    offset: [this.offset.x, this.offset.y],
                    center: [this.center.x, this.center.y],
                    rotation: this.rotation,
                    wrap: [this.wrapS, this.wrapT],
                    format: this.format,
                    type: this.type,
                    encoding: this.encoding,
                    minFilter: this.minFilter,
                    magFilter: this.magFilter,
                    anisotropy: this.anisotropy,
                    flipY: this.flipY,
                    premultiplyAlpha: this.premultiplyAlpha,
                    unpackAlignment: this.unpackAlignment
                };
                if (this.image !== void 0) {
                    const i = this.image;
                    if (i.uuid === void 0 && (i.uuid = Xt()), !t && e.images[i.uuid] === void 0) {
                        let r;
                        if (Array.isArray(i)) {
                            r = [];
                            for (let s = 0, o = i.length; s < o; s++) i[s].isDataTexture ? r.push(_o(i[s].image)) : r.push(_o(i[s]))
                        } else r = _o(i);
                        e.images[i.uuid] = {
                            uuid: i.uuid,
                            url: r
                        }
                    }
                    n.image = i.uuid
                }
                return t || (e.textures[this.uuid] = n), n
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
            transformUv(e) {
                if (this.mapping !== Dc) return e;
                if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) {
                    case xn:
                        e.x = e.x - Math.floor(e.x);
                        break;
                    case Ct:
                        e.x = e.x < 0 ? 0 : 1;
                        break;
                    case Zs:
                        Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
                        break
                }
                if (e.y < 0 || e.y > 1) switch (this.wrapT) {
                    case xn:
                        e.y = e.y - Math.floor(e.y);
                        break;
                    case Ct:
                        e.y = e.y < 0 ? 0 : 1;
                        break;
                    case Zs:
                        Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
                        break
                }
                return this.flipY && (e.y = 1 - e.y), e
            }
            set needsUpdate(e) {
                e === !0 && this.version++
            }
        }
        at.DEFAULT_IMAGE = void 0, at.DEFAULT_MAPPING = Dc, at.prototype.isTexture = !0;

        function _o(a) {
            return typeof HTMLImageElement != "undefined" && a instanceof HTMLImageElement || typeof HTMLCanvasElement != "undefined" && a instanceof HTMLCanvasElement || typeof ImageBitmap != "undefined" && a instanceof ImageBitmap ? Ki.getDataURL(a) : a.data ? {
                data: Array.prototype.slice.call(a.data),
                width: a.width,
                height: a.height,
                type: a.data.constructor.name
            } : (console.warn("THREE.Texture: Unable to serialize Texture."), {})
        }
        class Ue {
            constructor(e = 0, t = 0, n = 0, i = 1) {
                this.x = e, this.y = t, this.z = n, this.w = i
            }
            get width() {
                return this.z
            }
            set width(e) {
                this.z = e
            }
            get height() {
                return this.w
            }
            set height(e) {
                this.w = e
            }
            set(e, t, n, i) {
                return this.x = e, this.y = t, this.z = n, this.w = i, this
            }
            setScalar(e) {
                return this.x = e, this.y = e, this.z = e, this.w = e, this
            }
            setX(e) {
                return this.x = e, this
            }
            setY(e) {
                return this.y = e, this
            }
            setZ(e) {
                return this.z = e, this
            }
            setW(e) {
                return this.w = e, this
            }
            setComponent(e, t) {
                switch (e) {
                    case 0:
                        this.x = t;
                        break;
                    case 1:
                        this.y = t;
                        break;
                    case 2:
                        this.z = t;
                        break;
                    case 3:
                        this.w = t;
                        break;
                    default:
                        throw new Error("index is out of range: " + e)
                }
                return this
            }
            getComponent(e) {
                switch (e) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    case 2:
                        return this.z;
                    case 3:
                        return this.w;
                    default:
                        throw new Error("index is out of range: " + e)
                }
            }
            clone() {
                return new this.constructor(this.x, this.y, this.z, this.w)
            }
            copy(e) {
                return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this
            }
            add(e, t) {
                return t !== void 0 ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this)
            }
            addScalar(e) {
                return this.x += e, this.y += e, this.z += e, this.w += e, this
            }
            addVectors(e, t) {
                return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this
            }
            addScaledVector(e, t) {
                return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this
            }
            sub(e, t) {
                return t !== void 0 ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this)
            }
            subScalar(e) {
                return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this
            }
            subVectors(e, t) {
                return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this
            }
            multiply(e) {
                return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this
            }
            multiplyScalar(e) {
                return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this
            }
            applyMatrix4(e) {
                const t = this.x,
                    n = this.y,
                    i = this.z,
                    r = this.w,
                    s = e.elements;
                return this.x = s[0] * t + s[4] * n + s[8] * i + s[12] * r, this.y = s[1] * t + s[5] * n + s[9] * i + s[13] * r, this.z = s[2] * t + s[6] * n + s[10] * i + s[14] * r, this.w = s[3] * t + s[7] * n + s[11] * i + s[15] * r, this
            }
            divideScalar(e) {
                return this.multiplyScalar(1 / e)
            }
            setAxisAngleFromQuaternion(e) {
                this.w = 2 * Math.acos(e.w);
                const t = Math.sqrt(1 - e.w * e.w);
                return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this
            }
            setAxisAngleFromRotationMatrix(e) {
                let t, n, i, r;
                const s = .01,
                    o = .1,
                    l = e.elements,
                    c = l[0],
                    u = l[4],
                    h = l[8],
                    f = l[1],
                    d = l[5],
                    m = l[9],
                    g = l[2],
                    v = l[6],
                    p = l[10];
                if (Math.abs(u - f) < s && Math.abs(h - g) < s && Math.abs(m - v) < s) {
                    if (Math.abs(u + f) < o && Math.abs(h + g) < o && Math.abs(m + v) < o && Math.abs(c + d + p - 3) < o) return this.set(1, 0, 0, 0), this;
                    t = Math.PI;
                    const M = (c + 1) / 2,
                        y = (d + 1) / 2,
                        b = (p + 1) / 2,
                        T = (u + f) / 4,
                        x = (h + g) / 4,
                        R = (m + v) / 4;
                    return M > y && M > b ? M < s ? (n = 0, i = .707106781, r = .707106781) : (n = Math.sqrt(M), i = T / n, r = x / n) : y > b ? y < s ? (n = .707106781, i = 0, r = .707106781) : (i = Math.sqrt(y), n = T / i, r = R / i) : b < s ? (n = .707106781, i = .707106781, r = 0) : (r = Math.sqrt(b), n = x / r, i = R / r), this.set(n, i, r, t), this
                }
                let _ = Math.sqrt((v - m) * (v - m) + (h - g) * (h - g) + (f - u) * (f - u));
                return Math.abs(_) < .001 && (_ = 1), this.x = (v - m) / _, this.y = (h - g) / _, this.z = (f - u) / _, this.w = Math.acos((c + d + p - 1) / 2), this
            }
            min(e) {
                return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this
            }
            max(e) {
                return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this
            }
            clamp(e, t) {
                return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this
            }
            clampScalar(e, t) {
                return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this
            }
            clampLength(e, t) {
                const n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
            }
            floor() {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
            }
            ceil() {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
            }
            round() {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
            }
            roundToZero() {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
            }
            negate() {
                return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
            }
            dot(e) {
                return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            setLength(e) {
                return this.normalize().multiplyScalar(e)
            }
            lerp(e, t) {
                return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this
            }
            lerpVectors(e, t, n) {
                return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this.w = e.w + (t.w - e.w) * n, this
            }
            equals(e) {
                return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
            }
            fromArray(e, t = 0) {
                return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this
            }
            toArray(e = [], t = 0) {
                return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e
            }
            fromBufferAttribute(e, t, n) {
                return n !== void 0 && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this
            }
            random() {
                return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
            }*[Symbol.iterator]() {
                yield this.x, yield this.y, yield this.z, yield this.w
            }
        }
        Ue.prototype.isVector4 = !0;
        class Dt extends bi {
            constructor(e, t, n = {}) {
                super();
                this.width = e, this.height = t, this.depth = 1, this.scissor = new Ue(0, 0, e, t), this.scissorTest = !1, this.viewport = new Ue(0, 0, e, t), this.texture = new at(void 0, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.isRenderTargetTexture = !0, this.texture.image = {
                    width: e,
                    height: t,
                    depth: 1
                }, this.texture.generateMipmaps = n.generateMipmaps !== void 0 ? n.generateMipmaps : !1, this.texture.internalFormat = n.internalFormat !== void 0 ? n.internalFormat : null, this.texture.minFilter = n.minFilter !== void 0 ? n.minFilter : lt, this.depthBuffer = n.depthBuffer !== void 0 ? n.depthBuffer : !0, this.stencilBuffer = n.stencilBuffer !== void 0 ? n.stencilBuffer : !1, this.depthTexture = n.depthTexture !== void 0 ? n.depthTexture : null
            }
            setTexture(e) {
                e.image = {
                    width: this.width,
                    height: this.height,
                    depth: this.depth
                }, this.texture = e
            }
            setSize(e, t, n = 1) {
                (this.width !== e || this.height !== t || this.depth !== n) && (this.width = e, this.height = t, this.depth = n, this.texture.image.width = e, this.texture.image.height = t, this.texture.image.depth = n, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t)
            }
            clone() {
                return new this.constructor().copy(this)
            }
            copy(e) {
                return this.width = e.width, this.height = e.height, this.depth = e.depth, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.texture.image = Bd({}, this.texture.image), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.depthTexture = e.depthTexture, this
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }
        Dt.prototype.isWebGLRenderTarget = !0;
        class Lm extends Dt {
            constructor(e, t, n) {
                super(e, t);
                const i = this.texture;
                this.texture = [];
                for (let r = 0; r < n; r++) this.texture[r] = i.clone()
            }
            setSize(e, t, n = 1) {
                if (this.width !== e || this.height !== t || this.depth !== n) {
                    this.width = e, this.height = t, this.depth = n;
                    for (let i = 0, r = this.texture.length; i < r; i++) this.texture[i].image.width = e, this.texture[i].image.height = t, this.texture[i].image.depth = n;
                    this.dispose()
                }
                return this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t), this
            }
            copy(e) {
                this.dispose(), this.width = e.width, this.height = e.height, this.depth = e.depth, this.viewport.set(0, 0, this.width, this.height), this.scissor.set(0, 0, this.width, this.height), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.depthTexture = e.depthTexture, this.texture.length = 0;
                for (let t = 0, n = e.texture.length; t < n; t++) this.texture[t] = e.texture[t].clone();
                return this
            }
        }
        Lm.prototype.isWebGLMultipleRenderTargets = !0;
        class Qc extends Dt {
            constructor(e, t, n) {
                super(e, t, n);
                this.samples = 4
            }
            copy(e) {
                return super.copy.call(this, e), this.samples = e.samples, this
            }
        }
        Qc.prototype.isWebGLMultisampleRenderTarget = !0;
        class At {
            constructor(e = 0, t = 0, n = 0, i = 1) {
                this._x = e, this._y = t, this._z = n, this._w = i
            }
            static slerp(e, t, n, i) {
                return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."), n.slerpQuaternions(e, t, i)
            }
            static slerpFlat(e, t, n, i, r, s, o) {
                let l = n[i + 0],
                    c = n[i + 1],
                    u = n[i + 2],
                    h = n[i + 3];
                const f = r[s + 0],
                    d = r[s + 1],
                    m = r[s + 2],
                    g = r[s + 3];
                if (o === 0) {
                    e[t + 0] = l, e[t + 1] = c, e[t + 2] = u, e[t + 3] = h;
                    return
                }
                if (o === 1) {
                    e[t + 0] = f, e[t + 1] = d, e[t + 2] = m, e[t + 3] = g;
                    return
                }
                if (h !== g || l !== f || c !== d || u !== m) {
                    let v = 1 - o;
                    const p = l * f + c * d + u * m + h * g,
                        _ = p >= 0 ? 1 : -1,
                        M = 1 - p * p;
                    if (M > Number.EPSILON) {
                        const b = Math.sqrt(M),
                            T = Math.atan2(b, p * _);
                        v = Math.sin(v * T) / b, o = Math.sin(o * T) / b
                    }
                    const y = o * _;
                    if (l = l * v + f * y, c = c * v + d * y, u = u * v + m * y, h = h * v + g * y, v === 1 - o) {
                        const b = 1 / Math.sqrt(l * l + c * c + u * u + h * h);
                        l *= b, c *= b, u *= b, h *= b
                    }
                }
                e[t] = l, e[t + 1] = c, e[t + 2] = u, e[t + 3] = h
            }
            static multiplyQuaternionsFlat(e, t, n, i, r, s) {
                const o = n[i],
                    l = n[i + 1],
                    c = n[i + 2],
                    u = n[i + 3],
                    h = r[s],
                    f = r[s + 1],
                    d = r[s + 2],
                    m = r[s + 3];
                return e[t] = o * m + u * h + l * d - c * f, e[t + 1] = l * m + u * f + c * h - o * d, e[t + 2] = c * m + u * d + o * f - l * h, e[t + 3] = u * m - o * h - l * f - c * d, e
            }
            get x() {
                return this._x
            }
            set x(e) {
                this._x = e, this._onChangeCallback()
            }
            get y() {
                return this._y
            }
            set y(e) {
                this._y = e, this._onChangeCallback()
            }
            get z() {
                return this._z
            }
            set z(e) {
                this._z = e, this._onChangeCallback()
            }
            get w() {
                return this._w
            }
            set w(e) {
                this._w = e, this._onChangeCallback()
            }
            set(e, t, n, i) {
                return this._x = e, this._y = t, this._z = n, this._w = i, this._onChangeCallback(), this
            }
            clone() {
                return new this.constructor(this._x, this._y, this._z, this._w)
            }
            copy(e) {
                return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this
            }
            setFromEuler(e, t) {
                if (!(e && e.isEuler)) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
                const n = e._x,
                    i = e._y,
                    r = e._z,
                    s = e._order,
                    o = Math.cos,
                    l = Math.sin,
                    c = o(n / 2),
                    u = o(i / 2),
                    h = o(r / 2),
                    f = l(n / 2),
                    d = l(i / 2),
                    m = l(r / 2);
                switch (s) {
                    case "XYZ":
                        this._x = f * u * h + c * d * m, this._y = c * d * h - f * u * m, this._z = c * u * m + f * d * h, this._w = c * u * h - f * d * m;
                        break;
                    case "YXZ":
                        this._x = f * u * h + c * d * m, this._y = c * d * h - f * u * m, this._z = c * u * m - f * d * h, this._w = c * u * h + f * d * m;
                        break;
                    case "ZXY":
                        this._x = f * u * h - c * d * m, this._y = c * d * h + f * u * m, this._z = c * u * m + f * d * h, this._w = c * u * h - f * d * m;
                        break;
                    case "ZYX":
                        this._x = f * u * h - c * d * m, this._y = c * d * h + f * u * m, this._z = c * u * m - f * d * h, this._w = c * u * h + f * d * m;
                        break;
                    case "YZX":
                        this._x = f * u * h + c * d * m, this._y = c * d * h + f * u * m, this._z = c * u * m - f * d * h, this._w = c * u * h - f * d * m;
                        break;
                    case "XZY":
                        this._x = f * u * h - c * d * m, this._y = c * d * h - f * u * m, this._z = c * u * m + f * d * h, this._w = c * u * h + f * d * m;
                        break;
                    default:
                        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + s)
                }
                return t !== !1 && this._onChangeCallback(), this
            }
            setFromAxisAngle(e, t) {
                const n = t / 2,
                    i = Math.sin(n);
                return this._x = e.x * i, this._y = e.y * i, this._z = e.z * i, this._w = Math.cos(n), this._onChangeCallback(), this
            }
            setFromRotationMatrix(e) {
                const t = e.elements,
                    n = t[0],
                    i = t[4],
                    r = t[8],
                    s = t[1],
                    o = t[5],
                    l = t[9],
                    c = t[2],
                    u = t[6],
                    h = t[10],
                    f = n + o + h;
                if (f > 0) {
                    const d = .5 / Math.sqrt(f + 1);
                    this._w = .25 / d, this._x = (u - l) * d, this._y = (r - c) * d, this._z = (s - i) * d
                } else if (n > o && n > h) {
                    const d = 2 * Math.sqrt(1 + n - o - h);
                    this._w = (u - l) / d, this._x = .25 * d, this._y = (i + s) / d, this._z = (r + c) / d
                } else if (o > h) {
                    const d = 2 * Math.sqrt(1 + o - n - h);
                    this._w = (r - c) / d, this._x = (i + s) / d, this._y = .25 * d, this._z = (l + u) / d
                } else {
                    const d = 2 * Math.sqrt(1 + h - n - o);
                    this._w = (s - i) / d, this._x = (r + c) / d, this._y = (l + u) / d, this._z = .25 * d
                }
                return this._onChangeCallback(), this
            }
            setFromUnitVectors(e, t) {
                let n = e.dot(t) + 1;
                return n < Number.EPSILON ? (n = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = n)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = n), this.normalize()
            }
            angleTo(e) {
                return 2 * Math.acos(Math.abs(Pt(this.dot(e), -1, 1)))
            }
            rotateTowards(e, t) {
                const n = this.angleTo(e);
                if (n === 0) return this;
                const i = Math.min(1, t / n);
                return this.slerp(e, i), this
            }
            identity() {
                return this.set(0, 0, 0, 1)
            }
            invert() {
                return this.conjugate()
            }
            conjugate() {
                return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
            }
            dot(e) {
                return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
            }
            lengthSq() {
                return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
            }
            length() {
                return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
            }
            normalize() {
                let e = this.length();
                return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this
            }
            multiply(e, t) {
                return t !== void 0 ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(e, t)) : this.multiplyQuaternions(this, e)
            }
            premultiply(e) {
                return this.multiplyQuaternions(e, this)
            }
            multiplyQuaternions(e, t) {
                const n = e._x,
                    i = e._y,
                    r = e._z,
                    s = e._w,
                    o = t._x,
                    l = t._y,
                    c = t._z,
                    u = t._w;
                return this._x = n * u + s * o + i * c - r * l, this._y = i * u + s * l + r * o - n * c, this._z = r * u + s * c + n * l - i * o, this._w = s * u - n * o - i * l - r * c, this._onChangeCallback(), this
            }
            slerp(e, t) {
                if (t === 0) return this;
                if (t === 1) return this.copy(e);
                const n = this._x,
                    i = this._y,
                    r = this._z,
                    s = this._w;
                let o = s * e._w + n * e._x + i * e._y + r * e._z;
                if (o < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, o = -o) : this.copy(e), o >= 1) return this._w = s, this._x = n, this._y = i, this._z = r, this;
                const l = 1 - o * o;
                if (l <= Number.EPSILON) {
                    const d = 1 - t;
                    return this._w = d * s + t * this._w, this._x = d * n + t * this._x, this._y = d * i + t * this._y, this._z = d * r + t * this._z, this.normalize(), this._onChangeCallback(), this
                }
                const c = Math.sqrt(l),
                    u = Math.atan2(c, o),
                    h = Math.sin((1 - t) * u) / c,
                    f = Math.sin(t * u) / c;
                return this._w = s * h + this._w * f, this._x = n * h + this._x * f, this._y = i * h + this._y * f, this._z = r * h + this._z * f, this._onChangeCallback(), this
            }
            slerpQuaternions(e, t, n) {
                this.copy(e).slerp(t, n)
            }
            random() {
                const e = Math.random(),
                    t = Math.sqrt(1 - e),
                    n = Math.sqrt(e),
                    i = 2 * Math.PI * Math.random(),
                    r = 2 * Math.PI * Math.random();
                return this.set(t * Math.cos(i), n * Math.sin(r), n * Math.cos(r), t * Math.sin(i))
            }
            equals(e) {
                return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
            }
            fromArray(e, t = 0) {
                return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this
            }
            toArray(e = [], t = 0) {
                return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e
            }
            fromBufferAttribute(e, t) {
                return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this
            }
            _onChange(e) {
                return this._onChangeCallback = e, this
            }
            _onChangeCallback() {}
        }
        At.prototype.isQuaternion = !0;
        class E {
            constructor(e = 0, t = 0, n = 0) {
                this.x = e, this.y = t, this.z = n
            }
            set(e, t, n) {
                return n === void 0 && (n = this.z), this.x = e, this.y = t, this.z = n, this
            }
            setScalar(e) {
                return this.x = e, this.y = e, this.z = e, this
            }
            setX(e) {
                return this.x = e, this
            }
            setY(e) {
                return this.y = e, this
            }
            setZ(e) {
                return this.z = e, this
            }
            setComponent(e, t) {
                switch (e) {
                    case 0:
                        this.x = t;
                        break;
                    case 1:
                        this.y = t;
                        break;
                    case 2:
                        this.z = t;
                        break;
                    default:
                        throw new Error("index is out of range: " + e)
                }
                return this
            }
            getComponent(e) {
                switch (e) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    case 2:
                        return this.z;
                    default:
                        throw new Error("index is out of range: " + e)
                }
            }
            clone() {
                return new this.constructor(this.x, this.y, this.z)
            }
            copy(e) {
                return this.x = e.x, this.y = e.y, this.z = e.z, this
            }
            add(e, t) {
                return t !== void 0 ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this)
            }
            addScalar(e) {
                return this.x += e, this.y += e, this.z += e, this
            }
            addVectors(e, t) {
                return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this
            }
            addScaledVector(e, t) {
                return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this
            }
            sub(e, t) {
                return t !== void 0 ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this)
            }
            subScalar(e) {
                return this.x -= e, this.y -= e, this.z -= e, this
            }
            subVectors(e, t) {
                return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this
            }
            multiply(e, t) {
                return t !== void 0 ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(e, t)) : (this.x *= e.x, this.y *= e.y, this.z *= e.z, this)
            }
            multiplyScalar(e) {
                return this.x *= e, this.y *= e, this.z *= e, this
            }
            multiplyVectors(e, t) {
                return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this
            }
            applyEuler(e) {
                return e && e.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(eu.setFromEuler(e))
            }
            applyAxisAngle(e, t) {
                return this.applyQuaternion(eu.setFromAxisAngle(e, t))
            }
            applyMatrix3(e) {
                const t = this.x,
                    n = this.y,
                    i = this.z,
                    r = e.elements;
                return this.x = r[0] * t + r[3] * n + r[6] * i, this.y = r[1] * t + r[4] * n + r[7] * i, this.z = r[2] * t + r[5] * n + r[8] * i, this
            }
            applyNormalMatrix(e) {
                return this.applyMatrix3(e).normalize()
            }
            applyMatrix4(e) {
                const t = this.x,
                    n = this.y,
                    i = this.z,
                    r = e.elements,
                    s = 1 / (r[3] * t + r[7] * n + r[11] * i + r[15]);
                return this.x = (r[0] * t + r[4] * n + r[8] * i + r[12]) * s, this.y = (r[1] * t + r[5] * n + r[9] * i + r[13]) * s, this.z = (r[2] * t + r[6] * n + r[10] * i + r[14]) * s, this
            }
            applyQuaternion(e) {
                const t = this.x,
                    n = this.y,
                    i = this.z,
                    r = e.x,
                    s = e.y,
                    o = e.z,
                    l = e.w,
                    c = l * t + s * i - o * n,
                    u = l * n + o * t - r * i,
                    h = l * i + r * n - s * t,
                    f = -r * t - s * n - o * i;
                return this.x = c * l + f * -r + u * -o - h * -s, this.y = u * l + f * -s + h * -r - c * -o, this.z = h * l + f * -o + c * -s - u * -r, this
            }
            project(e) {
                return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
            }
            unproject(e) {
                return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
            }
            transformDirection(e) {
                const t = this.x,
                    n = this.y,
                    i = this.z,
                    r = e.elements;
                return this.x = r[0] * t + r[4] * n + r[8] * i, this.y = r[1] * t + r[5] * n + r[9] * i, this.z = r[2] * t + r[6] * n + r[10] * i, this.normalize()
            }
            divide(e) {
                return this.x /= e.x, this.y /= e.y, this.z /= e.z, this
            }
            divideScalar(e) {
                return this.multiplyScalar(1 / e)
            }
            min(e) {
                return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this
            }
            max(e) {
                return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this
            }
            clamp(e, t) {
                return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this
            }
            clampScalar(e, t) {
                return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this
            }
            clampLength(e, t) {
                const n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
            }
            floor() {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
            }
            ceil() {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
            }
            round() {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
            }
            roundToZero() {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
            }
            negate() {
                return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
            }
            dot(e) {
                return this.x * e.x + this.y * e.y + this.z * e.z
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y + this.z * this.z
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            setLength(e) {
                return this.normalize().multiplyScalar(e)
            }
            lerp(e, t) {
                return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this
            }
            lerpVectors(e, t, n) {
                return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this
            }
            cross(e, t) {
                return t !== void 0 ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(e, t)) : this.crossVectors(this, e)
            }
            crossVectors(e, t) {
                const n = e.x,
                    i = e.y,
                    r = e.z,
                    s = t.x,
                    o = t.y,
                    l = t.z;
                return this.x = i * l - r * o, this.y = r * s - n * l, this.z = n * o - i * s, this
            }
            projectOnVector(e) {
                const t = e.lengthSq();
                if (t === 0) return this.set(0, 0, 0);
                const n = e.dot(this) / t;
                return this.copy(e).multiplyScalar(n)
            }
            projectOnPlane(e) {
                return vo.copy(this).projectOnVector(e), this.sub(vo)
            }
            reflect(e) {
                return this.sub(vo.copy(e).multiplyScalar(2 * this.dot(e)))
            }
            angleTo(e) {
                const t = Math.sqrt(this.lengthSq() * e.lengthSq());
                if (t === 0) return Math.PI / 2;
                const n = this.dot(e) / t;
                return Math.acos(Pt(n, -1, 1))
            }
            distanceTo(e) {
                return Math.sqrt(this.distanceToSquared(e))
            }
            distanceToSquared(e) {
                const t = this.x - e.x,
                    n = this.y - e.y,
                    i = this.z - e.z;
                return t * t + n * n + i * i
            }
            manhattanDistanceTo(e) {
                return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
            }
            setFromSpherical(e) {
                return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
            }
            setFromSphericalCoords(e, t, n) {
                const i = Math.sin(t) * e;
                return this.x = i * Math.sin(n), this.y = Math.cos(t) * e, this.z = i * Math.cos(n), this
            }
            setFromCylindrical(e) {
                return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
            }
            setFromCylindricalCoords(e, t, n) {
                return this.x = e * Math.sin(t), this.y = n, this.z = e * Math.cos(t), this
            }
            setFromMatrixPosition(e) {
                const t = e.elements;
                return this.x = t[12], this.y = t[13], this.z = t[14], this
            }
            setFromMatrixScale(e) {
                const t = this.setFromMatrixColumn(e, 0).length(),
                    n = this.setFromMatrixColumn(e, 1).length(),
                    i = this.setFromMatrixColumn(e, 2).length();
                return this.x = t, this.y = n, this.z = i, this
            }
            setFromMatrixColumn(e, t) {
                return this.fromArray(e.elements, t * 4)
            }
            setFromMatrix3Column(e, t) {
                return this.fromArray(e.elements, t * 3)
            }
            equals(e) {
                return e.x === this.x && e.y === this.y && e.z === this.z
            }
            fromArray(e, t = 0) {
                return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this
            }
            toArray(e = [], t = 0) {
                return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e
            }
            fromBufferAttribute(e, t, n) {
                return n !== void 0 && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this
            }
            random() {
                return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
            }
            randomDirection() {
                const e = (Math.random() - .5) * 2,
                    t = Math.random() * Math.PI * 2,
                    n = Math.sqrt(1 - e ** 2);
                return this.x = n * Math.cos(t), this.y = n * Math.sin(t), this.z = e, this
            }*[Symbol.iterator]() {
                yield this.x, yield this.y, yield this.z
            }
        }
        E.prototype.isVector3 = !0;
        const vo = new E,
            eu = new At;
        class jt {
            constructor(e = new E(1 / 0, 1 / 0, 1 / 0), t = new E(-1 / 0, -1 / 0, -1 / 0)) {
                this.min = e, this.max = t
            }
            set(e, t) {
                return this.min.copy(e), this.max.copy(t), this
            }
            setFromArray(e) {
                let t = 1 / 0,
                    n = 1 / 0,
                    i = 1 / 0,
                    r = -1 / 0,
                    s = -1 / 0,
                    o = -1 / 0;
                for (let l = 0, c = e.length; l < c; l += 3) {
                    const u = e[l],
                        h = e[l + 1],
                        f = e[l + 2];
                    u < t && (t = u), h < n && (n = h), f < i && (i = f), u > r && (r = u), h > s && (s = h), f > o && (o = f)
                }
                return this.min.set(t, n, i), this.max.set(r, s, o), this
            }
            setFromBufferAttribute(e) {
                let t = 1 / 0,
                    n = 1 / 0,
                    i = 1 / 0,
                    r = -1 / 0,
                    s = -1 / 0,
                    o = -1 / 0;
                for (let l = 0, c = e.count; l < c; l++) {
                    const u = e.getX(l),
                        h = e.getY(l),
                        f = e.getZ(l);
                    u < t && (t = u), h < n && (n = h), f < i && (i = f), u > r && (r = u), h > s && (s = h), f > o && (o = f)
                }
                return this.min.set(t, n, i), this.max.set(r, s, o), this
            }
            setFromPoints(e) {
                this.makeEmpty();
                for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
                return this
            }
            setFromCenterAndSize(e, t) {
                const n = rs.copy(t).multiplyScalar(.5);
                return this.min.copy(e).sub(n), this.max.copy(e).add(n), this
            }
            setFromObject(e) {
                return this.makeEmpty(), this.expandByObject(e)
            }
            clone() {
                return new this.constructor().copy(this)
            }
            copy(e) {
                return this.min.copy(e.min), this.max.copy(e.max), this
            }
            makeEmpty() {
                return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
            }
            isEmpty() {
                return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
            }
            getCenter(e) {
                return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
            }
            getSize(e) {
                return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
            }
            expandByPoint(e) {
                return this.min.min(e), this.max.max(e), this
            }
            expandByVector(e) {
                return this.min.sub(e), this.max.add(e), this
            }
            expandByScalar(e) {
                return this.min.addScalar(-e), this.max.addScalar(e), this
            }
            expandByObject(e) {
                e.updateWorldMatrix(!1, !1);
                const t = e.geometry;
                t !== void 0 && (t.boundingBox === null && t.computeBoundingBox(), xo.copy(t.boundingBox), xo.applyMatrix4(e.matrixWorld), this.union(xo));
                const n = e.children;
                for (let i = 0, r = n.length; i < r; i++) this.expandByObject(n[i]);
                return this
            }
            containsPoint(e) {
                return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z)
            }
            containsBox(e) {
                return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
            }
            getParameter(e, t) {
                return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
            }
            intersectsBox(e) {
                return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z)
            }
            intersectsSphere(e) {
                return this.clampPoint(e.center, rs), rs.distanceToSquared(e.center) <= e.radius * e.radius
            }
            intersectsPlane(e) {
                let t, n;
                return e.normal.x > 0 ? (t = e.normal.x * this.min.x, n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, n = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, n += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, n += e.normal.z * this.min.z), t <= -e.constant && n >= -e.constant
            }
            intersectsTriangle(e) {
                if (this.isEmpty()) return !1;
                this.getCenter(ss), ta.subVectors(this.max, ss), Qi.subVectors(e.a, ss), er.subVectors(e.b, ss), tr.subVectors(e.c, ss), Gn.subVectors(er, Qi), Hn.subVectors(tr, er), wi.subVectors(Qi, tr);
                let t = [0, -Gn.z, Gn.y, 0, -Hn.z, Hn.y, 0, -wi.z, wi.y, Gn.z, 0, -Gn.x, Hn.z, 0, -Hn.x, wi.z, 0, -wi.x, -Gn.y, Gn.x, 0, -Hn.y, Hn.x, 0, -wi.y, wi.x, 0];
                return !yo(t, Qi, er, tr, ta) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !yo(t, Qi, er, tr, ta)) ? !1 : (na.crossVectors(Gn, Hn), t = [na.x, na.y, na.z], yo(t, Qi, er, tr, ta))
            }
            clampPoint(e, t) {
                return t.copy(e).clamp(this.min, this.max)
            }
            distanceToPoint(e) {
                return rs.copy(e).clamp(this.min, this.max).sub(e).length()
            }
            getBoundingSphere(e) {
                return this.getCenter(e.center), e.radius = this.getSize(rs).length() * .5, e
            }
            intersect(e) {
                return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this
            }
            union(e) {
                return this.min.min(e.min), this.max.max(e.max), this
            }
            applyMatrix4(e) {
                return this.isEmpty() ? this : (Mn[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), Mn[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), Mn[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), Mn[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), Mn[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), Mn[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), Mn[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), Mn[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(Mn), this)
            }
            translate(e) {
                return this.min.add(e), this.max.add(e), this
            }
            equals(e) {
                return e.min.equals(this.min) && e.max.equals(this.max)
            }
        }
        jt.prototype.isBox3 = !0;
        const Mn = [new E, new E, new E, new E, new E, new E, new E, new E],
            rs = new E,
            xo = new jt,
            Qi = new E,
            er = new E,
            tr = new E,
            Gn = new E,
            Hn = new E,
            wi = new E,
            ss = new E,
            ta = new E,
            na = new E,
            Si = new E;

        function yo(a, e, t, n, i) {
            for (let r = 0, s = a.length - 3; r <= s; r += 3) {
                Si.fromArray(a, r);
                const o = i.x * Math.abs(Si.x) + i.y * Math.abs(Si.y) + i.z * Math.abs(Si.z),
                    l = e.dot(Si),
                    c = t.dot(Si),
                    u = n.dot(Si);
                if (Math.max(-Math.max(l, c, u), Math.min(l, c, u)) > o) return !1
            }
            return !0
        }
        const Rm = new jt,
            tu = new E,
            Mo = new E,
            bo = new E;
        class Ti {
            constructor(e = new E, t = -1) {
                this.center = e, this.radius = t
            }
            set(e, t) {
                return this.center.copy(e), this.radius = t, this
            }
            setFromPoints(e, t) {
                const n = this.center;
                t !== void 0 ? n.copy(t) : Rm.setFromPoints(e).getCenter(n);
                let i = 0;
                for (let r = 0, s = e.length; r < s; r++) i = Math.max(i, n.distanceToSquared(e[r]));
                return this.radius = Math.sqrt(i), this
            }
            copy(e) {
                return this.center.copy(e.center), this.radius = e.radius, this
            }
            isEmpty() {
                return this.radius < 0
            }
            makeEmpty() {
                return this.center.set(0, 0, 0), this.radius = -1, this
            }
            containsPoint(e) {
                return e.distanceToSquared(this.center) <= this.radius * this.radius
            }
            distanceToPoint(e) {
                return e.distanceTo(this.center) - this.radius
            }
            intersectsSphere(e) {
                const t = this.radius + e.radius;
                return e.center.distanceToSquared(this.center) <= t * t
            }
            intersectsBox(e) {
                return e.intersectsSphere(this)
            }
            intersectsPlane(e) {
                return Math.abs(e.distanceToPoint(this.center)) <= this.radius
            }
            clampPoint(e, t) {
                const n = this.center.distanceToSquared(e);
                return t.copy(e), n > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t
            }
            getBoundingBox(e) {
                return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e)
            }
            applyMatrix4(e) {
                return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this
            }
            translate(e) {
                return this.center.add(e), this
            }
            expandByPoint(e) {
                bo.subVectors(e, this.center);
                const t = bo.lengthSq();
                if (t > this.radius * this.radius) {
                    const n = Math.sqrt(t),
                        i = (n - this.radius) * .5;
                    this.center.add(bo.multiplyScalar(i / n)), this.radius += i
                }
                return this
            }
            union(e) {
                return Mo.subVectors(e.center, this.center).normalize().multiplyScalar(e.radius), this.expandByPoint(tu.copy(e.center).add(Mo)), this.expandByPoint(tu.copy(e.center).sub(Mo)), this
            }
            equals(e) {
                return e.center.equals(this.center) && e.radius === this.radius
            }
            clone() {
                return new this.constructor().copy(this)
            }
        }
        const bn = new E,
            wo = new E,
            ia = new E,
            Vn = new E,
            So = new E,
            ra = new E,
            To = new E;
        class Ei {
            constructor(e = new E, t = new E(0, 0, -1)) {
                this.origin = e, this.direction = t
            }
            set(e, t) {
                return this.origin.copy(e), this.direction.copy(t), this
            }
            copy(e) {
                return this.origin.copy(e.origin), this.direction.copy(e.direction), this
            }
            at(e, t) {
                return t.copy(this.direction).multiplyScalar(e).add(this.origin)
            }
            lookAt(e) {
                return this.direction.copy(e).sub(this.origin).normalize(), this
            }
            recast(e) {
                return this.origin.copy(this.at(e, bn)), this
            }
            closestPointToPoint(e, t) {
                t.subVectors(e, this.origin);
                const n = t.dot(this.direction);
                return n < 0 ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(n).add(this.origin)
            }
            distanceToPoint(e) {
                return Math.sqrt(this.distanceSqToPoint(e))
            }
            distanceSqToPoint(e) {
                const t = bn.subVectors(e, this.origin).dot(this.direction);
                return t < 0 ? this.origin.distanceToSquared(e) : (bn.copy(this.direction).multiplyScalar(t).add(this.origin), bn.distanceToSquared(e))
            }
            distanceSqToSegment(e, t, n, i) {
                wo.copy(e).add(t).multiplyScalar(.5), ia.copy(t).sub(e).normalize(), Vn.copy(this.origin).sub(wo);
                const r = e.distanceTo(t) * .5,
                    s = -this.direction.dot(ia),
                    o = Vn.dot(this.direction),
                    l = -Vn.dot(ia),
                    c = Vn.lengthSq(),
                    u = Math.abs(1 - s * s);
                let h, f, d, m;
                if (u > 0)
                    if (h = s * l - o, f = s * o - l, m = r * u, h >= 0)
                        if (f >= -m)
                            if (f <= m) {
                                const g = 1 / u;
                                h *= g, f *= g, d = h * (h + s * f + 2 * o) + f * (s * h + f + 2 * l) + c
                            } else f = r, h = Math.max(0, -(s * f + o)), d = -h * h + f * (f + 2 * l) + c;
                else f = -r, h = Math.max(0, -(s * f + o)), d = -h * h + f * (f + 2 * l) + c;
                else f <= -m ? (h = Math.max(0, -(-s * r + o)), f = h > 0 ? -r : Math.min(Math.max(-r, -l), r), d = -h * h + f * (f + 2 * l) + c) : f <= m ? (h = 0, f = Math.min(Math.max(-r, -l), r), d = f * (f + 2 * l) + c) : (h = Math.max(0, -(s * r + o)), f = h > 0 ? r : Math.min(Math.max(-r, -l), r), d = -h * h + f * (f + 2 * l) + c);
                else f = s > 0 ? -r : r, h = Math.max(0, -(s * f + o)), d = -h * h + f * (f + 2 * l) + c;
                return n && n.copy(this.direction).multiplyScalar(h).add(this.origin), i && i.copy(ia).multiplyScalar(f).add(wo), d
            }
            intersectSphere(e, t) {
                bn.subVectors(e.center, this.origin);
                const n = bn.dot(this.direction),
                    i = bn.dot(bn) - n * n,
                    r = e.radius * e.radius;
                if (i > r) return null;
                const s = Math.sqrt(r - i),
                    o = n - s,
                    l = n + s;
                return o < 0 && l < 0 ? null : o < 0 ? this.at(l, t) : this.at(o, t)
            }
            intersectsSphere(e) {
                return this.distanceSqToPoint(e.center) <= e.radius * e.radius
            }
            distanceToPlane(e) {
                const t = e.normal.dot(this.direction);
                if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
                const n = -(this.origin.dot(e.normal) + e.constant) / t;
                return n >= 0 ? n : null
            }
            intersectPlane(e, t) {
                const n = this.distanceToPlane(e);
                return n === null ? null : this.at(n, t)
            }
            intersectsPlane(e) {
                const t = e.distanceToPoint(this.origin);
                return t === 0 || e.normal.dot(this.direction) * t < 0
            }
            intersectBox(e, t) {
                let n, i, r, s, o, l;
                const c = 1 / this.direction.x,
                    u = 1 / this.direction.y,
                    h = 1 / this.direction.z,
                    f = this.origin;
                return c >= 0 ? (n = (e.min.x - f.x) * c, i = (e.max.x - f.x) * c) : (n = (e.max.x - f.x) * c, i = (e.min.x - f.x) * c), u >= 0 ? (r = (e.min.y - f.y) * u, s = (e.max.y - f.y) * u) : (r = (e.max.y - f.y) * u, s = (e.min.y - f.y) * u), n > s || r > i || ((r > n || n !== n) && (n = r), (s < i || i !== i) && (i = s), h >= 0 ? (o = (e.min.z - f.z) * h, l = (e.max.z - f.z) * h) : (o = (e.max.z - f.z) * h, l = (e.min.z - f.z) * h), n > l || o > i) || ((o > n || n !== n) && (n = o), (l < i || i !== i) && (i = l), i < 0) ? null : this.at(n >= 0 ? n : i, t)
            }
            intersectsBox(e) {
                return this.intersectBox(e, bn) !== null
            }
            intersectTriangle(e, t, n, i, r) {
                So.subVectors(t, e), ra.subVectors(n, e), To.crossVectors(So, ra);
                let s = this.direction.dot(To),
                    o;
                if (s > 0) {
                    if (i) return null;
                    o = 1
                } else if (s < 0) o = -1, s = -s;
                else return null;
                Vn.subVectors(this.origin, e);
                const l = o * this.direction.dot(ra.crossVectors(Vn, ra));
                if (l < 0) return null;
                const c = o * this.direction.dot(So.cross(Vn));
                if (c < 0 || l + c > s) return null;
                const u = -o * Vn.dot(To);
                return u < 0 ? null : this.at(u / s, r)
            }
            applyMatrix4(e) {
                return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
            }
            equals(e) {
                return e.origin.equals(this.origin) && e.direction.equals(this.direction)
            }
            clone() {
                return new this.constructor().copy(this)
            }
        }
        class fe {
            constructor() {
                this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
            }
            set(e, t, n, i, r, s, o, l, c, u, h, f, d, m, g, v) {
                const p = this.elements;
                return p[0] = e, p[4] = t, p[8] = n, p[12] = i, p[1] = r, p[5] = s, p[9] = o, p[13] = l, p[2] = c, p[6] = u, p[10] = h, p[14] = f, p[3] = d, p[7] = m, p[11] = g, p[15] = v, this
            }
            identity() {
                return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
            }
            clone() {
                return new fe().fromArray(this.elements)
            }
            copy(e) {
                const t = this.elements,
                    n = e.elements;
                return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], this
            }
            copyPosition(e) {
                const t = this.elements,
                    n = e.elements;
                return t[12] = n[12], t[13] = n[13], t[14] = n[14], this
            }
            setFromMatrix3(e) {
                const t = e.elements;
                return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1), this
            }
            extractBasis(e, t, n) {
                return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this
            }
            makeBasis(e, t, n) {
                return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1), this
            }
            extractRotation(e) {
                const t = this.elements,
                    n = e.elements,
                    i = 1 / nr.setFromMatrixColumn(e, 0).length(),
                    r = 1 / nr.setFromMatrixColumn(e, 1).length(),
                    s = 1 / nr.setFromMatrixColumn(e, 2).length();
                return t[0] = n[0] * i, t[1] = n[1] * i, t[2] = n[2] * i, t[3] = 0, t[4] = n[4] * r, t[5] = n[5] * r, t[6] = n[6] * r, t[7] = 0, t[8] = n[8] * s, t[9] = n[9] * s, t[10] = n[10] * s, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
            }
            makeRotationFromEuler(e) {
                e && e.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
                const t = this.elements,
                    n = e.x,
                    i = e.y,
                    r = e.z,
                    s = Math.cos(n),
                    o = Math.sin(n),
                    l = Math.cos(i),
                    c = Math.sin(i),
                    u = Math.cos(r),
                    h = Math.sin(r);
                if (e.order === "XYZ") {
                    const f = s * u,
                        d = s * h,
                        m = o * u,
                        g = o * h;
                    t[0] = l * u, t[4] = -l * h, t[8] = c, t[1] = d + m * c, t[5] = f - g * c, t[9] = -o * l, t[2] = g - f * c, t[6] = m + d * c, t[10] = s * l
                } else if (e.order === "YXZ") {
                    const f = l * u,
                        d = l * h,
                        m = c * u,
                        g = c * h;
                    t[0] = f + g * o, t[4] = m * o - d, t[8] = s * c, t[1] = s * h, t[5] = s * u, t[9] = -o, t[2] = d * o - m, t[6] = g + f * o, t[10] = s * l
                } else if (e.order === "ZXY") {
                    const f = l * u,
                        d = l * h,
                        m = c * u,
                        g = c * h;
                    t[0] = f - g * o, t[4] = -s * h, t[8] = m + d * o, t[1] = d + m * o, t[5] = s * u, t[9] = g - f * o, t[2] = -s * c, t[6] = o, t[10] = s * l
                } else if (e.order === "ZYX") {
                    const f = s * u,
                        d = s * h,
                        m = o * u,
                        g = o * h;
                    t[0] = l * u, t[4] = m * c - d, t[8] = f * c + g, t[1] = l * h, t[5] = g * c + f, t[9] = d * c - m, t[2] = -c, t[6] = o * l, t[10] = s * l
                } else if (e.order === "YZX") {
                    const f = s * l,
                        d = s * c,
                        m = o * l,
                        g = o * c;
                    t[0] = l * u, t[4] = g - f * h, t[8] = m * h + d, t[1] = h, t[5] = s * u, t[9] = -o * u, t[2] = -c * u, t[6] = d * h + m, t[10] = f - g * h
                } else if (e.order === "XZY") {
                    const f = s * l,
                        d = s * c,
                        m = o * l,
                        g = o * c;
                    t[0] = l * u, t[4] = -h, t[8] = c * u, t[1] = f * h + g, t[5] = s * u, t[9] = d * h - m, t[2] = m * h - d, t[6] = o * u, t[10] = g * h + f
                }
                return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
            }
            makeRotationFromQuaternion(e) {
                return this.compose(Cm, e, Pm)
            }
            lookAt(e, t, n) {
                const i = this.elements;
                return Ut.subVectors(e, t), Ut.lengthSq() === 0 && (Ut.z = 1), Ut.normalize(), Wn.crossVectors(n, Ut), Wn.lengthSq() === 0 && (Math.abs(n.z) === 1 ? Ut.x += 1e-4 : Ut.z += 1e-4, Ut.normalize(), Wn.crossVectors(n, Ut)), Wn.normalize(), sa.crossVectors(Ut, Wn), i[0] = Wn.x, i[4] = sa.x, i[8] = Ut.x, i[1] = Wn.y, i[5] = sa.y, i[9] = Ut.y, i[2] = Wn.z, i[6] = sa.z, i[10] = Ut.z, this
            }
            multiply(e, t) {
                return t !== void 0 ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(e, t)) : this.multiplyMatrices(this, e)
            }
            premultiply(e) {
                return this.multiplyMatrices(e, this)
            }
            multiplyMatrices(e, t) {
                const n = e.elements,
                    i = t.elements,
                    r = this.elements,
                    s = n[0],
                    o = n[4],
                    l = n[8],
                    c = n[12],
                    u = n[1],
                    h = n[5],
                    f = n[9],
                    d = n[13],
                    m = n[2],
                    g = n[6],
                    v = n[10],
                    p = n[14],
                    _ = n[3],
                    M = n[7],
                    y = n[11],
                    b = n[15],
                    T = i[0],
                    x = i[4],
                    R = i[8],
                    P = i[12],
                    I = i[1],
                    L = i[5],
                    Y = i[9],
                    D = i[13],
                    F = i[2],
                    N = i[6],
                    z = i[10],
                    k = i[14],
                    J = i[3],
                    oe = i[7],
                    he = i[11],
                    ie = i[15];
                return r[0] = s * T + o * I + l * F + c * J, r[4] = s * x + o * L + l * N + c * oe, r[8] = s * R + o * Y + l * z + c * he, r[12] = s * P + o * D + l * k + c * ie, r[1] = u * T + h * I + f * F + d * J, r[5] = u * x + h * L + f * N + d * oe, r[9] = u * R + h * Y + f * z + d * he, r[13] = u * P + h * D + f * k + d * ie, r[2] = m * T + g * I + v * F + p * J, r[6] = m * x + g * L + v * N + p * oe, r[10] = m * R + g * Y + v * z + p * he, r[14] = m * P + g * D + v * k + p * ie, r[3] = _ * T + M * I + y * F + b * J, r[7] = _ * x + M * L + y * N + b * oe, r[11] = _ * R + M * Y + y * z + b * he, r[15] = _ * P + M * D + y * k + b * ie, this
            }
            multiplyScalar(e) {
                const t = this.elements;
                return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this
            }
            determinant() {
                const e = this.elements,
                    t = e[0],
                    n = e[4],
                    i = e[8],
                    r = e[12],
                    s = e[1],
                    o = e[5],
                    l = e[9],
                    c = e[13],
                    u = e[2],
                    h = e[6],
                    f = e[10],
                    d = e[14],
                    m = e[3],
                    g = e[7],
                    v = e[11],
                    p = e[15];
                return m * (+r * l * h - i * c * h - r * o * f + n * c * f + i * o * d - n * l * d) + g * (+t * l * d - t * c * f + r * s * f - i * s * d + i * c * u - r * l * u) + v * (+t * c * h - t * o * d - r * s * h + n * s * d + r * o * u - n * c * u) + p * (-i * o * u - t * l * h + t * o * f + i * s * h - n * s * f + n * l * u)
            }
            transpose() {
                const e = this.elements;
                let t;
                return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this
            }
            setPosition(e, t, n) {
                const i = this.elements;
                return e.isVector3 ? (i[12] = e.x, i[13] = e.y, i[14] = e.z) : (i[12] = e, i[13] = t, i[14] = n), this
            }
            invert() {
                const e = this.elements,
                    t = e[0],
                    n = e[1],
                    i = e[2],
                    r = e[3],
                    s = e[4],
                    o = e[5],
                    l = e[6],
                    c = e[7],
                    u = e[8],
                    h = e[9],
                    f = e[10],
                    d = e[11],
                    m = e[12],
                    g = e[13],
                    v = e[14],
                    p = e[15],
                    _ = h * v * c - g * f * c + g * l * d - o * v * d - h * l * p + o * f * p,
                    M = m * f * c - u * v * c - m * l * d + s * v * d + u * l * p - s * f * p,
                    y = u * g * c - m * h * c + m * o * d - s * g * d - u * o * p + s * h * p,
                    b = m * h * l - u * g * l - m * o * f + s * g * f + u * o * v - s * h * v,
                    T = t * _ + n * M + i * y + r * b;
                if (T === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                const x = 1 / T;
                return e[0] = _ * x, e[1] = (g * f * r - h * v * r - g * i * d + n * v * d + h * i * p - n * f * p) * x, e[2] = (o * v * r - g * l * r + g * i * c - n * v * c - o * i * p + n * l * p) * x, e[3] = (h * l * r - o * f * r - h * i * c + n * f * c + o * i * d - n * l * d) * x, e[4] = M * x, e[5] = (u * v * r - m * f * r + m * i * d - t * v * d - u * i * p + t * f * p) * x, e[6] = (m * l * r - s * v * r - m * i * c + t * v * c + s * i * p - t * l * p) * x, e[7] = (s * f * r - u * l * r + u * i * c - t * f * c - s * i * d + t * l * d) * x, e[8] = y * x, e[9] = (m * h * r - u * g * r - m * n * d + t * g * d + u * n * p - t * h * p) * x, e[10] = (s * g * r - m * o * r + m * n * c - t * g * c - s * n * p + t * o * p) * x, e[11] = (u * o * r - s * h * r - u * n * c + t * h * c + s * n * d - t * o * d) * x, e[12] = b * x, e[13] = (u * g * i - m * h * i + m * n * f - t * g * f - u * n * v + t * h * v) * x, e[14] = (m * o * i - s * g * i - m * n * l + t * g * l + s * n * v - t * o * v) * x, e[15] = (s * h * i - u * o * i + u * n * l - t * h * l - s * n * f + t * o * f) * x, this
            }
            scale(e) {
                const t = this.elements,
                    n = e.x,
                    i = e.y,
                    r = e.z;
                return t[0] *= n, t[4] *= i, t[8] *= r, t[1] *= n, t[5] *= i, t[9] *= r, t[2] *= n, t[6] *= i, t[10] *= r, t[3] *= n, t[7] *= i, t[11] *= r, this
            }
            getMaxScaleOnAxis() {
                const e = this.elements,
                    t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
                    n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
                    i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
                return Math.sqrt(Math.max(t, n, i))
            }
            makeTranslation(e, t, n) {
                return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this
            }
            makeRotationX(e) {
                const t = Math.cos(e),
                    n = Math.sin(e);
                return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this
            }
            makeRotationY(e) {
                const t = Math.cos(e),
                    n = Math.sin(e);
                return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this
            }
            makeRotationZ(e) {
                const t = Math.cos(e),
                    n = Math.sin(e);
                return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
            }
            makeRotationAxis(e, t) {
                const n = Math.cos(t),
                    i = Math.sin(t),
                    r = 1 - n,
                    s = e.x,
                    o = e.y,
                    l = e.z,
                    c = r * s,
                    u = r * o;
                return this.set(c * s + n, c * o - i * l, c * l + i * o, 0, c * o + i * l, u * o + n, u * l - i * s, 0, c * l - i * o, u * l + i * s, r * l * l + n, 0, 0, 0, 0, 1), this
            }
            makeScale(e, t, n) {
                return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
            }
            makeShear(e, t, n, i, r, s) {
                return this.set(1, n, r, 0, e, 1, s, 0, t, i, 1, 0, 0, 0, 0, 1), this
            }
            compose(e, t, n) {
                const i = this.elements,
                    r = t._x,
                    s = t._y,
                    o = t._z,
                    l = t._w,
                    c = r + r,
                    u = s + s,
                    h = o + o,
                    f = r * c,
                    d = r * u,
                    m = r * h,
                    g = s * u,
                    v = s * h,
                    p = o * h,
                    _ = l * c,
                    M = l * u,
                    y = l * h,
                    b = n.x,
                    T = n.y,
                    x = n.z;
                return i[0] = (1 - (g + p)) * b, i[1] = (d + y) * b, i[2] = (m - M) * b, i[3] = 0, i[4] = (d - y) * T, i[5] = (1 - (f + p)) * T, i[6] = (v + _) * T, i[7] = 0, i[8] = (m + M) * x, i[9] = (v - _) * x, i[10] = (1 - (f + g)) * x, i[11] = 0, i[12] = e.x, i[13] = e.y, i[14] = e.z, i[15] = 1, this
            }
            decompose(e, t, n) {
                const i = this.elements;
                let r = nr.set(i[0], i[1], i[2]).length();
                const s = nr.set(i[4], i[5], i[6]).length(),
                    o = nr.set(i[8], i[9], i[10]).length();
                this.determinant() < 0 && (r = -r), e.x = i[12], e.y = i[13], e.z = i[14], rn.copy(this);
                const c = 1 / r,
                    u = 1 / s,
                    h = 1 / o;
                return rn.elements[0] *= c, rn.elements[1] *= c, rn.elements[2] *= c, rn.elements[4] *= u, rn.elements[5] *= u, rn.elements[6] *= u, rn.elements[8] *= h, rn.elements[9] *= h, rn.elements[10] *= h, t.setFromRotationMatrix(rn), n.x = r, n.y = s, n.z = o, this
            }
            makePerspective(e, t, n, i, r, s) {
                s === void 0 && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
                const o = this.elements,
                    l = 2 * r / (t - e),
                    c = 2 * r / (n - i),
                    u = (t + e) / (t - e),
                    h = (n + i) / (n - i),
                    f = -(s + r) / (s - r),
                    d = -2 * s * r / (s - r);
                return o[0] = l, o[4] = 0, o[8] = u, o[12] = 0, o[1] = 0, o[5] = c, o[9] = h, o[13] = 0, o[2] = 0, o[6] = 0, o[10] = f, o[14] = d, o[3] = 0, o[7] = 0, o[11] = -1, o[15] = 0, this
            }
            makeOrthographic(e, t, n, i, r, s) {
                const o = this.elements,
                    l = 1 / (t - e),
                    c = 1 / (n - i),
                    u = 1 / (s - r),
                    h = (t + e) * l,
                    f = (n + i) * c,
                    d = (s + r) * u;
                return o[0] = 2 * l, o[4] = 0, o[8] = 0, o[12] = -h, o[1] = 0, o[5] = 2 * c, o[9] = 0, o[13] = -f, o[2] = 0, o[6] = 0, o[10] = -2 * u, o[14] = -d, o[3] = 0, o[7] = 0, o[11] = 0, o[15] = 1, this
            }
            equals(e) {
                const t = this.elements,
                    n = e.elements;
                for (let i = 0; i < 16; i++)
                    if (t[i] !== n[i]) return !1;
                return !0
            }
            fromArray(e, t = 0) {
                for (let n = 0; n < 16; n++) this.elements[n] = e[n + t];
                return this
            }
            toArray(e = [], t = 0) {
                const n = this.elements;
                return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9], e[t + 10] = n[10], e[t + 11] = n[11], e[t + 12] = n[12], e[t + 13] = n[13], e[t + 14] = n[14], e[t + 15] = n[15], e
            }
        }
        fe.prototype.isMatrix4 = !0;
        const nr = new E,
            rn = new fe,
            Cm = new E(0, 0, 0),
            Pm = new E(1, 1, 1),
            Wn = new E,
            sa = new E,
            Ut = new E,
            nu = new fe,
            iu = new At;
        class ir {
            constructor(e = 0, t = 0, n = 0, i = ir.DefaultOrder) {
                this._x = e, this._y = t, this._z = n, this._order = i
            }
            get x() {
                return this._x
            }
            set x(e) {
                this._x = e, this._onChangeCallback()
            }
            get y() {
                return this._y
            }
            set y(e) {
                this._y = e, this._onChangeCallback()
            }
            get z() {
                return this._z
            }
            set z(e) {
                this._z = e, this._onChangeCallback()
            }
            get order() {
                return this._order
            }
            set order(e) {
                this._order = e, this._onChangeCallback()
            }
            set(e, t, n, i = this._order) {
                return this._x = e, this._y = t, this._z = n, this._order = i, this._onChangeCallback(), this
            }
            clone() {
                return new this.constructor(this._x, this._y, this._z, this._order)
            }
            copy(e) {
                return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this
            }
            setFromRotationMatrix(e, t = this._order, n = !0) {
                const i = e.elements,
                    r = i[0],
                    s = i[4],
                    o = i[8],
                    l = i[1],
                    c = i[5],
                    u = i[9],
                    h = i[2],
                    f = i[6],
                    d = i[10];
                switch (t) {
                    case "XYZ":
                        this._y = Math.asin(Pt(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(-u, d), this._z = Math.atan2(-s, r)) : (this._x = Math.atan2(f, c), this._z = 0);
                        break;
                    case "YXZ":
                        this._x = Math.asin(-Pt(u, -1, 1)), Math.abs(u) < .9999999 ? (this._y = Math.atan2(o, d), this._z = Math.atan2(l, c)) : (this._y = Math.atan2(-h, r), this._z = 0);
                        break;
                    case "ZXY":
                        this._x = Math.asin(Pt(f, -1, 1)), Math.abs(f) < .9999999 ? (this._y = Math.atan2(-h, d), this._z = Math.atan2(-s, c)) : (this._y = 0, this._z = Math.atan2(l, r));
                        break;
                    case "ZYX":
                        this._y = Math.asin(-Pt(h, -1, 1)), Math.abs(h) < .9999999 ? (this._x = Math.atan2(f, d), this._z = Math.atan2(l, r)) : (this._x = 0, this._z = Math.atan2(-s, c));
                        break;
                    case "YZX":
                        this._z = Math.asin(Pt(l, -1, 1)), Math.abs(l) < .9999999 ? (this._x = Math.atan2(-u, c), this._y = Math.atan2(-h, r)) : (this._x = 0, this._y = Math.atan2(o, d));
                        break;
                    case "XZY":
                        this._z = Math.asin(-Pt(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(f, c), this._y = Math.atan2(o, r)) : (this._x = Math.atan2(-u, d), this._y = 0);
                        break;
                    default:
                        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t)
                }
                return this._order = t, n === !0 && this._onChangeCallback(), this
            }
            setFromQuaternion(e, t, n) {
                return nu.makeRotationFromQuaternion(e), this.setFromRotationMatrix(nu, t, n)
            }
            setFromVector3(e, t = this._order) {
                return this.set(e.x, e.y, e.z, t)
            }
            reorder(e) {
                return iu.setFromEuler(this), this.setFromQuaternion(iu, e)
            }
            equals(e) {
                return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
            }
            fromArray(e) {
                return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this
            }
            toArray(e = [], t = 0) {
                return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e
            }
            toVector3(e) {
                return e ? e.set(this._x, this._y, this._z) : new E(this._x, this._y, this._z)
            }
            _onChange(e) {
                return this._onChangeCallback = e, this
            }
            _onChangeCallback() {}
        }
        ir.prototype.isEuler = !0, ir.DefaultOrder = "XYZ", ir.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
        class aa {
            constructor() {
                this.mask = 1 | 0
            }
            set(e) {
                this.mask = 1 << e | 0
            }
            enable(e) {
                this.mask |= 1 << e | 0
            }
            enableAll() {
                this.mask = 4294967295 | 0
            }
            toggle(e) {
                this.mask ^= 1 << e | 0
            }
            disable(e) {
                this.mask &= ~(1 << e | 0)
            }
            disableAll() {
                this.mask = 0
            }
            test(e) {
                return (this.mask & e.mask) != 0
            }
        }
        let Dm = 0;
        const ru = new E,
            rr = new At,
            wn = new fe,
            oa = new E,
            as = new E,
            Im = new E,
            Fm = new At,
            su = new E(1, 0, 0),
            au = new E(0, 1, 0),
            ou = new E(0, 0, 1),
            zm = {
                type: "added"
            },
            lu = {
                type: "removed"
            };
        class Te extends bi {
            constructor() {
                super();
                Object.defineProperty(this, "id", {
                    value: Dm++
                }), this.uuid = Xt(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Te.DefaultUp.clone();
                const e = new E,
                    t = new ir,
                    n = new At,
                    i = new E(1, 1, 1);

                function r() {
                    n.setFromEuler(t, !1)
                }

                function s() {
                    t.setFromQuaternion(n, void 0, !1)
                }
                t._onChange(r), n._onChange(s), Object.defineProperties(this, {
                    position: {
                        configurable: !0,
                        enumerable: !0,
                        value: e
                    },
                    rotation: {
                        configurable: !0,
                        enumerable: !0,
                        value: t
                    },
                    quaternion: {
                        configurable: !0,
                        enumerable: !0,
                        value: n
                    },
                    scale: {
                        configurable: !0,
                        enumerable: !0,
                        value: i
                    },
                    modelViewMatrix: {
                        value: new fe
                    },
                    normalMatrix: {
                        value: new mt
                    }
                }), this.matrix = new fe, this.matrixWorld = new fe, this.matrixAutoUpdate = Te.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new aa, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {}
            }
            onBeforeRender() {}
            onAfterRender() {}
            applyMatrix4(e) {
                this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale)
            }
            applyQuaternion(e) {
                return this.quaternion.premultiply(e), this
            }
            setRotationFromAxisAngle(e, t) {
                this.quaternion.setFromAxisAngle(e, t)
            }
            setRotationFromEuler(e) {
                this.quaternion.setFromEuler(e, !0)
            }
            setRotationFromMatrix(e) {
                this.quaternion.setFromRotationMatrix(e)
            }
            setRotationFromQuaternion(e) {
                this.quaternion.copy(e)
            }
            rotateOnAxis(e, t) {
                return rr.setFromAxisAngle(e, t), this.quaternion.multiply(rr), this
            }
            rotateOnWorldAxis(e, t) {
                return rr.setFromAxisAngle(e, t), this.quaternion.premultiply(rr), this
            }
            rotateX(e) {
                return this.rotateOnAxis(su, e)
            }
            rotateY(e) {
                return this.rotateOnAxis(au, e)
            }
            rotateZ(e) {
                return this.rotateOnAxis(ou, e)
            }
            translateOnAxis(e, t) {
                return ru.copy(e).applyQuaternion(this.quaternion), this.position.add(ru.multiplyScalar(t)), this
            }
            translateX(e) {
                return this.translateOnAxis(su, e)
            }
            translateY(e) {
                return this.translateOnAxis(au, e)
            }
            translateZ(e) {
                return this.translateOnAxis(ou, e)
            }
            localToWorld(e) {
                return e.applyMatrix4(this.matrixWorld)
            }
            worldToLocal(e) {
                return e.applyMatrix4(wn.copy(this.matrixWorld).invert())
            }
            lookAt(e, t, n) {
                e.isVector3 ? oa.copy(e) : oa.set(e, t, n);
                const i = this.parent;
                this.updateWorldMatrix(!0, !1), as.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? wn.lookAt(as, oa, this.up) : wn.lookAt(oa, as, this.up), this.quaternion.setFromRotationMatrix(wn), i && (wn.extractRotation(i.matrixWorld), rr.setFromRotationMatrix(wn), this.quaternion.premultiply(rr.invert()))
            }
            add(e) {
                if (arguments.length > 1) {
                    for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
                    return this
                }
                return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.parent !== null && e.parent.remove(e), e.parent = this, this.children.push(e), e.dispatchEvent(zm)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this)
            }
            remove(e) {
                if (arguments.length > 1) {
                    for (let n = 0; n < arguments.length; n++) this.remove(arguments[n]);
                    return this
                }
                const t = this.children.indexOf(e);
                return t !== -1 && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(lu)), this
            }
            removeFromParent() {
                const e = this.parent;
                return e !== null && e.remove(this), this
            }
            clear() {
                for (let e = 0; e < this.children.length; e++) {
                    const t = this.children[e];
                    t.parent = null, t.dispatchEvent(lu)
                }
                return this.children.length = 0, this
            }
            attach(e) {
                return this.updateWorldMatrix(!0, !1), wn.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), wn.multiply(e.parent.matrixWorld)), e.applyMatrix4(wn), this.add(e), e.updateWorldMatrix(!1, !0), this
            }
            getObjectById(e) {
                return this.getObjectByProperty("id", e)
            }
            getObjectByName(e) {
                return this.getObjectByProperty("name", e)
            }
            getObjectByProperty(e, t) {
                if (this[e] === t) return this;
                for (let n = 0, i = this.children.length; n < i; n++) {
                    const s = this.children[n].getObjectByProperty(e, t);
                    if (s !== void 0) return s
                }
            }
            getWorldPosition(e) {
                return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld)
            }
            getWorldQuaternion(e) {
                return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(as, e, Im), e
            }
            getWorldScale(e) {
                return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(as, Fm, e), e
            }
            getWorldDirection(e) {
                this.updateWorldMatrix(!0, !1);
                const t = this.matrixWorld.elements;
                return e.set(t[8], t[9], t[10]).normalize()
            }
            raycast() {}
            traverse(e) {
                e(this);
                const t = this.children;
                for (let n = 0, i = t.length; n < i; n++) t[n].traverse(e)
            }
            traverseVisible(e) {
                if (this.visible === !1) return;
                e(this);
                const t = this.children;
                for (let n = 0, i = t.length; n < i; n++) t[n].traverseVisible(e)
            }
            traverseAncestors(e) {
                const t = this.parent;
                t !== null && (e(t), t.traverseAncestors(e))
            }
            updateMatrix() {
                this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
            }
            updateMatrixWorld(e) {
                this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
                const t = this.children;
                for (let n = 0, i = t.length; n < i; n++) t[n].updateMatrixWorld(e)
            }
            updateWorldMatrix(e, t) {
                const n = this.parent;
                if (e === !0 && n !== null && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), t === !0) {
                    const i = this.children;
                    for (let r = 0, s = i.length; r < s; r++) i[r].updateWorldMatrix(!1, !0)
                }
            }
            toJSON(e) {
                const t = e === void 0 || typeof e == "string",
                    n = {};
                t && (e = {
                    geometries: {},
                    materials: {},
                    textures: {},
                    images: {},
                    shapes: {},
                    skeletons: {},
                    animations: {}
                }, n.metadata = {
                    version: 4.5,
                    type: "Object",
                    generator: "Object3D.toJSON"
                });
                const i = {};
                i.uuid = this.uuid, i.type = this.type, this.name !== "" && (i.name = this.name), this.castShadow === !0 && (i.castShadow = !0), this.receiveShadow === !0 && (i.receiveShadow = !0), this.visible === !1 && (i.visible = !1), this.frustumCulled === !1 && (i.frustumCulled = !1), this.renderOrder !== 0 && (i.renderOrder = this.renderOrder), JSON.stringify(this.userData) !== "{}" && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), this.matrixAutoUpdate === !1 && (i.matrixAutoUpdate = !1), this.isInstancedMesh && (i.type = "InstancedMesh", i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (i.instanceColor = this.instanceColor.toJSON()));

                function r(o, l) {
                    return o[l.uuid] === void 0 && (o[l.uuid] = l.toJSON(e)), l.uuid
                }
                if (this.isScene) this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && (i.environment = this.environment.toJSON(e).uuid);
                else if (this.isMesh || this.isLine || this.isPoints) {
                    i.geometry = r(e.geometries, this.geometry);
                    const o = this.geometry.parameters;
                    if (o !== void 0 && o.shapes !== void 0) {
                        const l = o.shapes;
                        if (Array.isArray(l))
                            for (let c = 0, u = l.length; c < u; c++) {
                                const h = l[c];
                                r(e.shapes, h)
                            } else r(e.shapes, l)
                    }
                }
                if (this.isSkinnedMesh && (i.bindMode = this.bindMode, i.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (r(e.skeletons, this.skeleton), i.skeleton = this.skeleton.uuid)), this.material !== void 0)
                    if (Array.isArray(this.material)) {
                        const o = [];
                        for (let l = 0, c = this.material.length; l < c; l++) o.push(r(e.materials, this.material[l]));
                        i.material = o
                    } else i.material = r(e.materials, this.material);
                if (this.children.length > 0) {
                    i.children = [];
                    for (let o = 0; o < this.children.length; o++) i.children.push(this.children[o].toJSON(e).object)
                }
                if (this.animations.length > 0) {
                    i.animations = [];
                    for (let o = 0; o < this.animations.length; o++) {
                        const l = this.animations[o];
                        i.animations.push(r(e.animations, l))
                    }
                }
                if (t) {
                    const o = s(e.geometries),
                        l = s(e.materials),
                        c = s(e.textures),
                        u = s(e.images),
                        h = s(e.shapes),
                        f = s(e.skeletons),
                        d = s(e.animations);
                    o.length > 0 && (n.geometries = o), l.length > 0 && (n.materials = l), c.length > 0 && (n.textures = c), u.length > 0 && (n.images = u), h.length > 0 && (n.shapes = h), f.length > 0 && (n.skeletons = f), d.length > 0 && (n.animations = d)
                }
                return n.object = i, n;

                function s(o) {
                    const l = [];
                    for (const c in o) {
                        const u = o[c];
                        delete u.metadata, l.push(u)
                    }
                    return l
                }
            }
            clone(e) {
                return new this.constructor().copy(this, e)
            }
            copy(e, t = !0) {
                if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.userData = JSON.parse(JSON.stringify(e.userData)), t === !0)
                    for (let n = 0; n < e.children.length; n++) {
                        const i = e.children[n];
                        this.add(i.clone())
                    }
                return this
            }
        }
        Te.DefaultUp = new E(0, 1, 0), Te.DefaultMatrixAutoUpdate = !0, Te.prototype.isObject3D = !0;
        const sn = new E,
            Sn = new E,
            Eo = new E,
            Tn = new E,
            sr = new E,
            ar = new E,
            cu = new E,
            Ao = new E,
            Lo = new E,
            Ro = new E;
        class it {
            constructor(e = new E, t = new E, n = new E) {
                this.a = e, this.b = t, this.c = n
            }
            static getNormal(e, t, n, i) {
                i.subVectors(n, t), sn.subVectors(e, t), i.cross(sn);
                const r = i.lengthSq();
                return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0)
            }
            static getBarycoord(e, t, n, i, r) {
                sn.subVectors(i, t), Sn.subVectors(n, t), Eo.subVectors(e, t);
                const s = sn.dot(sn),
                    o = sn.dot(Sn),
                    l = sn.dot(Eo),
                    c = Sn.dot(Sn),
                    u = Sn.dot(Eo),
                    h = s * c - o * o;
                if (h === 0) return r.set(-2, -1, -1);
                const f = 1 / h,
                    d = (c * l - o * u) * f,
                    m = (s * u - o * l) * f;
                return r.set(1 - d - m, m, d)
            }
            static containsPoint(e, t, n, i) {
                return this.getBarycoord(e, t, n, i, Tn), Tn.x >= 0 && Tn.y >= 0 && Tn.x + Tn.y <= 1
            }
            static getUV(e, t, n, i, r, s, o, l) {
                return this.getBarycoord(e, t, n, i, Tn), l.set(0, 0), l.addScaledVector(r, Tn.x), l.addScaledVector(s, Tn.y), l.addScaledVector(o, Tn.z), l
            }
            static isFrontFacing(e, t, n, i) {
                return sn.subVectors(n, t), Sn.subVectors(e, t), sn.cross(Sn).dot(i) < 0
            }
            set(e, t, n) {
                return this.a.copy(e), this.b.copy(t), this.c.copy(n), this
            }
            setFromPointsAndIndices(e, t, n, i) {
                return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[i]), this
            }
            setFromAttributeAndIndices(e, t, n, i) {
                return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, n), this.c.fromBufferAttribute(e, i), this
            }
            clone() {
                return new this.constructor().copy(this)
            }
            copy(e) {
                return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this
            }
            getArea() {
                return sn.subVectors(this.c, this.b), Sn.subVectors(this.a, this.b), sn.cross(Sn).length() * .5
            }
            getMidpoint(e) {
                return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
            }
            getNormal(e) {
                return it.getNormal(this.a, this.b, this.c, e)
            }
            getPlane(e) {
                return e.setFromCoplanarPoints(this.a, this.b, this.c)
            }
            getBarycoord(e, t) {
                return it.getBarycoord(e, this.a, this.b, this.c, t)
            }
            getUV(e, t, n, i, r) {
                return it.getUV(e, this.a, this.b, this.c, t, n, i, r)
            }
            containsPoint(e) {
                return it.containsPoint(e, this.a, this.b, this.c)
            }
            isFrontFacing(e) {
                return it.isFrontFacing(this.a, this.b, this.c, e)
            }
            intersectsBox(e) {
                return e.intersectsTriangle(this)
            }
            closestPointToPoint(e, t) {
                const n = this.a,
                    i = this.b,
                    r = this.c;
                let s, o;
                sr.subVectors(i, n), ar.subVectors(r, n), Ao.subVectors(e, n);
                const l = sr.dot(Ao),
                    c = ar.dot(Ao);
                if (l <= 0 && c <= 0) return t.copy(n);
                Lo.subVectors(e, i);
                const u = sr.dot(Lo),
                    h = ar.dot(Lo);
                if (u >= 0 && h <= u) return t.copy(i);
                const f = l * h - u * c;
                if (f <= 0 && l >= 0 && u <= 0) return s = l / (l - u), t.copy(n).addScaledVector(sr, s);
                Ro.subVectors(e, r);
                const d = sr.dot(Ro),
                    m = ar.dot(Ro);
                if (m >= 0 && d <= m) return t.copy(r);
                const g = d * c - l * m;
                if (g <= 0 && c >= 0 && m <= 0) return o = c / (c - m), t.copy(n).addScaledVector(ar, o);
                const v = u * m - d * h;
                if (v <= 0 && h - u >= 0 && d - m >= 0) return cu.subVectors(r, i), o = (h - u) / (h - u + (d - m)), t.copy(i).addScaledVector(cu, o);
                const p = 1 / (v + g + f);
                return s = g * p, o = f * p, t.copy(n).addScaledVector(sr, s).addScaledVector(ar, o)
            }
            equals(e) {
                return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
            }
        }
        let Nm = 0;
        class ot extends bi {
            constructor() {
                super();
                Object.defineProperty(this, "id", {
                    value: Nm++
                }), this.uuid = Xt(), this.name = "", this.type = "Material", this.fog = !0, this.blending = Jr, this.side = Vi, this.vertexColors = !1, this.opacity = 1, this.format = ct, this.transparent = !1, this.blendSrc = Rc, this.blendDst = Cc, this.blendEquation = Wi, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = no, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = fm, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = fo, this.stencilZFail = fo, this.stencilZPass = fo, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0
            }
            get alphaTest() {
                return this._alphaTest
            }
            set alphaTest(e) {
                this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e
            }
            onBuild() {}
            onBeforeRender() {}
            onBeforeCompile() {}
            customProgramCacheKey() {
                return this.onBeforeCompile.toString()
            }
            setValues(e) {
                if (e !== void 0)
                    for (const t in e) {
                        const n = e[t];
                        if (n === void 0) {
                            console.warn("THREE.Material: '" + t + "' parameter is undefined.");
                            continue
                        }
                        if (t === "shading") {
                            console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = n === Sc;
                            continue
                        }
                        const i = this[t];
                        if (i === void 0) {
                            console.warn("THREE." + this.type + ": '" + t + "' is not a property of this material.");
                            continue
                        }
                        i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[t] = n
                    }
            }
            toJSON(e) {
                const t = e === void 0 || typeof e == "string";
                t && (e = {
                    textures: {},
                    images: {}
                });
                const n = {
                    metadata: {
                        version: 4.5,
                        type: "Material",
                        generator: "Material.toJSON"
                    }
                };
                n.uuid = this.uuid, n.type = this.type, this.name !== "" && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), this.roughness !== void 0 && (n.roughness = this.roughness), this.metalness !== void 0 && (n.metalness = this.metalness), this.sheen !== void 0 && (n.sheen = this.sheen), this.sheenTint && this.sheenTint.isColor && (n.sheenTint = this.sheenTint.getHex()), this.sheenRoughness !== void 0 && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && this.emissiveIntensity !== 1 && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (n.specularIntensity = this.specularIntensity), this.specularTint && this.specularTint.isColor && (n.specularTint = this.specularTint.getHex()), this.shininess !== void 0 && (n.shininess = this.shininess), this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularTintMap && this.specularTintMap.isTexture && (n.specularTintMap = this.specularTintMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (n.combine = this.combine)), this.envMapIntensity !== void 0 && (n.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (n.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && (n.attenuationDistance = this.attenuationDistance), this.attenuationTint !== void 0 && (n.attenuationTint = this.attenuationTint.getHex()), this.size !== void 0 && (n.size = this.size), this.shadowSide !== null && (n.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== Jr && (n.blending = this.blending), this.side !== Vi && (n.side = this.side), this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), this.format !== ct && (n.format = this.format), this.transparent === !0 && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.colorWrite = this.colorWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, this.rotation && this.rotation !== 0 && (n.rotation = this.rotation), this.polygonOffset === !0 && (n.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (n.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && this.linewidth !== 1 && (n.linewidth = this.linewidth), this.dashSize !== void 0 && (n.dashSize = this.dashSize), this.gapSize !== void 0 && (n.gapSize = this.gapSize), this.scale !== void 0 && (n.scale = this.scale), this.dithering === !0 && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), this.alphaToCoverage === !0 && (n.alphaToCoverage = this.alphaToCoverage), this.premultipliedAlpha === !0 && (n.premultipliedAlpha = this.premultipliedAlpha), this.wireframe === !0 && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (n.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (n.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (n.flatShading = this.flatShading), this.visible === !1 && (n.visible = !1), this.toneMapped === !1 && (n.toneMapped = !1), JSON.stringify(this.userData) !== "{}" && (n.userData = this.userData);

                function i(r) {
                    const s = [];
                    for (const o in r) {
                        const l = r[o];
                        delete l.metadata, s.push(l)
                    }
                    return s
                }
                if (t) {
                    const r = i(e.textures),
                        s = i(e.images);
                    r.length > 0 && (n.textures = r), s.length > 0 && (n.images = s)
                }
                return n
            }
            clone() {
                return new this.constructor().copy(this)
            }
            copy(e) {
                this.name = e.name, this.fog = e.fog, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.format = e.format, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
                const t = e.clippingPlanes;
                let n = null;
                if (t !== null) {
                    const i = t.length;
                    n = new Array(i);
                    for (let r = 0; r !== i; ++r) n[r] = t[r].clone()
                }
                return this.clippingPlanes = n, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
            set needsUpdate(e) {
                e === !0 && this.version++
            }
        }
        ot.prototype.isMaterial = !0;
        const uu = {
                aliceblue: 15792383,
                antiquewhite: 16444375,
                aqua: 65535,
                aquamarine: 8388564,
                azure: 15794175,
                beige: 16119260,
                bisque: 16770244,
                black: 0,
                blanchedalmond: 16772045,
                blue: 255,
                blueviolet: 9055202,
                brown: 10824234,
                burlywood: 14596231,
                cadetblue: 6266528,
                chartreuse: 8388352,
                chocolate: 13789470,
                coral: 16744272,
                cornflowerblue: 6591981,
                cornsilk: 16775388,
                crimson: 14423100,
                cyan: 65535,
                darkblue: 139,
                darkcyan: 35723,
                darkgoldenrod: 12092939,
                darkgray: 11119017,
                darkgreen: 25600,
                darkgrey: 11119017,
                darkkhaki: 12433259,
                darkmagenta: 9109643,
                darkolivegreen: 5597999,
                darkorange: 16747520,
                darkorchid: 10040012,
                darkred: 9109504,
                darksalmon: 15308410,
                darkseagreen: 9419919,
                darkslateblue: 4734347,
                darkslategray: 3100495,
                darkslategrey: 3100495,
                darkturquoise: 52945,
                darkviolet: 9699539,
                deeppink: 16716947,
                deepskyblue: 49151,
                dimgray: 6908265,
                dimgrey: 6908265,
                dodgerblue: 2003199,
                firebrick: 11674146,
                floralwhite: 16775920,
                forestgreen: 2263842,
                fuchsia: 16711935,
                gainsboro: 14474460,
                ghostwhite: 16316671,
                gold: 16766720,
                goldenrod: 14329120,
                gray: 8421504,
                green: 32768,
                greenyellow: 11403055,
                grey: 8421504,
                honeydew: 15794160,
                hotpink: 16738740,
                indianred: 13458524,
                indigo: 4915330,
                ivory: 16777200,
                khaki: 15787660,
                lavender: 15132410,
                lavenderblush: 16773365,
                lawngreen: 8190976,
                lemonchiffon: 16775885,
                lightblue: 11393254,
                lightcoral: 15761536,
                lightcyan: 14745599,
                lightgoldenrodyellow: 16448210,
                lightgray: 13882323,
                lightgreen: 9498256,
                lightgrey: 13882323,
                lightpink: 16758465,
                lightsalmon: 16752762,
                lightseagreen: 2142890,
                lightskyblue: 8900346,
                lightslategray: 7833753,
                lightslategrey: 7833753,
                lightsteelblue: 11584734,
                lightyellow: 16777184,
                lime: 65280,
                limegreen: 3329330,
                linen: 16445670,
                magenta: 16711935,
                maroon: 8388608,
                mediumaquamarine: 6737322,
                mediumblue: 205,
                mediumorchid: 12211667,
                mediumpurple: 9662683,
                mediumseagreen: 3978097,
                mediumslateblue: 8087790,
                mediumspringgreen: 64154,
                mediumturquoise: 4772300,
                mediumvioletred: 13047173,
                midnightblue: 1644912,
                mintcream: 16121850,
                mistyrose: 16770273,
                moccasin: 16770229,
                navajowhite: 16768685,
                navy: 128,
                oldlace: 16643558,
                olive: 8421376,
                olivedrab: 7048739,
                orange: 16753920,
                orangered: 16729344,
                orchid: 14315734,
                palegoldenrod: 15657130,
                palegreen: 10025880,
                paleturquoise: 11529966,
                palevioletred: 14381203,
                papayawhip: 16773077,
                peachpuff: 16767673,
                peru: 13468991,
                pink: 16761035,
                plum: 14524637,
                powderblue: 11591910,
                purple: 8388736,
                rebeccapurple: 6697881,
                red: 16711680,
                rosybrown: 12357519,
                royalblue: 4286945,
                saddlebrown: 9127187,
                salmon: 16416882,
                sandybrown: 16032864,
                seagreen: 3050327,
                seashell: 16774638,
                sienna: 10506797,
                silver: 12632256,
                skyblue: 8900331,
                slateblue: 6970061,
                slategray: 7372944,
                slategrey: 7372944,
                snow: 16775930,
                springgreen: 65407,
                steelblue: 4620980,
                tan: 13808780,
                teal: 32896,
                thistle: 14204888,
                tomato: 16737095,
                turquoise: 4251856,
                violet: 15631086,
                wheat: 16113331,
                white: 16777215,
                whitesmoke: 16119285,
                yellow: 16776960,
                yellowgreen: 10145074
            },
            an = {
                h: 0,
                s: 0,
                l: 0
            },
            la = {
                h: 0,
                s: 0,
                l: 0
            };

        function Co(a, e, t) {
            return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? a + (e - a) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? a + (e - a) * 6 * (2 / 3 - t) : a
        }

        function Po(a) {
            return a < .04045 ? a * .0773993808 : Math.pow(a * .9478672986 + .0521327014, 2.4)
        }

        function Do(a) {
            return a < .0031308 ? a * 12.92 : 1.055 * Math.pow(a, .41666) - .055
        }
        class ne {
            constructor(e, t, n) {
                return t === void 0 && n === void 0 ? this.set(e) : this.setRGB(e, t, n)
            }
            set(e) {
                return e && e.isColor ? this.copy(e) : typeof e == "number" ? this.setHex(e) : typeof e == "string" && this.setStyle(e), this
            }
            setScalar(e) {
                return this.r = e, this.g = e, this.b = e, this
            }
            setHex(e) {
                return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, this
            }
            setRGB(e, t, n) {
                return this.r = e, this.g = t, this.b = n, this
            }
            setHSL(e, t, n) {
                if (e = po(e, 1), t = Pt(t, 0, 1), n = Pt(n, 0, 1), t === 0) this.r = this.g = this.b = n;
                else {
                    const i = n <= .5 ? n * (1 + t) : n + t - n * t,
                        r = 2 * n - i;
                    this.r = Co(r, i, e + 1 / 3), this.g = Co(r, i, e), this.b = Co(r, i, e - 1 / 3)
                }
                return this
            }
            setStyle(e) {
                function t(i) {
                    i !== void 0 && parseFloat(i) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
                }
                let n;
                if (n = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)) {
                    let i;
                    const r = n[1],
                        s = n[2];
                    switch (r) {
                        case "rgb":
                        case "rgba":
                            if (i = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)) return this.r = Math.min(255, parseInt(i[1], 10)) / 255, this.g = Math.min(255, parseInt(i[2], 10)) / 255, this.b = Math.min(255, parseInt(i[3], 10)) / 255, t(i[4]), this;
                            if (i = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)) return this.r = Math.min(100, parseInt(i[1], 10)) / 100, this.g = Math.min(100, parseInt(i[2], 10)) / 100, this.b = Math.min(100, parseInt(i[3], 10)) / 100, t(i[4]), this;
                            break;
                        case "hsl":
                        case "hsla":
                            if (i = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)) {
                                const o = parseFloat(i[1]) / 360,
                                    l = parseInt(i[2], 10) / 100,
                                    c = parseInt(i[3], 10) / 100;
                                return t(i[4]), this.setHSL(o, l, c)
                            }
                            break
                    }
                } else if (n = /^\#([A-Fa-f\d]+)$/.exec(e)) {
                    const i = n[1],
                        r = i.length;
                    if (r === 3) return this.r = parseInt(i.charAt(0) + i.charAt(0), 16) / 255, this.g = parseInt(i.charAt(1) + i.charAt(1), 16) / 255, this.b = parseInt(i.charAt(2) + i.charAt(2), 16) / 255, this;
                    if (r === 6) return this.r = parseInt(i.charAt(0) + i.charAt(1), 16) / 255, this.g = parseInt(i.charAt(2) + i.charAt(3), 16) / 255, this.b = parseInt(i.charAt(4) + i.charAt(5), 16) / 255, this
                }
                return e && e.length > 0 ? this.setColorName(e) : this
            }
            setColorName(e) {
                const t = uu[e.toLowerCase()];
                return t !== void 0 ? this.setHex(t) : console.warn("THREE.Color: Unknown color " + e), this
            }
            clone() {
                return new this.constructor(this.r, this.g, this.b)
            }
            copy(e) {
                return this.r = e.r, this.g = e.g, this.b = e.b, this
            }
            copyGammaToLinear(e, t = 2) {
                return this.r = Math.pow(e.r, t), this.g = Math.pow(e.g, t), this.b = Math.pow(e.b, t), this
            }
            copyLinearToGamma(e, t = 2) {
                const n = t > 0 ? 1 / t : 1;
                return this.r = Math.pow(e.r, n), this.g = Math.pow(e.g, n), this.b = Math.pow(e.b, n), this
            }
            convertGammaToLinear(e) {
                return this.copyGammaToLinear(this, e), this
            }
            convertLinearToGamma(e) {
                return this.copyLinearToGamma(this, e), this
            }
            copySRGBToLinear(e) {
                return this.r = Po(e.r), this.g = Po(e.g), this.b = Po(e.b), this
            }
            copyLinearToSRGB(e) {
                return this.r = Do(e.r), this.g = Do(e.g), this.b = Do(e.b), this
            }
            convertSRGBToLinear() {
                return this.copySRGBToLinear(this), this
            }
            convertLinearToSRGB() {
                return this.copyLinearToSRGB(this), this
            }
            getHex() {
                return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0
            }
            getHexString() {
                return ("000000" + this.getHex().toString(16)).slice(-6)
            }
            getHSL(e) {
                const t = this.r,
                    n = this.g,
                    i = this.b,
                    r = Math.max(t, n, i),
                    s = Math.min(t, n, i);
                let o, l;
                const c = (s + r) / 2;
                if (s === r) o = 0, l = 0;
                else {
                    const u = r - s;
                    switch (l = c <= .5 ? u / (r + s) : u / (2 - r - s), r) {
                        case t:
                            o = (n - i) / u + (n < i ? 6 : 0);
                            break;
                        case n:
                            o = (i - t) / u + 2;
                            break;
                        case i:
                            o = (t - n) / u + 4;
                            break
                    }
                    o /= 6
                }
                return e.h = o, e.s = l, e.l = c, e
            }
            getStyle() {
                return "rgb(" + (this.r * 255 | 0) + "," + (this.g * 255 | 0) + "," + (this.b * 255 | 0) + ")"
            }
            offsetHSL(e, t, n) {
                return this.getHSL(an), an.h += e, an.s += t, an.l += n, this.setHSL(an.h, an.s, an.l), this
            }
            add(e) {
                return this.r += e.r, this.g += e.g, this.b += e.b, this
            }
            addColors(e, t) {
                return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this
            }
            addScalar(e) {
                return this.r += e, this.g += e, this.b += e, this
            }
            sub(e) {
                return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this
            }
            multiply(e) {
                return this.r *= e.r, this.g *= e.g, this.b *= e.b, this
            }
            multiplyScalar(e) {
                return this.r *= e, this.g *= e, this.b *= e, this
            }
            lerp(e, t) {
                return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this
            }
            lerpColors(e, t, n) {
                return this.r = e.r + (t.r - e.r) * n, this.g = e.g + (t.g - e.g) * n, this.b = e.b + (t.b - e.b) * n, this
            }
            lerpHSL(e, t) {
                this.getHSL(an), e.getHSL(la);
                const n = is(an.h, la.h, t),
                    i = is(an.s, la.s, t),
                    r = is(an.l, la.l, t);
                return this.setHSL(n, i, r), this
            }
            equals(e) {
                return e.r === this.r && e.g === this.g && e.b === this.b
            }
            fromArray(e, t = 0) {
                return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this
            }
            toArray(e = [], t = 0) {
                return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e
            }
            fromBufferAttribute(e, t) {
                return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), e.normalized === !0 && (this.r /= 255, this.g /= 255, this.b /= 255), this
            }
            toJSON() {
                return this.getHex()
            }
        }
        ne.NAMES = uu, ne.prototype.isColor = !0, ne.prototype.r = 1, ne.prototype.g = 1, ne.prototype.b = 1;
        class un extends ot {
            constructor(e) {
                super();
                this.type = "MeshBasicMaterial", this.color = new ne(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = qs, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(e)
            }
            copy(e) {
                return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this
            }
        }
        un.prototype.isMeshBasicMaterial = !0;
        const qe = new E,
            ca = new X;
        class Qe {
            constructor(e, t, n) {
                if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                this.name = "", this.array = e, this.itemSize = t, this.count = e !== void 0 ? e.length / t : 0, this.normalized = n === !0, this.usage = Mi, this.updateRange = {
                    offset: 0,
                    count: -1
                }, this.version = 0
            }
            onUploadCallback() {}
            set needsUpdate(e) {
                e === !0 && this.version++
            }
            setUsage(e) {
                return this.usage = e, this
            }
            copy(e) {
                return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this
            }
            copyAt(e, t, n) {
                e *= this.itemSize, n *= t.itemSize;
                for (let i = 0, r = this.itemSize; i < r; i++) this.array[e + i] = t.array[n + i];
                return this
            }
            copyArray(e) {
                return this.array.set(e), this
            }
            copyColorsArray(e) {
                const t = this.array;
                let n = 0;
                for (let i = 0, r = e.length; i < r; i++) {
                    let s = e[i];
                    s === void 0 && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i), s = new ne), t[n++] = s.r, t[n++] = s.g, t[n++] = s.b
                }
                return this
            }
            copyVector2sArray(e) {
                const t = this.array;
                let n = 0;
                for (let i = 0, r = e.length; i < r; i++) {
                    let s = e[i];
                    s === void 0 && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i), s = new X), t[n++] = s.x, t[n++] = s.y
                }
                return this
            }
            copyVector3sArray(e) {
                const t = this.array;
                let n = 0;
                for (let i = 0, r = e.length; i < r; i++) {
                    let s = e[i];
                    s === void 0 && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i), s = new E), t[n++] = s.x, t[n++] = s.y, t[n++] = s.z
                }
                return this
            }
            copyVector4sArray(e) {
                const t = this.array;
                let n = 0;
                for (let i = 0, r = e.length; i < r; i++) {
                    let s = e[i];
                    s === void 0 && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i), s = new Ue), t[n++] = s.x, t[n++] = s.y, t[n++] = s.z, t[n++] = s.w
                }
                return this
            }
            applyMatrix3(e) {
                if (this.itemSize === 2)
                    for (let t = 0, n = this.count; t < n; t++) ca.fromBufferAttribute(this, t), ca.applyMatrix3(e), this.setXY(t, ca.x, ca.y);
                else if (this.itemSize === 3)
                    for (let t = 0, n = this.count; t < n; t++) qe.fromBufferAttribute(this, t), qe.applyMatrix3(e), this.setXYZ(t, qe.x, qe.y, qe.z);
                return this
            }
            applyMatrix4(e) {
                for (let t = 0, n = this.count; t < n; t++) qe.x = this.getX(t), qe.y = this.getY(t), qe.z = this.getZ(t), qe.applyMatrix4(e), this.setXYZ(t, qe.x, qe.y, qe.z);
                return this
            }
            applyNormalMatrix(e) {
                for (let t = 0, n = this.count; t < n; t++) qe.x = this.getX(t), qe.y = this.getY(t), qe.z = this.getZ(t), qe.applyNormalMatrix(e), this.setXYZ(t, qe.x, qe.y, qe.z);
                return this
            }
            transformDirection(e) {
                for (let t = 0, n = this.count; t < n; t++) qe.x = this.getX(t), qe.y = this.getY(t), qe.z = this.getZ(t), qe.transformDirection(e), this.setXYZ(t, qe.x, qe.y, qe.z);
                return this
            }
            set(e, t = 0) {
                return this.array.set(e, t), this
            }
            getX(e) {
                return this.array[e * this.itemSize]
            }
            setX(e, t) {
                return this.array[e * this.itemSize] = t, this
            }
            getY(e) {
                return this.array[e * this.itemSize + 1]
            }
            setY(e, t) {
                return this.array[e * this.itemSize + 1] = t, this
            }
            getZ(e) {
                return this.array[e * this.itemSize + 2]
            }
            setZ(e, t) {
                return this.array[e * this.itemSize + 2] = t, this
            }
            getW(e) {
                return this.array[e * this.itemSize + 3]
            }
            setW(e, t) {
                return this.array[e * this.itemSize + 3] = t, this
            }
            setXY(e, t, n) {
                return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this
            }
            setXYZ(e, t, n, i) {
                return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this
            }
            setXYZW(e, t, n, i, r) {
                return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this.array[e + 3] = r, this
            }
            onUpload(e) {
                return this.onUploadCallback = e, this
            }
            clone() {
                return new this.constructor(this.array, this.itemSize).copy(this)
            }
            toJSON() {
                const e = {
                    itemSize: this.itemSize,
                    type: this.array.constructor.name,
                    array: Array.prototype.slice.call(this.array),
                    normalized: this.normalized
                };
                return this.name !== "" && (e.name = this.name), this.usage !== Mi && (e.usage = this.usage), (this.updateRange.offset !== 0 || this.updateRange.count !== -1) && (e.updateRange = this.updateRange), e
            }
        }
        Qe.prototype.isBufferAttribute = !0;
        class hu extends Qe {
            constructor(e, t, n) {
                super(new Uint16Array(e), t, n)
            }
        }
        class fu extends Qe {
            constructor(e, t, n) {
                super(new Uint32Array(e), t, n)
            }
        }
        class Bm extends Qe {
            constructor(e, t, n) {
                super(new Uint16Array(e), t, n)
            }
        }
        Bm.prototype.isFloat16BufferAttribute = !0;
        class Je extends Qe {
            constructor(e, t, n) {
                super(new Float32Array(e), t, n)
            }
        }
        let Om = 0;
        const Yt = new fe,
            Io = new Te,
            or = new E,
            kt = new jt,
            os = new jt,
            ut = new E;
        class ke extends bi {
            constructor() {
                super();
                Object.defineProperty(this, "id", {
                    value: Om++
                }), this.uuid = Xt(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
                    start: 0,
                    count: 1 / 0
                }, this.userData = {}
            }
            getIndex() {
                return this.index
            }
            setIndex(e) {
                return Array.isArray(e) ? this.index = new(Kc(e) > 65535 ? fu : hu)(e, 1) : this.index = e, this
            }
            getAttribute(e) {
                return this.attributes[e]
            }
            setAttribute(e, t) {
                return this.attributes[e] = t, this
            }
            deleteAttribute(e) {
                return delete this.attributes[e], this
            }
            hasAttribute(e) {
                return this.attributes[e] !== void 0
            }
            addGroup(e, t, n = 0) {
                this.groups.push({
                    start: e,
                    count: t,
                    materialIndex: n
                })
            }
            clearGroups() {
                this.groups = []
            }
            setDrawRange(e, t) {
                this.drawRange.start = e, this.drawRange.count = t
            }
            applyMatrix4(e) {
                const t = this.attributes.position;
                t !== void 0 && (t.applyMatrix4(e), t.needsUpdate = !0);
                const n = this.attributes.normal;
                if (n !== void 0) {
                    const r = new mt().getNormalMatrix(e);
                    n.applyNormalMatrix(r), n.needsUpdate = !0
                }
                const i = this.attributes.tangent;
                return i !== void 0 && (i.transformDirection(e), i.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this
            }
            applyQuaternion(e) {
                return Yt.makeRotationFromQuaternion(e), this.applyMatrix4(Yt), this
            }
            rotateX(e) {
                return Yt.makeRotationX(e), this.applyMatrix4(Yt), this
            }
            rotateY(e) {
                return Yt.makeRotationY(e), this.applyMatrix4(Yt), this
            }
            rotateZ(e) {
                return Yt.makeRotationZ(e), this.applyMatrix4(Yt), this
            }
            translate(e, t, n) {
                return Yt.makeTranslation(e, t, n), this.applyMatrix4(Yt), this
            }
            scale(e, t, n) {
                return Yt.makeScale(e, t, n), this.applyMatrix4(Yt), this
            }
            lookAt(e) {
                return Io.lookAt(e), Io.updateMatrix(), this.applyMatrix4(Io.matrix), this
            }
            center() {
                return this.computeBoundingBox(), this.boundingBox.getCenter(or).negate(), this.translate(or.x, or.y, or.z), this
            }
            setFromPoints(e) {
                const t = [];
                for (let n = 0, i = e.length; n < i; n++) {
                    const r = e[n];
                    t.push(r.x, r.y, r.z || 0)
                }
                return this.setAttribute("position", new Je(t, 3)), this
            }
            computeBoundingBox() {
                this.boundingBox === null && (this.boundingBox = new jt);
                const e = this.attributes.position,
                    t = this.morphAttributes.position;
                if (e && e.isGLBufferAttribute) {
                    console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingBox.set(new E(-1 / 0, -1 / 0, -1 / 0), new E(1 / 0, 1 / 0, 1 / 0));
                    return
                }
                if (e !== void 0) {
                    if (this.boundingBox.setFromBufferAttribute(e), t)
                        for (let n = 0, i = t.length; n < i; n++) {
                            const r = t[n];
                            kt.setFromBufferAttribute(r), this.morphTargetsRelative ? (ut.addVectors(this.boundingBox.min, kt.min), this.boundingBox.expandByPoint(ut), ut.addVectors(this.boundingBox.max, kt.max), this.boundingBox.expandByPoint(ut)) : (this.boundingBox.expandByPoint(kt.min), this.boundingBox.expandByPoint(kt.max))
                        }
                } else this.boundingBox.makeEmpty();
                (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
            }
            computeBoundingSphere() {
                this.boundingSphere === null && (this.boundingSphere = new Ti);
                const e = this.attributes.position,
                    t = this.morphAttributes.position;
                if (e && e.isGLBufferAttribute) {
                    console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingSphere.set(new E, 1 / 0);
                    return
                }
                if (e) {
                    const n = this.boundingSphere.center;
                    if (kt.setFromBufferAttribute(e), t)
                        for (let r = 0, s = t.length; r < s; r++) {
                            const o = t[r];
                            os.setFromBufferAttribute(o), this.morphTargetsRelative ? (ut.addVectors(kt.min, os.min), kt.expandByPoint(ut), ut.addVectors(kt.max, os.max), kt.expandByPoint(ut)) : (kt.expandByPoint(os.min), kt.expandByPoint(os.max))
                        }
                    kt.getCenter(n);
                    let i = 0;
                    for (let r = 0, s = e.count; r < s; r++) ut.fromBufferAttribute(e, r), i = Math.max(i, n.distanceToSquared(ut));
                    if (t)
                        for (let r = 0, s = t.length; r < s; r++) {
                            const o = t[r],
                                l = this.morphTargetsRelative;
                            for (let c = 0, u = o.count; c < u; c++) ut.fromBufferAttribute(o, c), l && (or.fromBufferAttribute(e, c), ut.add(or)), i = Math.max(i, n.distanceToSquared(ut))
                        }
                    this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                }
            }
            computeTangents() {
                const e = this.index,
                    t = this.attributes;
                if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
                    console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
                    return
                }
                const n = e.array,
                    i = t.position.array,
                    r = t.normal.array,
                    s = t.uv.array,
                    o = i.length / 3;
                t.tangent === void 0 && this.setAttribute("tangent", new Qe(new Float32Array(4 * o), 4));
                const l = t.tangent.array,
                    c = [],
                    u = [];
                for (let I = 0; I < o; I++) c[I] = new E, u[I] = new E;
                const h = new E,
                    f = new E,
                    d = new E,
                    m = new X,
                    g = new X,
                    v = new X,
                    p = new E,
                    _ = new E;

                function M(I, L, Y) {
                    h.fromArray(i, I * 3), f.fromArray(i, L * 3), d.fromArray(i, Y * 3), m.fromArray(s, I * 2), g.fromArray(s, L * 2), v.fromArray(s, Y * 2), f.sub(h), d.sub(h), g.sub(m), v.sub(m);
                    const D = 1 / (g.x * v.y - v.x * g.y);
                    !isFinite(D) || (p.copy(f).multiplyScalar(v.y).addScaledVector(d, -g.y).multiplyScalar(D), _.copy(d).multiplyScalar(g.x).addScaledVector(f, -v.x).multiplyScalar(D), c[I].add(p), c[L].add(p), c[Y].add(p), u[I].add(_), u[L].add(_), u[Y].add(_))
                }
                let y = this.groups;
                y.length === 0 && (y = [{
                    start: 0,
                    count: n.length
                }]);
                for (let I = 0, L = y.length; I < L; ++I) {
                    const Y = y[I],
                        D = Y.start,
                        F = Y.count;
                    for (let N = D, z = D + F; N < z; N += 3) M(n[N + 0], n[N + 1], n[N + 2])
                }
                const b = new E,
                    T = new E,
                    x = new E,
                    R = new E;

                function P(I) {
                    x.fromArray(r, I * 3), R.copy(x);
                    const L = c[I];
                    b.copy(L), b.sub(x.multiplyScalar(x.dot(L))).normalize(), T.crossVectors(R, L);
                    const D = T.dot(u[I]) < 0 ? -1 : 1;
                    l[I * 4] = b.x, l[I * 4 + 1] = b.y, l[I * 4 + 2] = b.z, l[I * 4 + 3] = D
                }
                for (let I = 0, L = y.length; I < L; ++I) {
                    const Y = y[I],
                        D = Y.start,
                        F = Y.count;
                    for (let N = D, z = D + F; N < z; N += 3) P(n[N + 0]), P(n[N + 1]), P(n[N + 2])
                }
            }
            computeVertexNormals() {
                const e = this.index,
                    t = this.getAttribute("position");
                if (t !== void 0) {
                    let n = this.getAttribute("normal");
                    if (n === void 0) n = new Qe(new Float32Array(t.count * 3), 3), this.setAttribute("normal", n);
                    else
                        for (let f = 0, d = n.count; f < d; f++) n.setXYZ(f, 0, 0, 0);
                    const i = new E,
                        r = new E,
                        s = new E,
                        o = new E,
                        l = new E,
                        c = new E,
                        u = new E,
                        h = new E;
                    if (e)
                        for (let f = 0, d = e.count; f < d; f += 3) {
                            const m = e.getX(f + 0),
                                g = e.getX(f + 1),
                                v = e.getX(f + 2);
                            i.fromBufferAttribute(t, m), r.fromBufferAttribute(t, g), s.fromBufferAttribute(t, v), u.subVectors(s, r), h.subVectors(i, r), u.cross(h), o.fromBufferAttribute(n, m), l.fromBufferAttribute(n, g), c.fromBufferAttribute(n, v), o.add(u), l.add(u), c.add(u), n.setXYZ(m, o.x, o.y, o.z), n.setXYZ(g, l.x, l.y, l.z), n.setXYZ(v, c.x, c.y, c.z)
                        } else
                            for (let f = 0, d = t.count; f < d; f += 3) i.fromBufferAttribute(t, f + 0), r.fromBufferAttribute(t, f + 1), s.fromBufferAttribute(t, f + 2), u.subVectors(s, r), h.subVectors(i, r), u.cross(h), n.setXYZ(f + 0, u.x, u.y, u.z), n.setXYZ(f + 1, u.x, u.y, u.z), n.setXYZ(f + 2, u.x, u.y, u.z);
                    this.normalizeNormals(), n.needsUpdate = !0
                }
            }
            merge(e, t) {
                if (!(e && e.isBufferGeometry)) {
                    console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", e);
                    return
                }
                t === void 0 && (t = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
                const n = this.attributes;
                for (const i in n) {
                    if (e.attributes[i] === void 0) continue;
                    const s = n[i].array,
                        o = e.attributes[i],
                        l = o.array,
                        c = o.itemSize * t,
                        u = Math.min(l.length, s.length - c);
                    for (let h = 0, f = c; h < u; h++, f++) s[f] = l[h]
                }
                return this
            }
            normalizeNormals() {
                const e = this.attributes.normal;
                for (let t = 0, n = e.count; t < n; t++) ut.fromBufferAttribute(e, t), ut.normalize(), e.setXYZ(t, ut.x, ut.y, ut.z)
            }
            toNonIndexed() {
                function e(o, l) {
                    const c = o.array,
                        u = o.itemSize,
                        h = o.normalized,
                        f = new c.constructor(l.length * u);
                    let d = 0,
                        m = 0;
                    for (let g = 0, v = l.length; g < v; g++) {
                        o.isInterleavedBufferAttribute ? d = l[g] * o.data.stride + o.offset : d = l[g] * u;
                        for (let p = 0; p < u; p++) f[m++] = c[d++]
                    }
                    return new Qe(f, u, h)
                }
                if (this.index === null) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
                const t = new ke,
                    n = this.index.array,
                    i = this.attributes;
                for (const o in i) {
                    const l = i[o],
                        c = e(l, n);
                    t.setAttribute(o, c)
                }
                const r = this.morphAttributes;
                for (const o in r) {
                    const l = [],
                        c = r[o];
                    for (let u = 0, h = c.length; u < h; u++) {
                        const f = c[u],
                            d = e(f, n);
                        l.push(d)
                    }
                    t.morphAttributes[o] = l
                }
                t.morphTargetsRelative = this.morphTargetsRelative;
                const s = this.groups;
                for (let o = 0, l = s.length; o < l; o++) {
                    const c = s[o];
                    t.addGroup(c.start, c.count, c.materialIndex)
                }
                return t
            }
            toJSON() {
                const e = {
                    metadata: {
                        version: 4.5,
                        type: "BufferGeometry",
                        generator: "BufferGeometry.toJSON"
                    }
                };
                if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
                    const l = this.parameters;
                    for (const c in l) l[c] !== void 0 && (e[c] = l[c]);
                    return e
                }
                e.data = {
                    attributes: {}
                };
                const t = this.index;
                t !== null && (e.data.index = {
                    type: t.array.constructor.name,
                    array: Array.prototype.slice.call(t.array)
                });
                const n = this.attributes;
                for (const l in n) {
                    const c = n[l];
                    e.data.attributes[l] = c.toJSON(e.data)
                }
                const i = {};
                let r = !1;
                for (const l in this.morphAttributes) {
                    const c = this.morphAttributes[l],
                        u = [];
                    for (let h = 0, f = c.length; h < f; h++) {
                        const d = c[h];
                        u.push(d.toJSON(e.data))
                    }
                    u.length > 0 && (i[l] = u, r = !0)
                }
                r && (e.data.morphAttributes = i, e.data.morphTargetsRelative = this.morphTargetsRelative);
                const s = this.groups;
                s.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(s)));
                const o = this.boundingSphere;
                return o !== null && (e.data.boundingSphere = {
                    center: o.center.toArray(),
                    radius: o.radius
                }), e
            }
            clone() {
                return new this.constructor().copy(this)
            }
            copy(e) {
                this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
                const t = {};
                this.name = e.name;
                const n = e.index;
                n !== null && this.setIndex(n.clone(t));
                const i = e.attributes;
                for (const c in i) {
                    const u = i[c];
                    this.setAttribute(c, u.clone(t))
                }
                const r = e.morphAttributes;
                for (const c in r) {
                    const u = [],
                        h = r[c];
                    for (let f = 0, d = h.length; f < d; f++) u.push(h[f].clone(t));
                    this.morphAttributes[c] = u
                }
                this.morphTargetsRelative = e.morphTargetsRelative;
                const s = e.groups;
                for (let c = 0, u = s.length; c < u; c++) {
                    const h = s[c];
                    this.addGroup(h.start, h.count, h.materialIndex)
                }
                const o = e.boundingBox;
                o !== null && (this.boundingBox = o.clone());
                const l = e.boundingSphere;
                return l !== null && (this.boundingSphere = l.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, e.parameters !== void 0 && (this.parameters = Object.assign({}, e.parameters)), this
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }
        ke.prototype.isBufferGeometry = !0;
        const du = new fe,
            lr = new Ei,
            Fo = new Ti,
            qn = new E,
            Xn = new E,
            jn = new E,
            zo = new E,
            No = new E,
            Bo = new E,
            ua = new E,
            ha = new E,
            fa = new E,
            da = new X,
            pa = new X,
            ma = new X,
            Oo = new E,
            ga = new E;
        class Ge extends Te {
            constructor(e = new ke, t = new un) {
                super();
                this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets()
            }
            copy(e) {
                return super.copy(e), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = e.material, this.geometry = e.geometry, this
            }
            updateMorphTargets() {
                const e = this.geometry;
                if (e.isBufferGeometry) {
                    const t = e.morphAttributes,
                        n = Object.keys(t);
                    if (n.length > 0) {
                        const i = t[n[0]];
                        if (i !== void 0) {
                            this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                            for (let r = 0, s = i.length; r < s; r++) {
                                const o = i[r].name || String(r);
                                this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = r
                            }
                        }
                    }
                } else {
                    const t = e.morphTargets;
                    t !== void 0 && t.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                }
            }
            raycast(e, t) {
                const n = this.geometry,
                    i = this.material,
                    r = this.matrixWorld;
                if (i === void 0 || (n.boundingSphere === null && n.computeBoundingSphere(), Fo.copy(n.boundingSphere), Fo.applyMatrix4(r), e.ray.intersectsSphere(Fo) === !1) || (du.copy(r).invert(), lr.copy(e.ray).applyMatrix4(du), n.boundingBox !== null && lr.intersectsBox(n.boundingBox) === !1)) return;
                let s;
                if (n.isBufferGeometry) {
                    const o = n.index,
                        l = n.attributes.position,
                        c = n.morphAttributes.position,
                        u = n.morphTargetsRelative,
                        h = n.attributes.uv,
                        f = n.attributes.uv2,
                        d = n.groups,
                        m = n.drawRange;
                    if (o !== null)
                        if (Array.isArray(i))
                            for (let g = 0, v = d.length; g < v; g++) {
                                const p = d[g],
                                    _ = i[p.materialIndex],
                                    M = Math.max(p.start, m.start),
                                    y = Math.min(o.count, Math.min(p.start + p.count, m.start + m.count));
                                for (let b = M, T = y; b < T; b += 3) {
                                    const x = o.getX(b),
                                        R = o.getX(b + 1),
                                        P = o.getX(b + 2);
                                    s = _a(this, _, e, lr, l, c, u, h, f, x, R, P), s && (s.faceIndex = Math.floor(b / 3), s.face.materialIndex = p.materialIndex, t.push(s))
                                }
                            } else {
                                const g = Math.max(0, m.start),
                                    v = Math.min(o.count, m.start + m.count);
                                for (let p = g, _ = v; p < _; p += 3) {
                                    const M = o.getX(p),
                                        y = o.getX(p + 1),
                                        b = o.getX(p + 2);
                                    s = _a(this, i, e, lr, l, c, u, h, f, M, y, b), s && (s.faceIndex = Math.floor(p / 3), t.push(s))
                                }
                            } else if (l !== void 0)
                                if (Array.isArray(i))
                                    for (let g = 0, v = d.length; g < v; g++) {
                                        const p = d[g],
                                            _ = i[p.materialIndex],
                                            M = Math.max(p.start, m.start),
                                            y = Math.min(l.count, Math.min(p.start + p.count, m.start + m.count));
                                        for (let b = M, T = y; b < T; b += 3) {
                                            const x = b,
                                                R = b + 1,
                                                P = b + 2;
                                            s = _a(this, _, e, lr, l, c, u, h, f, x, R, P), s && (s.faceIndex = Math.floor(b / 3), s.face.materialIndex = p.materialIndex, t.push(s))
                                        }
                                    } else {
                                        const g = Math.max(0, m.start),
                                            v = Math.min(l.count, m.start + m.count);
                                        for (let p = g, _ = v; p < _; p += 3) {
                                            const M = p,
                                                y = p + 1,
                                                b = p + 2;
                                            s = _a(this, i, e, lr, l, c, u, h, f, M, y, b), s && (s.faceIndex = Math.floor(p / 3), t.push(s))
                                        }
                                    }
                } else n.isGeometry && console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
            }
        }
        Ge.prototype.isMesh = !0;

        function Um(a, e, t, n, i, r, s, o) {
            let l;
            if (e.side === nt ? l = n.intersectTriangle(s, r, i, !0, o) : l = n.intersectTriangle(i, r, s, e.side !== vi, o), l === null) return null;
            ga.copy(o), ga.applyMatrix4(a.matrixWorld);
            const c = t.ray.origin.distanceTo(ga);
            return c < t.near || c > t.far ? null : {
                distance: c,
                point: ga.clone(),
                object: a
            }
        }

        function _a(a, e, t, n, i, r, s, o, l, c, u, h) {
            qn.fromBufferAttribute(i, c), Xn.fromBufferAttribute(i, u), jn.fromBufferAttribute(i, h);
            const f = a.morphTargetInfluences;
            if (r && f) {
                ua.set(0, 0, 0), ha.set(0, 0, 0), fa.set(0, 0, 0);
                for (let m = 0, g = r.length; m < g; m++) {
                    const v = f[m],
                        p = r[m];
                    v !== 0 && (zo.fromBufferAttribute(p, c), No.fromBufferAttribute(p, u), Bo.fromBufferAttribute(p, h), s ? (ua.addScaledVector(zo, v), ha.addScaledVector(No, v), fa.addScaledVector(Bo, v)) : (ua.addScaledVector(zo.sub(qn), v), ha.addScaledVector(No.sub(Xn), v), fa.addScaledVector(Bo.sub(jn), v)))
                }
                qn.add(ua), Xn.add(ha), jn.add(fa)
            }
            a.isSkinnedMesh && (a.boneTransform(c, qn), a.boneTransform(u, Xn), a.boneTransform(h, jn));
            const d = Um(a, e, t, n, qn, Xn, jn, Oo);
            if (d) {
                o && (da.fromBufferAttribute(o, c), pa.fromBufferAttribute(o, u), ma.fromBufferAttribute(o, h), d.uv = it.getUV(Oo, qn, Xn, jn, da, pa, ma, new X)), l && (da.fromBufferAttribute(l, c), pa.fromBufferAttribute(l, u), ma.fromBufferAttribute(l, h), d.uv2 = it.getUV(Oo, qn, Xn, jn, da, pa, ma, new X));
                const m = {
                    a: c,
                    b: u,
                    c: h,
                    normal: new E,
                    materialIndex: 0
                };
                it.getNormal(qn, Xn, jn, m.normal), d.face = m
            }
            return d
        }
        class Yn extends ke {
            constructor(e = 1, t = 1, n = 1, i = 1, r = 1, s = 1) {
                super();
                this.type = "BoxGeometry", this.parameters = {
                    width: e,
                    height: t,
                    depth: n,
                    widthSegments: i,
                    heightSegments: r,
                    depthSegments: s
                };
                const o = this;
                i = Math.floor(i), r = Math.floor(r), s = Math.floor(s);
                const l = [],
                    c = [],
                    u = [],
                    h = [];
                let f = 0,
                    d = 0;
                m("z", "y", "x", -1, -1, n, t, e, s, r, 0), m("z", "y", "x", 1, -1, n, t, -e, s, r, 1), m("x", "z", "y", 1, 1, e, n, t, i, s, 2), m("x", "z", "y", 1, -1, e, n, -t, i, s, 3), m("x", "y", "z", 1, -1, e, t, n, i, r, 4), m("x", "y", "z", -1, -1, e, t, -n, i, r, 5), this.setIndex(l), this.setAttribute("position", new Je(c, 3)), this.setAttribute("normal", new Je(u, 3)), this.setAttribute("uv", new Je(h, 2));

                function m(g, v, p, _, M, y, b, T, x, R, P) {
                    const I = y / x,
                        L = b / R,
                        Y = y / 2,
                        D = b / 2,
                        F = T / 2,
                        N = x + 1,
                        z = R + 1;
                    let k = 0,
                        J = 0;
                    const oe = new E;
                    for (let he = 0; he < z; he++) {
                        const ie = he * L - D;
                        for (let be = 0; be < N; be++) {
                            const W = be * I - Y;
                            oe[g] = W * _, oe[v] = ie * M, oe[p] = F, c.push(oe.x, oe.y, oe.z), oe[g] = 0, oe[v] = 0, oe[p] = T > 0 ? 1 : -1, u.push(oe.x, oe.y, oe.z), h.push(be / x), h.push(1 - he / R), k += 1
                        }
                    }
                    for (let he = 0; he < R; he++)
                        for (let ie = 0; ie < x; ie++) {
                            const be = f + ie + N * he,
                                W = f + ie + N * (he + 1),
                                $ = f + (ie + 1) + N * (he + 1),
                                me = f + (ie + 1) + N * he;
                            l.push(be, W, me), l.push(W, $, me), J += 6
                        }
                    o.addGroup(d, J, P), d += J, f += k
                }
            }
            static fromJSON(e) {
                return new Yn(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments)
            }
        }

        function cr(a) {
            const e = {};
            for (const t in a) {
                e[t] = {};
                for (const n in a[t]) {
                    const i = a[t][n];
                    i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture || i.isQuaternion) ? e[t][n] = i.clone() : Array.isArray(i) ? e[t][n] = i.slice() : e[t][n] = i
                }
            }
            return e
        }

        function xt(a) {
            const e = {};
            for (let t = 0; t < a.length; t++) {
                const n = cr(a[t]);
                for (const i in n) e[i] = n[i]
            }
            return e
        }
        const ls = {
            clone: cr,
            merge: xt
        };
        var km = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
            Gm = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
        class It extends ot {
            constructor(e) {
                super();
                this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = km, this.fragmentShader = Gm, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.extensions = {
                    derivatives: !1,
                    fragDepth: !1,
                    drawBuffers: !1,
                    shaderTextureLOD: !1
                }, this.defaultAttributeValues = {
                    color: [1, 1, 1],
                    uv: [0, 0],
                    uv2: [0, 0]
                }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, e !== void 0 && (e.attributes !== void 0 && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(e))
            }
            copy(e) {
                return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = cr(e.uniforms), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this
            }
            toJSON(e) {
                const t = super.toJSON(e);
                t.glslVersion = this.glslVersion, t.uniforms = {};
                for (const i in this.uniforms) {
                    const s = this.uniforms[i].value;
                    s && s.isTexture ? t.uniforms[i] = {
                        type: "t",
                        value: s.toJSON(e).uuid
                    } : s && s.isColor ? t.uniforms[i] = {
                        type: "c",
                        value: s.getHex()
                    } : s && s.isVector2 ? t.uniforms[i] = {
                        type: "v2",
                        value: s.toArray()
                    } : s && s.isVector3 ? t.uniforms[i] = {
                        type: "v3",
                        value: s.toArray()
                    } : s && s.isVector4 ? t.uniforms[i] = {
                        type: "v4",
                        value: s.toArray()
                    } : s && s.isMatrix3 ? t.uniforms[i] = {
                        type: "m3",
                        value: s.toArray()
                    } : s && s.isMatrix4 ? t.uniforms[i] = {
                        type: "m4",
                        value: s.toArray()
                    } : t.uniforms[i] = {
                        value: s
                    }
                }
                Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader;
                const n = {};
                for (const i in this.extensions) this.extensions[i] === !0 && (n[i] = !0);
                return Object.keys(n).length > 0 && (t.extensions = n), t
            }
        }
        It.prototype.isShaderMaterial = !0;
        class Uo extends Te {
            constructor() {
                super();
                this.type = "Camera", this.matrixWorldInverse = new fe, this.projectionMatrix = new fe, this.projectionMatrixInverse = new fe
            }
            copy(e, t) {
                return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this
            }
            getWorldDirection(e) {
                this.updateWorldMatrix(!0, !1);
                const t = this.matrixWorld.elements;
                return e.set(-t[8], -t[9], -t[10]).normalize()
            }
            updateMatrixWorld(e) {
                super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert()
            }
            updateWorldMatrix(e, t) {
                super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert()
            }
            clone() {
                return new this.constructor().copy(this)
            }
        }
        Uo.prototype.isCamera = !0;
        class yt extends Uo {
            constructor(e = 50, t = 1, n = .1, i = 2e3) {
                super();
                this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = n, this.far = i, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
            }
            copy(e, t) {
                return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this
            }
            setFocalLength(e) {
                const t = .5 * this.getFilmHeight() / e;
                this.fov = ns * 2 * Math.atan(t), this.updateProjectionMatrix()
            }
            getFocalLength() {
                const e = Math.tan(ts * .5 * this.fov);
                return .5 * this.getFilmHeight() / e
            }
            getEffectiveFOV() {
                return ns * 2 * Math.atan(Math.tan(ts * .5 * this.fov) / this.zoom)
            }
            getFilmWidth() {
                return this.filmGauge * Math.min(this.aspect, 1)
            }
            getFilmHeight() {
                return this.filmGauge / Math.max(this.aspect, 1)
            }
            setViewOffset(e, t, n, i, r, s) {
                this.aspect = e / t, this.view === null && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = s, this.updateProjectionMatrix()
            }
            clearViewOffset() {
                this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix()
            }
            updateProjectionMatrix() {
                const e = this.near;
                let t = e * Math.tan(ts * .5 * this.fov) / this.zoom,
                    n = 2 * t,
                    i = this.aspect * n,
                    r = -.5 * i;
                const s = this.view;
                if (this.view !== null && this.view.enabled) {
                    const l = s.fullWidth,
                        c = s.fullHeight;
                    r += s.offsetX * i / l, t -= s.offsetY * n / c, i *= s.width / l, n *= s.height / c
                }
                const o = this.filmOffset;
                o !== 0 && (r += e * o / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + i, t, t - n, e, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
            }
            toJSON(e) {
                const t = super.toJSON(e);
                return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, this.view !== null && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t
            }
        }
        yt.prototype.isPerspectiveCamera = !0;
        const ur = 90,
            hr = 1;
        class ko extends Te {
            constructor(e, t, n) {
                super();
                if (this.type = "CubeCamera", n.isWebGLCubeRenderTarget !== !0) {
                    console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
                    return
                }
                this.renderTarget = n;
                const i = new yt(ur, hr, e, t);
                i.layers = this.layers, i.up.set(0, -1, 0), i.lookAt(new E(1, 0, 0)), this.add(i);
                const r = new yt(ur, hr, e, t);
                r.layers = this.layers, r.up.set(0, -1, 0), r.lookAt(new E(-1, 0, 0)), this.add(r);
                const s = new yt(ur, hr, e, t);
                s.layers = this.layers, s.up.set(0, 0, 1), s.lookAt(new E(0, 1, 0)), this.add(s);
                const o = new yt(ur, hr, e, t);
                o.layers = this.layers, o.up.set(0, 0, -1), o.lookAt(new E(0, -1, 0)), this.add(o);
                const l = new yt(ur, hr, e, t);
                l.layers = this.layers, l.up.set(0, -1, 0), l.lookAt(new E(0, 0, 1)), this.add(l);
                const c = new yt(ur, hr, e, t);
                c.layers = this.layers, c.up.set(0, -1, 0), c.lookAt(new E(0, 0, -1)), this.add(c)
            }
            update(e, t) {
                this.parent === null && this.updateMatrixWorld();
                const n = this.renderTarget,
                    [i, r, s, o, l, c] = this.children,
                    u = e.xr.enabled,
                    h = e.getRenderTarget();
                e.xr.enabled = !1;
                const f = n.texture.generateMipmaps;
                n.texture.generateMipmaps = !1, e.setRenderTarget(n, 0), e.render(t, i), e.setRenderTarget(n, 1), e.render(t, r), e.setRenderTarget(n, 2), e.render(t, s), e.setRenderTarget(n, 3), e.render(t, o), e.setRenderTarget(n, 4), e.render(t, l), n.texture.generateMipmaps = f, e.setRenderTarget(n, 5), e.render(t, c), e.setRenderTarget(h), e.xr.enabled = u
            }
        }
        class va extends at {
            constructor(e, t, n, i, r, s, o, l, c, u) {
                e = e !== void 0 ? e : [], t = t !== void 0 ? t : Xs;
                super(e, t, n, i, r, s, o, l, c, u);
                this.flipY = !1
            }
            get images() {
                return this.image
            }
            set images(e) {
                this.image = e
            }
        }
        va.prototype.isCubeTexture = !0;
        class pu extends Dt {
            constructor(e, t, n) {
                Number.isInteger(t) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"), t = n);
                super(e, e, t);
                t = t || {}, this.texture = new va(void 0, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.encoding), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : !1, this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : lt, this.texture._needsFlipEnvMap = !1
            }
            fromEquirectangularTexture(e, t) {
                this.texture.type = t.type, this.texture.format = ct, this.texture.encoding = t.encoding, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
                const n = {
                        uniforms: {
                            tEquirect: {
                                value: null
                            }
                        },
                        vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
                        fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
                    },
                    i = new Yn(5, 5, 5),
                    r = new It({
                        name: "CubemapFromEquirect",
                        uniforms: cr(n.uniforms),
                        vertexShader: n.vertexShader,
                        fragmentShader: n.fragmentShader,
                        side: nt,
                        blending: On
                    });
                r.uniforms.tEquirect.value = t;
                const s = new Ge(i, r),
                    o = t.minFilter;
                return t.minFilter === qi && (t.minFilter = lt), new ko(1, 10, this).update(e, s), t.minFilter = o, s.geometry.dispose(), s.material.dispose(), this
            }
            clear(e, t, n, i) {
                const r = e.getRenderTarget();
                for (let s = 0; s < 6; s++) e.setRenderTarget(this, s), e.clear(t, n, i);
                e.setRenderTarget(r)
            }
        }
        pu.prototype.isWebGLCubeRenderTarget = !0;
        const Go = new E,
            Hm = new E,
            Vm = new mt;
        class En {
            constructor(e = new E(1, 0, 0), t = 0) {
                this.normal = e, this.constant = t
            }
            set(e, t) {
                return this.normal.copy(e), this.constant = t, this
            }
            setComponents(e, t, n, i) {
                return this.normal.set(e, t, n), this.constant = i, this
            }
            setFromNormalAndCoplanarPoint(e, t) {
                return this.normal.copy(e), this.constant = -t.dot(this.normal), this
            }
            setFromCoplanarPoints(e, t, n) {
                const i = Go.subVectors(n, t).cross(Hm.subVectors(e, t)).normalize();
                return this.setFromNormalAndCoplanarPoint(i, e), this
            }
            copy(e) {
                return this.normal.copy(e.normal), this.constant = e.constant, this
            }
            normalize() {
                const e = 1 / this.normal.length();
                return this.normal.multiplyScalar(e), this.constant *= e, this
            }
            negate() {
                return this.constant *= -1, this.normal.negate(), this
            }
            distanceToPoint(e) {
                return this.normal.dot(e) + this.constant
            }
            distanceToSphere(e) {
                return this.distanceToPoint(e.center) - e.radius
            }
            projectPoint(e, t) {
                return t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)
            }
            intersectLine(e, t) {
                const n = e.delta(Go),
                    i = this.normal.dot(n);
                if (i === 0) return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
                const r = -(e.start.dot(this.normal) + this.constant) / i;
                return r < 0 || r > 1 ? null : t.copy(n).multiplyScalar(r).add(e.start)
            }
            intersectsLine(e) {
                const t = this.distanceToPoint(e.start),
                    n = this.distanceToPoint(e.end);
                return t < 0 && n > 0 || n < 0 && t > 0
            }
            intersectsBox(e) {
                return e.intersectsPlane(this)
            }
            intersectsSphere(e) {
                return e.intersectsPlane(this)
            }
            coplanarPoint(e) {
                return e.copy(this.normal).multiplyScalar(-this.constant)
            }
            applyMatrix4(e, t) {
                const n = t || Vm.getNormalMatrix(e),
                    i = this.coplanarPoint(Go).applyMatrix4(e),
                    r = this.normal.applyMatrix3(n).normalize();
                return this.constant = -i.dot(r), this
            }
            translate(e) {
                return this.constant -= e.dot(this.normal), this
            }
            equals(e) {
                return e.normal.equals(this.normal) && e.constant === this.constant
            }
            clone() {
                return new this.constructor().copy(this)
            }
        }
        En.prototype.isPlane = !0;
        const fr = new Ti,
            xa = new E;
        class ya {
            constructor(e = new En, t = new En, n = new En, i = new En, r = new En, s = new En) {
                this.planes = [e, t, n, i, r, s]
            }
            set(e, t, n, i, r, s) {
                const o = this.planes;
                return o[0].copy(e), o[1].copy(t), o[2].copy(n), o[3].copy(i), o[4].copy(r), o[5].copy(s), this
            }
            copy(e) {
                const t = this.planes;
                for (let n = 0; n < 6; n++) t[n].copy(e.planes[n]);
                return this
            }
            setFromProjectionMatrix(e) {
                const t = this.planes,
                    n = e.elements,
                    i = n[0],
                    r = n[1],
                    s = n[2],
                    o = n[3],
                    l = n[4],
                    c = n[5],
                    u = n[6],
                    h = n[7],
                    f = n[8],
                    d = n[9],
                    m = n[10],
                    g = n[11],
                    v = n[12],
                    p = n[13],
                    _ = n[14],
                    M = n[15];
                return t[0].setComponents(o - i, h - l, g - f, M - v).normalize(), t[1].setComponents(o + i, h + l, g + f, M + v).normalize(), t[2].setComponents(o + r, h + c, g + d, M + p).normalize(), t[3].setComponents(o - r, h - c, g - d, M - p).normalize(), t[4].setComponents(o - s, h - u, g - m, M - _).normalize(), t[5].setComponents(o + s, h + u, g + m, M + _).normalize(), this
            }
            intersectsObject(e) {
                const t = e.geometry;
                return t.boundingSphere === null && t.computeBoundingSphere(), fr.copy(t.boundingSphere).applyMatrix4(e.matrixWorld), this.intersectsSphere(fr)
            }
            intersectsSprite(e) {
                return fr.center.set(0, 0, 0), fr.radius = .7071067811865476, fr.applyMatrix4(e.matrixWorld), this.intersectsSphere(fr)
            }
            intersectsSphere(e) {
                const t = this.planes,
                    n = e.center,
                    i = -e.radius;
                for (let r = 0; r < 6; r++)
                    if (t[r].distanceToPoint(n) < i) return !1;
                return !0
            }
            intersectsBox(e) {
                const t = this.planes;
                for (let n = 0; n < 6; n++) {
                    const i = t[n];
                    if (xa.x = i.normal.x > 0 ? e.max.x : e.min.x, xa.y = i.normal.y > 0 ? e.max.y : e.min.y, xa.z = i.normal.z > 0 ? e.max.z : e.min.z, i.distanceToPoint(xa) < 0) return !1
                }
                return !0
            }
            containsPoint(e) {
                const t = this.planes;
                for (let n = 0; n < 6; n++)
                    if (t[n].distanceToPoint(e) < 0) return !1;
                return !0
            }
            clone() {
                return new this.constructor().copy(this)
            }
        }

        function mu() {
            let a = null,
                e = !1,
                t = null,
                n = null;

            function i(r, s) {
                t(r, s), n = a.requestAnimationFrame(i)
            }
            return {
                start: function() {
                    e !== !0 && t !== null && (n = a.requestAnimationFrame(i), e = !0)
                },
                stop: function() {
                    a.cancelAnimationFrame(n), e = !1
                },
                setAnimationLoop: function(r) {
                    t = r
                },
                setContext: function(r) {
                    a = r
                }
            }
        }

        function Wm(a, e) {
            const t = e.isWebGL2,
                n = new WeakMap;

            function i(c, u) {
                const h = c.array,
                    f = c.usage,
                    d = a.createBuffer();
                a.bindBuffer(u, d), a.bufferData(u, h, f), c.onUploadCallback();
                let m = 5126;
                return h instanceof Float32Array ? m = 5126 : h instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : h instanceof Uint16Array ? c.isFloat16BufferAttribute ? t ? m = 5131 : console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.") : m = 5123 : h instanceof Int16Array ? m = 5122 : h instanceof Uint32Array ? m = 5125 : h instanceof Int32Array ? m = 5124 : h instanceof Int8Array ? m = 5120 : (h instanceof Uint8Array || h instanceof Uint8ClampedArray) && (m = 5121), {
                    buffer: d,
                    type: m,
                    bytesPerElement: h.BYTES_PER_ELEMENT,
                    version: c.version
                }
            }

            function r(c, u, h) {
                const f = u.array,
                    d = u.updateRange;
                a.bindBuffer(h, c), d.count === -1 ? a.bufferSubData(h, 0, f) : (t ? a.bufferSubData(h, d.offset * f.BYTES_PER_ELEMENT, f, d.offset, d.count) : a.bufferSubData(h, d.offset * f.BYTES_PER_ELEMENT, f.subarray(d.offset, d.offset + d.count)), d.count = -1)
            }

            function s(c) {
                return c.isInterleavedBufferAttribute && (c = c.data), n.get(c)
            }

            function o(c) {
                c.isInterleavedBufferAttribute && (c = c.data);
                const u = n.get(c);
                u && (a.deleteBuffer(u.buffer), n.delete(c))
            }

            function l(c, u) {
                if (c.isGLBufferAttribute) {
                    const f = n.get(c);
                    (!f || f.version < c.version) && n.set(c, {
                        buffer: c.buffer,
                        type: c.type,
                        bytesPerElement: c.elementSize,
                        version: c.version
                    });
                    return
                }
                c.isInterleavedBufferAttribute && (c = c.data);
                const h = n.get(c);
                h === void 0 ? n.set(c, i(c, u)) : h.version < c.version && (r(h.buffer, c, u), h.version = c.version)
            }
            return {
                get: s,
                remove: o,
                update: l
            }
        }
        class Zn extends ke {
            constructor(e = 1, t = 1, n = 1, i = 1) {
                super();
                this.type = "PlaneGeometry", this.parameters = {
                    width: e,
                    height: t,
                    widthSegments: n,
                    heightSegments: i
                };
                const r = e / 2,
                    s = t / 2,
                    o = Math.floor(n),
                    l = Math.floor(i),
                    c = o + 1,
                    u = l + 1,
                    h = e / o,
                    f = t / l,
                    d = [],
                    m = [],
                    g = [],
                    v = [];
                for (let p = 0; p < u; p++) {
                    const _ = p * f - s;
                    for (let M = 0; M < c; M++) {
                        const y = M * h - r;
                        m.push(y, -_, 0), g.push(0, 0, 1), v.push(M / o), v.push(1 - p / l)
                    }
                }
                for (let p = 0; p < l; p++)
                    for (let _ = 0; _ < o; _++) {
                        const M = _ + c * p,
                            y = _ + c * (p + 1),
                            b = _ + 1 + c * (p + 1),
                            T = _ + 1 + c * p;
                        d.push(M, y, T), d.push(y, b, T)
                    }
                this.setIndex(d), this.setAttribute("position", new Je(m, 3)), this.setAttribute("normal", new Je(g, 3)), this.setAttribute("uv", new Je(v, 2))
            }
            static fromJSON(e) {
                return new Zn(e.width, e.height, e.widthSegments, e.heightSegments)
            }
        }
        var qm = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`,
            Xm = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
            jm = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,
            Ym = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
            Zm = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
            Jm = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
            $m = "vec3 transformed = vec3( position );",
            Km = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
            Qm = `vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenTint, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenTint * ( D * V );
}
#endif`,
            eg = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
            tg = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,
            ng = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
            ig = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
            rg = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
            sg = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
            ag = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
            og = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,
            lg = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,
            cg = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float linearToRelativeLuminance( const in vec3 color ) {
	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );
	return dot( weights, color.rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`,
            ug = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_maxMipLevel 8.0
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_maxTileSize 256.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );
		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );
		vec2 f = fract( uv );
		uv += 0.5 - f;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		if ( mipInt < cubeUV_maxMipLevel ) {
			uv.y += 2.0 * cubeUV_maxTileSize;
		}
		uv.y += filterInt * 2.0 * cubeUV_minTileSize;
		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );
		uv *= texelSize;
		vec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.x += texelSize;
		vec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.y += texelSize;
		vec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.x -= texelSize;
		vec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		vec3 tm = mix( tl, tr, f.x );
		vec3 bm = mix( bl, br, f.x );
		return mix( tm, bm, f.y );
	}
	#define r0 1.0
	#define v0 0.339
	#define m0 - 2.0
	#define r1 0.8
	#define v1 0.276
	#define m1 - 1.0
	#define r4 0.4
	#define v4 0.046
	#define m4 2.0
	#define r5 0.305
	#define v5 0.016
	#define m5 3.0
	#define r6 0.21
	#define v6 0.0038
	#define m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= r1 ) {
			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;
		} else if ( roughness >= r4 ) {
			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;
		} else if ( roughness >= r5 ) {
			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;
		} else if ( roughness >= r6 ) {
			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
            hg = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
            fg = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
            dg = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`,
            pg = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
            mg = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
            gg = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
            _g = `
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );
}
vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );
}
vec4 sRGBToLinear( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 RGBEToLinear( in vec4 value ) {
	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );
}
vec4 LinearToRGBE( in vec4 value ) {
	float maxComponent = max( max( value.r, value.g ), value.b );
	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );
	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );
}
vec4 RGBMToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * value.a * maxRange, 1.0 );
}
vec4 LinearToRGBM( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );
	M = ceil( M * 255.0 ) / 255.0;
	return vec4( value.rgb / ( M * maxRange ), M );
}
vec4 RGBDToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );
}
vec4 LinearToRGBD( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float D = max( maxRange / maxRGB, 1.0 );
	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );
	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );
}
const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );
vec4 LinearToLogLuv( in vec4 value ) {
	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;
	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );
	vec4 vResult;
	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;
	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;
	vResult.w = fract( Le );
	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;
	return vResult;
}
const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );
vec4 LogLuvToLinear( in vec4 value ) {
	float Le = value.z * 255.0 + value.w;
	vec3 Xp_Y_XYZp;
	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );
	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;
	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;
	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;
	return vec4( max( vRGB, 0.0 ), 1.0 );
}`,
            vg = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
		envColor = envMapTexelToLinear( envColor );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
            xg = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform int maxMipLevel;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
            yg = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
            Mg = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
            bg = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
            wg = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
            Sg = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
            Tg = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
            Eg = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
            Ag = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return texture2D( gradientMap, coord ).rgb;
	#else
		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );
	#endif
}`,
            Lg = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		lightMapIrradiance *= PI;
	#endif
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,
            Rg = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
            Cg = `vec3 diffuse = vec3( 1.0 );
GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;
vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif
IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;
vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
vIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );
#ifdef DOUBLE_SIDED
	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );
#endif
#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		getPointLightInfo( pointLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		getSpotLightInfo( spotLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_HEMI_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		#ifdef DOUBLE_SIDED
			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );
		#endif
	}
	#pragma unroll_loop_end
#endif`,
            Pg = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( PHYSICALLY_CORRECT_LIGHTS )
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#else
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
            Dg = `#if defined( USE_ENVMAP )
	#ifdef ENVMAP_MODE_REFRACTION
		uniform float refractionRatio;
	#endif
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec;
			#ifdef ENVMAP_MODE_REFLECTION
				reflectVec = reflect( - viewDir, normal );
				reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			#else
				reflectVec = refract( - viewDir, normal, refractionRatio );
			#endif
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`,
            Ig = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
            Fg = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
#define Material_LightProbeLOD( material )	(0)`,
            zg = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
            Ng = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)`,
            Bg = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	#ifdef SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularTintFactor = specularTint;
		#ifdef USE_SPECULARINTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;
		#endif
		#ifdef USE_SPECULARTINTMAP
			specularTintFactor *= specularTintMapTexelToLinear( texture2D( specularTintMap, vUv ) ).rgb;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularTintFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularTintFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_SHEEN
	material.sheenTint = sheenTint;
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
#endif`,
            Og = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenTint;
		float sheenRoughness;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	vec3 FssEss = specularColor * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		reflectedLight.directSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenTint, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
            Ug = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
            kg = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			lightMapIrradiance *= PI;
		#endif
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
            Gg = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,
            Hg = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
            Vg = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
            Wg = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,
            qg = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,
            Xg = `#ifdef USE_MAP
	vec4 texelColor = texture2D( map, vUv );
	texelColor = mapTexelToLinear( texelColor );
	diffuseColor *= texelColor;
#endif`,
            jg = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
            Yg = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	vec4 mapTexel = texture2D( map, uv );
	diffuseColor *= mapTexelToLinear( mapTexel );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
            Zg = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
            Jg = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
            $g = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
            Kg = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] > 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1, 2 ) * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,
            Qg = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform vec2 morphTargetsTextureSize;
		vec3 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset, const in int stride ) {
			float texelIndex = float( vertexIndex * stride + offset );
			float y = floor( texelIndex / morphTargetsTextureSize.x );
			float x = texelIndex - y * morphTargetsTextureSize.x;
			vec3 morphUV = vec3( ( x + 0.5 ) / morphTargetsTextureSize.x, y / morphTargetsTextureSize.y, morphTargetIndex );
			return texture( morphTargetsTexture, morphUV ).xyz;
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,
            e0 = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			#ifndef USE_MORPHNORMALS
				if ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 1 ) * morphTargetInfluences[ i ];
			#else
				if ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 2 ) * morphTargetInfluences[ i ];
			#endif
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,
            t0 = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`,
            n0 = `#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
            i0 = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
            r0 = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
            s0 = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
            a0 = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`,
            o0 = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,
            l0 = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`,
            c0 = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`,
            u0 = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
            h0 = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`,
            f0 = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
            d0 = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
            p0 = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
            m0 = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
            g0 = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
            _0 = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
            v0 = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,
            x0 = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
            y0 = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`,
            M0 = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
            b0 = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
            w0 = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	#ifdef BONE_TEXTURE
		uniform highp sampler2D boneTexture;
		uniform int boneTextureSize;
		mat4 getBoneMatrix( const in float i ) {
			float j = i * 4.0;
			float x = mod( j, float( boneTextureSize ) );
			float y = floor( j / float( boneTextureSize ) );
			float dx = 1.0 / float( boneTextureSize );
			float dy = 1.0 / float( boneTextureSize );
			y = dy * ( y + 0.5 );
			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
			mat4 bone = mat4( v1, v2, v3, v4 );
			return bone;
		}
	#else
		uniform mat4 boneMatrices[ MAX_BONES ];
		mat4 getBoneMatrix( const in float i ) {
			mat4 bone = boneMatrices[ int(i) ];
			return bone;
		}
	#endif
#endif`,
            S0 = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
            T0 = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
            E0 = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
            A0 = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
            L0 = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
            R0 = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
            C0 = `#ifdef USE_TRANSMISSION
	float transmissionAlpha = 1.0;
	float transmissionFactor = transmission;
	float thicknessFactor = thickness;
	#ifdef USE_TRANSMISSIONMAP
		transmissionFactor *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		thicknessFactor *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,
		attenuationTint, attenuationDistance );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );
	transmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );
#endif`,
            P0 = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationTint;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	vec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( float roughness, float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( vec2 fragCoord, float roughness, float ior ) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		#ifdef TEXTURE_LOD_EXT
			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#else
			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#endif
	}
	vec3 applyVolumeAttenuation( vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance ) {
		if ( attenuationDistance == 0.0 ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 diffuseColor, vec3 specularColor, float specularF90,
		vec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,
		vec3 attenuationColor, float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`,
            D0 = `#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`,
            I0 = `#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`,
            F0 = `#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`,
            z0 = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`,
            N0 = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`,
            B0 = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`,
            O0 = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
        const Re = {
                alphamap_fragment: qm,
                alphamap_pars_fragment: Xm,
                alphatest_fragment: jm,
                alphatest_pars_fragment: Ym,
                aomap_fragment: Zm,
                aomap_pars_fragment: Jm,
                begin_vertex: $m,
                beginnormal_vertex: Km,
                bsdfs: Qm,
                bumpmap_pars_fragment: eg,
                clipping_planes_fragment: tg,
                clipping_planes_pars_fragment: ng,
                clipping_planes_pars_vertex: ig,
                clipping_planes_vertex: rg,
                color_fragment: sg,
                color_pars_fragment: ag,
                color_pars_vertex: og,
                color_vertex: lg,
                common: cg,
                cube_uv_reflection_fragment: ug,
                defaultnormal_vertex: hg,
                displacementmap_pars_vertex: fg,
                displacementmap_vertex: dg,
                emissivemap_fragment: pg,
                emissivemap_pars_fragment: mg,
                encodings_fragment: gg,
                encodings_pars_fragment: _g,
                envmap_fragment: vg,
                envmap_common_pars_fragment: xg,
                envmap_pars_fragment: yg,
                envmap_pars_vertex: Mg,
                envmap_physical_pars_fragment: Dg,
                envmap_vertex: bg,
                fog_vertex: wg,
                fog_pars_vertex: Sg,
                fog_fragment: Tg,
                fog_pars_fragment: Eg,
                gradientmap_pars_fragment: Ag,
                lightmap_fragment: Lg,
                lightmap_pars_fragment: Rg,
                lights_lambert_vertex: Cg,
                lights_pars_begin: Pg,
                lights_toon_fragment: Ig,
                lights_toon_pars_fragment: Fg,
                lights_phong_fragment: zg,
                lights_phong_pars_fragment: Ng,
                lights_physical_fragment: Bg,
                lights_physical_pars_fragment: Og,
                lights_fragment_begin: Ug,
                lights_fragment_maps: kg,
                lights_fragment_end: Gg,
                logdepthbuf_fragment: Hg,
                logdepthbuf_pars_fragment: Vg,
                logdepthbuf_pars_vertex: Wg,
                logdepthbuf_vertex: qg,
                map_fragment: Xg,
                map_pars_fragment: jg,
                map_particle_fragment: Yg,
                map_particle_pars_fragment: Zg,
                metalnessmap_fragment: Jg,
                metalnessmap_pars_fragment: $g,
                morphnormal_vertex: Kg,
                morphtarget_pars_vertex: Qg,
                morphtarget_vertex: e0,
                normal_fragment_begin: t0,
                normal_fragment_maps: n0,
                normal_pars_fragment: i0,
                normal_pars_vertex: r0,
                normal_vertex: s0,
                normalmap_pars_fragment: a0,
                clearcoat_normal_fragment_begin: o0,
                clearcoat_normal_fragment_maps: l0,
                clearcoat_pars_fragment: c0,
                output_fragment: u0,
                packing: h0,
                premultiplied_alpha_fragment: f0,
                project_vertex: d0,
                dithering_fragment: p0,
                dithering_pars_fragment: m0,
                roughnessmap_fragment: g0,
                roughnessmap_pars_fragment: _0,
                shadowmap_pars_fragment: v0,
                shadowmap_pars_vertex: x0,
                shadowmap_vertex: y0,
                shadowmask_pars_fragment: M0,
                skinbase_vertex: b0,
                skinning_pars_vertex: w0,
                skinning_vertex: S0,
                skinnormal_vertex: T0,
                specularmap_fragment: E0,
                specularmap_pars_fragment: A0,
                tonemapping_fragment: L0,
                tonemapping_pars_fragment: R0,
                transmission_fragment: C0,
                transmission_pars_fragment: P0,
                uv_pars_fragment: D0,
                uv_pars_vertex: I0,
                uv_vertex: F0,
                uv2_pars_fragment: z0,
                uv2_pars_vertex: N0,
                uv2_vertex: B0,
                worldpos_vertex: O0,
                background_vert: `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
                background_frag: `uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
                cube_vert: `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
                cube_frag: `#include <envmap_common_pars_fragment>
uniform float opacity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>
	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
                depth_vert: `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
                depth_frag: `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,
                distanceRGBA_vert: `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
                distanceRGBA_frag: `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
                equirect_vert: `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
                equirect_frag: `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	vec4 texColor = texture2D( tEquirect, sampleUV );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
                linedashed_vert: `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
                linedashed_frag: `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
                meshbasic_vert: `#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
                meshbasic_frag: `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
                meshlambert_vert: `#define LAMBERT
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
                meshlambert_frag: `uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>
	#ifdef DOUBLE_SIDED
		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;
	#else
		reflectedLight.indirectDiffuse += vIndirectFront;
	#endif
	#include <lightmap_fragment>
	reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );
	#ifdef DOUBLE_SIDED
		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;
	#else
		reflectedLight.directDiffuse = vLightFront;
	#endif
	reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
                meshmatcap_vert: `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
                meshmatcap_frag: `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
		matcapColor = matcapTexelToLinear( matcapColor );
	#else
		vec4 matcapColor = vec4( 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
                meshnormal_vert: `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
                meshnormal_frag: `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
}`,
                meshphong_vert: `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
                meshphong_frag: `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
                meshphysical_vert: `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
                meshphysical_frag: `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularTint;
	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
	#ifdef USE_SPECULARTINTMAP
		uniform sampler2D specularTintMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenTint;
	uniform float sheenRoughness;
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - clearcoat * Fcc ) + clearcoatSpecular * clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
                meshtoon_vert: `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
                meshtoon_frag: `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
                points_vert: `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
                points_frag: `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
                shadow_vert: `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
                shadow_frag: `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,
                sprite_vert: `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
                sprite_frag: `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`
            },
            re = {
                common: {
                    diffuse: {
                        value: new ne(16777215)
                    },
                    opacity: {
                        value: 1
                    },
                    map: {
                        value: null
                    },
                    uvTransform: {
                        value: new mt
                    },
                    uv2Transform: {
                        value: new mt
                    },
                    alphaMap: {
                        value: null
                    },
                    alphaTest: {
                        value: 0
                    }
                },
                specularmap: {
                    specularMap: {
                        value: null
                    }
                },
                envmap: {
                    envMap: {
                        value: null
                    },
                    flipEnvMap: {
                        value: -1
                    },
                    reflectivity: {
                        value: 1
                    },
                    ior: {
                        value: 1.5
                    },
                    refractionRatio: {
                        value: .98
                    },
                    maxMipLevel: {
                        value: 0
                    }
                },
                aomap: {
                    aoMap: {
                        value: null
                    },
                    aoMapIntensity: {
                        value: 1
                    }
                },
                lightmap: {
                    lightMap: {
                        value: null
                    },
                    lightMapIntensity: {
                        value: 1
                    }
                },
                emissivemap: {
                    emissiveMap: {
                        value: null
                    }
                },
                bumpmap: {
                    bumpMap: {
                        value: null
                    },
                    bumpScale: {
                        value: 1
                    }
                },
                normalmap: {
                    normalMap: {
                        value: null
                    },
                    normalScale: {
                        value: new X(1, 1)
                    }
                },
                displacementmap: {
                    displacementMap: {
                        value: null
                    },
                    displacementScale: {
                        value: 1
                    },
                    displacementBias: {
                        value: 0
                    }
                },
                roughnessmap: {
                    roughnessMap: {
                        value: null
                    }
                },
                metalnessmap: {
                    metalnessMap: {
                        value: null
                    }
                },
                gradientmap: {
                    gradientMap: {
                        value: null
                    }
                },
                fog: {
                    fogDensity: {
                        value: 25e-5
                    },
                    fogNear: {
                        value: 1
                    },
                    fogFar: {
                        value: 2e3
                    },
                    fogColor: {
                        value: new ne(16777215)
                    }
                },
                lights: {
                    ambientLightColor: {
                        value: []
                    },
                    lightProbe: {
                        value: []
                    },
                    directionalLights: {
                        value: [],
                        properties: {
                            direction: {},
                            color: {}
                        }
                    },
                    directionalLightShadows: {
                        value: [],
                        properties: {
                            shadowBias: {},
                            shadowNormalBias: {},
                            shadowRadius: {},
                            shadowMapSize: {}
                        }
                    },
                    directionalShadowMap: {
                        value: []
                    },
                    directionalShadowMatrix: {
                        value: []
                    },
                    spotLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            direction: {},
                            distance: {},
                            coneCos: {},
                            penumbraCos: {},
                            decay: {}
                        }
                    },
                    spotLightShadows: {
                        value: [],
                        properties: {
                            shadowBias: {},
                            shadowNormalBias: {},
                            shadowRadius: {},
                            shadowMapSize: {}
                        }
                    },
                    spotShadowMap: {
                        value: []
                    },
                    spotShadowMatrix: {
                        value: []
                    },
                    pointLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            decay: {},
                            distance: {}
                        }
                    },
                    pointLightShadows: {
                        value: [],
                        properties: {
                            shadowBias: {},
                            shadowNormalBias: {},
                            shadowRadius: {},
                            shadowMapSize: {},
                            shadowCameraNear: {},
                            shadowCameraFar: {}
                        }
                    },
                    pointShadowMap: {
                        value: []
                    },
                    pointShadowMatrix: {
                        value: []
                    },
                    hemisphereLights: {
                        value: [],
                        properties: {
                            direction: {},
                            skyColor: {},
                            groundColor: {}
                        }
                    },
                    rectAreaLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            width: {},
                            height: {}
                        }
                    },
                    ltc_1: {
                        value: null
                    },
                    ltc_2: {
                        value: null
                    }
                },
                points: {
                    diffuse: {
                        value: new ne(16777215)
                    },
                    opacity: {
                        value: 1
                    },
                    size: {
                        value: 1
                    },
                    scale: {
                        value: 1
                    },
                    map: {
                        value: null
                    },
                    alphaMap: {
                        value: null
                    },
                    alphaTest: {
                        value: 0
                    },
                    uvTransform: {
                        value: new mt
                    }
                },
                sprite: {
                    diffuse: {
                        value: new ne(16777215)
                    },
                    opacity: {
                        value: 1
                    },
                    center: {
                        value: new X(.5, .5)
                    },
                    rotation: {
                        value: 0
                    },
                    map: {
                        value: null
                    },
                    alphaMap: {
                        value: null
                    },
                    alphaTest: {
                        value: 0
                    },
                    uvTransform: {
                        value: new mt
                    }
                }
            },
            hn = {
                basic: {
                    uniforms: xt([re.common, re.specularmap, re.envmap, re.aomap, re.lightmap, re.fog]),
                    vertexShader: Re.meshbasic_vert,
                    fragmentShader: Re.meshbasic_frag
                },
                lambert: {
                    uniforms: xt([re.common, re.specularmap, re.envmap, re.aomap, re.lightmap, re.emissivemap, re.fog, re.lights, {
                        emissive: {
                            value: new ne(0)
                        }
                    }]),
                    vertexShader: Re.meshlambert_vert,
                    fragmentShader: Re.meshlambert_frag
                },
                phong: {
                    uniforms: xt([re.common, re.specularmap, re.envmap, re.aomap, re.lightmap, re.emissivemap, re.bumpmap, re.normalmap, re.displacementmap, re.fog, re.lights, {
                        emissive: {
                            value: new ne(0)
                        },
                        specular: {
                            value: new ne(1118481)
                        },
                        shininess: {
                            value: 30
                        }
                    }]),
                    vertexShader: Re.meshphong_vert,
                    fragmentShader: Re.meshphong_frag
                },
                standard: {
                    uniforms: xt([re.common, re.envmap, re.aomap, re.lightmap, re.emissivemap, re.bumpmap, re.normalmap, re.displacementmap, re.roughnessmap, re.metalnessmap, re.fog, re.lights, {
                        emissive: {
                            value: new ne(0)
                        },
                        roughness: {
                            value: 1
                        },
                        metalness: {
                            value: 0
                        },
                        envMapIntensity: {
                            value: 1
                        }
                    }]),
                    vertexShader: Re.meshphysical_vert,
                    fragmentShader: Re.meshphysical_frag
                },
                toon: {
                    uniforms: xt([re.common, re.aomap, re.lightmap, re.emissivemap, re.bumpmap, re.normalmap, re.displacementmap, re.gradientmap, re.fog, re.lights, {
                        emissive: {
                            value: new ne(0)
                        }
                    }]),
                    vertexShader: Re.meshtoon_vert,
                    fragmentShader: Re.meshtoon_frag
                },
                matcap: {
                    uniforms: xt([re.common, re.bumpmap, re.normalmap, re.displacementmap, re.fog, {
                        matcap: {
                            value: null
                        }
                    }]),
                    vertexShader: Re.meshmatcap_vert,
                    fragmentShader: Re.meshmatcap_frag
                },
                points: {
                    uniforms: xt([re.points, re.fog]),
                    vertexShader: Re.points_vert,
                    fragmentShader: Re.points_frag
                },
                dashed: {
                    uniforms: xt([re.common, re.fog, {
                        scale: {
                            value: 1
                        },
                        dashSize: {
                            value: 1
                        },
                        totalSize: {
                            value: 2
                        }
                    }]),
                    vertexShader: Re.linedashed_vert,
                    fragmentShader: Re.linedashed_frag
                },
                depth: {
                    uniforms: xt([re.common, re.displacementmap]),
                    vertexShader: Re.depth_vert,
                    fragmentShader: Re.depth_frag
                },
                normal: {
                    uniforms: xt([re.common, re.bumpmap, re.normalmap, re.displacementmap, {
                        opacity: {
                            value: 1
                        }
                    }]),
                    vertexShader: Re.meshnormal_vert,
                    fragmentShader: Re.meshnormal_frag
                },
                sprite: {
                    uniforms: xt([re.sprite, re.fog]),
                    vertexShader: Re.sprite_vert,
                    fragmentShader: Re.sprite_frag
                },
                background: {
                    uniforms: {
                        uvTransform: {
                            value: new mt
                        },
                        t2D: {
                            value: null
                        }
                    },
                    vertexShader: Re.background_vert,
                    fragmentShader: Re.background_frag
                },
                cube: {
                    uniforms: xt([re.envmap, {
                        opacity: {
                            value: 1
                        }
                    }]),
                    vertexShader: Re.cube_vert,
                    fragmentShader: Re.cube_frag
                },
                equirect: {
                    uniforms: {
                        tEquirect: {
                            value: null
                        }
                    },
                    vertexShader: Re.equirect_vert,
                    fragmentShader: Re.equirect_frag
                },
                distanceRGBA: {
                    uniforms: xt([re.common, re.displacementmap, {
                        referencePosition: {
                            value: new E
                        },
                        nearDistance: {
                            value: 1
                        },
                        farDistance: {
                            value: 1e3
                        }
                    }]),
                    vertexShader: Re.distanceRGBA_vert,
                    fragmentShader: Re.distanceRGBA_frag
                },
                shadow: {
                    uniforms: xt([re.lights, re.fog, {
                        color: {
                            value: new ne(0)
                        },
                        opacity: {
                            value: 1
                        }
                    }]),
                    vertexShader: Re.shadow_vert,
                    fragmentShader: Re.shadow_frag
                }
            };
        hn.physical = {
            uniforms: xt([hn.standard.uniforms, {
                clearcoat: {
                    value: 0
                },
                clearcoatMap: {
                    value: null
                },
                clearcoatRoughness: {
                    value: 0
                },
                clearcoatRoughnessMap: {
                    value: null
                },
                clearcoatNormalScale: {
                    value: new X(1, 1)
                },
                clearcoatNormalMap: {
                    value: null
                },
                sheen: {
                    value: 0
                },
                sheenTint: {
                    value: new ne(0)
                },
                sheenRoughness: {
                    value: 0
                },
                transmission: {
                    value: 0
                },
                transmissionMap: {
                    value: null
                },
                transmissionSamplerSize: {
                    value: new X
                },
                transmissionSamplerMap: {
                    value: null
                },
                thickness: {
                    value: 0
                },
                thicknessMap: {
                    value: null
                },
                attenuationDistance: {
                    value: 0
                },
                attenuationTint: {
                    value: new ne(0)
                },
                specularIntensity: {
                    value: 0
                },
                specularIntensityMap: {
                    value: null
                },
                specularTint: {
                    value: new ne(1, 1, 1)
                },
                specularTintMap: {
                    value: null
                }
            }]),
            vertexShader: Re.meshphysical_vert,
            fragmentShader: Re.meshphysical_frag
        };

        function U0(a, e, t, n, i) {
            const r = new ne(0);
            let s = 0,
                o, l, c = null,
                u = 0,
                h = null;

            function f(m, g) {
                let v = !1,
                    p = g.isScene === !0 ? g.background : null;
                p && p.isTexture && (p = e.get(p));
                const _ = a.xr,
                    M = _.getSession && _.getSession();
                M && M.environmentBlendMode === "additive" && (p = null), p === null ? d(r, s) : p && p.isColor && (d(p, 1), v = !0), (a.autoClear || v) && a.clear(a.autoClearColor, a.autoClearDepth, a.autoClearStencil), p && (p.isCubeTexture || p.mapping === Ys) ? (l === void 0 && (l = new Ge(new Yn(1, 1, 1), new It({
                    name: "BackgroundCubeMaterial",
                    uniforms: cr(hn.cube.uniforms),
                    vertexShader: hn.cube.vertexShader,
                    fragmentShader: hn.cube.fragmentShader,
                    side: nt,
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1
                })), l.geometry.deleteAttribute("normal"), l.geometry.deleteAttribute("uv"), l.onBeforeRender = function(y, b, T) {
                    this.matrixWorld.copyPosition(T.matrixWorld)
                }, Object.defineProperty(l.material, "envMap", {
                    get: function() {
                        return this.uniforms.envMap.value
                    }
                }), n.update(l)), l.material.uniforms.envMap.value = p, l.material.uniforms.flipEnvMap.value = p.isCubeTexture && p.isRenderTargetTexture === !1 ? -1 : 1, (c !== p || u !== p.version || h !== a.toneMapping) && (l.material.needsUpdate = !0, c = p, u = p.version, h = a.toneMapping), m.unshift(l, l.geometry, l.material, 0, 0, null)) : p && p.isTexture && (o === void 0 && (o = new Ge(new Zn(2, 2), new It({
                    name: "BackgroundMaterial",
                    uniforms: cr(hn.background.uniforms),
                    vertexShader: hn.background.vertexShader,
                    fragmentShader: hn.background.fragmentShader,
                    side: Vi,
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1
                })), o.geometry.deleteAttribute("normal"), Object.defineProperty(o.material, "map", {
                    get: function() {
                        return this.uniforms.t2D.value
                    }
                }), n.update(o)), o.material.uniforms.t2D.value = p, p.matrixAutoUpdate === !0 && p.updateMatrix(), o.material.uniforms.uvTransform.value.copy(p.matrix), (c !== p || u !== p.version || h !== a.toneMapping) && (o.material.needsUpdate = !0, c = p, u = p.version, h = a.toneMapping), m.unshift(o, o.geometry, o.material, 0, 0, null))
            }

            function d(m, g) {
                t.buffers.color.setClear(m.r, m.g, m.b, g, i)
            }
            return {
                getClearColor: function() {
                    return r
                },
                setClearColor: function(m, g = 1) {
                    r.set(m), s = g, d(r, s)
                },
                getClearAlpha: function() {
                    return s
                },
                setClearAlpha: function(m) {
                    s = m, d(r, s)
                },
                render: f
            }
        }

        function k0(a, e, t, n) {
            const i = a.getParameter(34921),
                r = n.isWebGL2 ? null : e.get("OES_vertex_array_object"),
                s = n.isWebGL2 || r !== null,
                o = {},
                l = g(null);
            let c = l;

            function u(D, F, N, z, k) {
                let J = !1;
                if (s) {
                    const oe = m(z, N, F);
                    c !== oe && (c = oe, f(c.object)), J = v(z, k), J && p(z, k)
                } else {
                    const oe = F.wireframe === !0;
                    (c.geometry !== z.id || c.program !== N.id || c.wireframe !== oe) && (c.geometry = z.id, c.program = N.id, c.wireframe = oe, J = !0)
                }
                D.isInstancedMesh === !0 && (J = !0), k !== null && t.update(k, 34963), J && (x(D, F, N, z), k !== null && a.bindBuffer(34963, t.get(k).buffer))
            }

            function h() {
                return n.isWebGL2 ? a.createVertexArray() : r.createVertexArrayOES()
            }

            function f(D) {
                return n.isWebGL2 ? a.bindVertexArray(D) : r.bindVertexArrayOES(D)
            }

            function d(D) {
                return n.isWebGL2 ? a.deleteVertexArray(D) : r.deleteVertexArrayOES(D)
            }

            function m(D, F, N) {
                const z = N.wireframe === !0;
                let k = o[D.id];
                k === void 0 && (k = {}, o[D.id] = k);
                let J = k[F.id];
                J === void 0 && (J = {}, k[F.id] = J);
                let oe = J[z];
                return oe === void 0 && (oe = g(h()), J[z] = oe), oe
            }

            function g(D) {
                const F = [],
                    N = [],
                    z = [];
                for (let k = 0; k < i; k++) F[k] = 0, N[k] = 0, z[k] = 0;
                return {
                    geometry: null,
                    program: null,
                    wireframe: !1,
                    newAttributes: F,
                    enabledAttributes: N,
                    attributeDivisors: z,
                    object: D,
                    attributes: {},
                    index: null
                }
            }

            function v(D, F) {
                const N = c.attributes,
                    z = D.attributes;
                let k = 0;
                for (const J in z) {
                    const oe = N[J],
                        he = z[J];
                    if (oe === void 0 || oe.attribute !== he || oe.data !== he.data) return !0;
                    k++
                }
                return c.attributesNum !== k || c.index !== F
            }

            function p(D, F) {
                const N = {},
                    z = D.attributes;
                let k = 0;
                for (const J in z) {
                    const oe = z[J],
                        he = {};
                    he.attribute = oe, oe.data && (he.data = oe.data), N[J] = he, k++
                }
                c.attributes = N, c.attributesNum = k, c.index = F
            }

            function _() {
                const D = c.newAttributes;
                for (let F = 0, N = D.length; F < N; F++) D[F] = 0
            }

            function M(D) {
                y(D, 0)
            }

            function y(D, F) {
                const N = c.newAttributes,
                    z = c.enabledAttributes,
                    k = c.attributeDivisors;
                N[D] = 1, z[D] === 0 && (a.enableVertexAttribArray(D), z[D] = 1), k[D] !== F && ((n.isWebGL2 ? a : e.get("ANGLE_instanced_arrays"))[n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](D, F), k[D] = F)
            }

            function b() {
                const D = c.newAttributes,
                    F = c.enabledAttributes;
                for (let N = 0, z = F.length; N < z; N++) F[N] !== D[N] && (a.disableVertexAttribArray(N), F[N] = 0)
            }

            function T(D, F, N, z, k, J) {
                n.isWebGL2 === !0 && (N === 5124 || N === 5125) ? a.vertexAttribIPointer(D, F, N, k, J) : a.vertexAttribPointer(D, F, N, z, k, J)
            }

            function x(D, F, N, z) {
                if (n.isWebGL2 === !1 && (D.isInstancedMesh || z.isInstancedBufferGeometry) && e.get("ANGLE_instanced_arrays") === null) return;
                _();
                const k = z.attributes,
                    J = N.getAttributes(),
                    oe = F.defaultAttributeValues;
                for (const he in J) {
                    const ie = J[he];
                    if (ie.location >= 0) {
                        let be = k[he];
                        if (be === void 0 && (he === "instanceMatrix" && D.instanceMatrix && (be = D.instanceMatrix), he === "instanceColor" && D.instanceColor && (be = D.instanceColor)), be !== void 0) {
                            const W = be.normalized,
                                $ = be.itemSize,
                                me = t.get(be);
                            if (me === void 0) continue;
                            const G = me.buffer,
                                xe = me.type,
                                Se = me.bytesPerElement;
                            if (be.isInterleavedBufferAttribute) {
                                const le = be.data,
                                    de = le.stride,
                                    Le = be.offset;
                                if (le && le.isInstancedInterleavedBuffer) {
                                    for (let V = 0; V < ie.locationSize; V++) y(ie.location + V, le.meshPerAttribute);
                                    D.isInstancedMesh !== !0 && z._maxInstanceCount === void 0 && (z._maxInstanceCount = le.meshPerAttribute * le.count)
                                } else
                                    for (let V = 0; V < ie.locationSize; V++) M(ie.location + V);
                                a.bindBuffer(34962, G);
                                for (let V = 0; V < ie.locationSize; V++) T(ie.location + V, $ / ie.locationSize, xe, W, de * Se, (Le + $ / ie.locationSize * V) * Se)
                            } else {
                                if (be.isInstancedBufferAttribute) {
                                    for (let le = 0; le < ie.locationSize; le++) y(ie.location + le, be.meshPerAttribute);
                                    D.isInstancedMesh !== !0 && z._maxInstanceCount === void 0 && (z._maxInstanceCount = be.meshPerAttribute * be.count)
                                } else
                                    for (let le = 0; le < ie.locationSize; le++) M(ie.location + le);
                                a.bindBuffer(34962, G);
                                for (let le = 0; le < ie.locationSize; le++) T(ie.location + le, $ / ie.locationSize, xe, W, $ * Se, $ / ie.locationSize * le * Se)
                            }
                        } else if (oe !== void 0) {
                            const W = oe[he];
                            if (W !== void 0) switch (W.length) {
                                case 2:
                                    a.vertexAttrib2fv(ie.location, W);
                                    break;
                                case 3:
                                    a.vertexAttrib3fv(ie.location, W);
                                    break;
                                case 4:
                                    a.vertexAttrib4fv(ie.location, W);
                                    break;
                                default:
                                    a.vertexAttrib1fv(ie.location, W)
                            }
                        }
                    }
                }
                b()
            }

            function R() {
                L();
                for (const D in o) {
                    const F = o[D];
                    for (const N in F) {
                        const z = F[N];
                        for (const k in z) d(z[k].object), delete z[k];
                        delete F[N]
                    }
                    delete o[D]
                }
            }

            function P(D) {
                if (o[D.id] === void 0) return;
                const F = o[D.id];
                for (const N in F) {
                    const z = F[N];
                    for (const k in z) d(z[k].object), delete z[k];
                    delete F[N]
                }
                delete o[D.id]
            }

            function I(D) {
                for (const F in o) {
                    const N = o[F];
                    if (N[D.id] === void 0) continue;
                    const z = N[D.id];
                    for (const k in z) d(z[k].object), delete z[k];
                    delete N[D.id]
                }
            }

            function L() {
                Y(), c !== l && (c = l, f(c.object))
            }

            function Y() {
                l.geometry = null, l.program = null, l.wireframe = !1
            }
            return {
                setup: u,
                reset: L,
                resetDefaultState: Y,
                dispose: R,
                releaseStatesOfGeometry: P,
                releaseStatesOfProgram: I,
                initAttributes: _,
                enableAttribute: M,
                disableUnusedAttributes: b
            }
        }

        function G0(a, e, t, n) {
            const i = n.isWebGL2;
            let r;

            function s(c) {
                r = c
            }

            function o(c, u) {
                a.drawArrays(r, c, u), t.update(u, r, 1)
            }

            function l(c, u, h) {
                if (h === 0) return;
                let f, d;
                if (i) f = a, d = "drawArraysInstanced";
                else if (f = e.get("ANGLE_instanced_arrays"), d = "drawArraysInstancedANGLE", f === null) {
                    console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                    return
                }
                f[d](r, c, u, h), t.update(u, r, h)
            }
            this.setMode = s, this.render = o, this.renderInstances = l
        }

        function H0(a, e, t) {
            let n;

            function i() {
                if (n !== void 0) return n;
                if (e.has("EXT_texture_filter_anisotropic") === !0) {
                    const x = e.get("EXT_texture_filter_anisotropic");
                    n = a.getParameter(x.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                } else n = 0;
                return n
            }

            function r(x) {
                if (x === "highp") {
                    if (a.getShaderPrecisionFormat(35633, 36338).precision > 0 && a.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";
                    x = "mediump"
                }
                return x === "mediump" && a.getShaderPrecisionFormat(35633, 36337).precision > 0 && a.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp"
            }
            const s = typeof WebGL2RenderingContext != "undefined" && a instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext != "undefined" && a instanceof WebGL2ComputeRenderingContext;
            let o = t.precision !== void 0 ? t.precision : "highp";
            const l = r(o);
            l !== o && (console.warn("THREE.WebGLRenderer:", o, "not supported, using", l, "instead."), o = l);
            const c = s || e.has("WEBGL_draw_buffers"),
                u = t.logarithmicDepthBuffer === !0,
                h = a.getParameter(34930),
                f = a.getParameter(35660),
                d = a.getParameter(3379),
                m = a.getParameter(34076),
                g = a.getParameter(34921),
                v = a.getParameter(36347),
                p = a.getParameter(36348),
                _ = a.getParameter(36349),
                M = f > 0,
                y = s || e.has("OES_texture_float"),
                b = M && y,
                T = s ? a.getParameter(36183) : 0;
            return {
                isWebGL2: s,
                drawBuffers: c,
                getMaxAnisotropy: i,
                getMaxPrecision: r,
                precision: o,
                logarithmicDepthBuffer: u,
                maxTextures: h,
                maxVertexTextures: f,
                maxTextureSize: d,
                maxCubemapSize: m,
                maxAttributes: g,
                maxVertexUniforms: v,
                maxVaryings: p,
                maxFragmentUniforms: _,
                vertexTextures: M,
                floatFragmentTextures: y,
                floatVertexTextures: b,
                maxSamples: T
            }
        }

        function V0(a) {
            const e = this;
            let t = null,
                n = 0,
                i = !1,
                r = !1;
            const s = new En,
                o = new mt,
                l = {
                    value: null,
                    needsUpdate: !1
                };
            this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function(h, f, d) {
                const m = h.length !== 0 || f || n !== 0 || i;
                return i = f, t = u(h, d, 0), n = h.length, m
            }, this.beginShadows = function() {
                r = !0, u(null)
            }, this.endShadows = function() {
                r = !1, c()
            }, this.setState = function(h, f, d) {
                const m = h.clippingPlanes,
                    g = h.clipIntersection,
                    v = h.clipShadows,
                    p = a.get(h);
                if (!i || m === null || m.length === 0 || r && !v) r ? u(null) : c();
                else {
                    const _ = r ? 0 : n,
                        M = _ * 4;
                    let y = p.clippingState || null;
                    l.value = y, y = u(m, f, M, d);
                    for (let b = 0; b !== M; ++b) y[b] = t[b];
                    p.clippingState = y, this.numIntersection = g ? this.numPlanes : 0, this.numPlanes += _
                }
            };

            function c() {
                l.value !== t && (l.value = t, l.needsUpdate = n > 0), e.numPlanes = n, e.numIntersection = 0
            }

            function u(h, f, d, m) {
                const g = h !== null ? h.length : 0;
                let v = null;
                if (g !== 0) {
                    if (v = l.value, m !== !0 || v === null) {
                        const p = d + g * 4,
                            _ = f.matrixWorldInverse;
                        o.getNormalMatrix(_), (v === null || v.length < p) && (v = new Float32Array(p));
                        for (let M = 0, y = d; M !== g; ++M, y += 4) s.copy(h[M]).applyMatrix4(_, o), s.normal.toArray(v, y), v[y + 3] = s.constant
                    }
                    l.value = v, l.needsUpdate = !0
                }
                return e.numPlanes = g, e.numIntersection = 0, v
            }
        }

        function W0(a) {
            let e = new WeakMap;

            function t(s, o) {
                return o === io ? s.mapping = Xs : o === ro && (s.mapping = js), s
            }

            function n(s) {
                if (s && s.isTexture && s.isRenderTargetTexture === !1) {
                    const o = s.mapping;
                    if (o === io || o === ro)
                        if (e.has(s)) {
                            const l = e.get(s).texture;
                            return t(l, s.mapping)
                        } else {
                            const l = s.image;
                            if (l && l.height > 0) {
                                const c = a.getRenderTarget(),
                                    u = new pu(l.height / 2);
                                return u.fromEquirectangularTexture(a, s), e.set(s, u), a.setRenderTarget(c), s.addEventListener("dispose", i), t(u.texture, s.mapping)
                            } else return null
                        }
                }
                return s
            }

            function i(s) {
                const o = s.target;
                o.removeEventListener("dispose", i);
                const l = e.get(o);
                l !== void 0 && (e.delete(o), l.dispose())
            }

            function r() {
                e = new WeakMap
            }
            return {
                get: n,
                dispose: r
            }
        }
        class dr extends Uo {
            constructor(e = -1, t = 1, n = 1, i = -1, r = .1, s = 2e3) {
                super();
                this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = n, this.bottom = i, this.near = r, this.far = s, this.updateProjectionMatrix()
            }
            copy(e, t) {
                return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this
            }
            setViewOffset(e, t, n, i, r, s) {
                this.view === null && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = s, this.updateProjectionMatrix()
            }
            clearViewOffset() {
                this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix()
            }
            updateProjectionMatrix() {
                const e = (this.right - this.left) / (2 * this.zoom),
                    t = (this.top - this.bottom) / (2 * this.zoom),
                    n = (this.right + this.left) / 2,
                    i = (this.top + this.bottom) / 2;
                let r = n - e,
                    s = n + e,
                    o = i + t,
                    l = i - t;
                if (this.view !== null && this.view.enabled) {
                    const c = (this.right - this.left) / this.view.fullWidth / this.zoom,
                        u = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                    r += c * this.view.offsetX, s = r + c * this.view.width, o -= u * this.view.offsetY, l = o - u * this.view.height
                }
                this.projectionMatrix.makeOrthographic(r, s, o, l, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
            }
            toJSON(e) {
                const t = super.toJSON(e);
                return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, this.view !== null && (t.object.view = Object.assign({}, this.view)), t
            }
        }
        dr.prototype.isOrthographicCamera = !0;
        class An extends It {
            constructor(e) {
                super(e);
                this.type = "RawShaderMaterial"
            }
        }
        An.prototype.isRawShaderMaterial = !0;
        const pr = 4,
            Jn = 8,
            fn = Math.pow(2, Jn),
            gu = [.125, .215, .35, .446, .526, .582],
            _u = Jn - pr + 1 + gu.length,
            mr = 20,
            $n = {
                [vt]: 0,
                [Ot]: 1,
                [ho]: 2,
                [Xc]: 3,
                [jc]: 4,
                [Yc]: 5,
                [uo]: 6
            },
            Ho = new dr,
            {
                _lodPlanes: cs,
                _sizeLods: vu,
                _sigmas: Ma
            } = X0(),
            xu = new ne;
        let Vo = null;
        const Ai = (1 + Math.sqrt(5)) / 2,
            gr = 1 / Ai,
            yu = [new E(1, 1, 1), new E(-1, 1, 1), new E(1, 1, -1), new E(-1, 1, -1), new E(0, Ai, gr), new E(0, Ai, -gr), new E(gr, 0, Ai), new E(-gr, 0, Ai), new E(Ai, gr, 0), new E(-Ai, gr, 0)];
        class Mu {
            constructor(e) {
                this._renderer = e, this._pingPongRenderTarget = null, this._blurMaterial = j0(mr), this._equirectShader = null, this._cubemapShader = null, this._compileMaterial(this._blurMaterial)
            }
            fromScene(e, t = 0, n = .1, i = 100) {
                Vo = this._renderer.getRenderTarget();
                const r = this._allocateTargets();
                return this._sceneToCubeUV(e, n, i, r), t > 0 && this._blur(r, 0, 0, t), this._applyPMREM(r), this._cleanup(r), r
            }
            fromEquirectangular(e) {
                return this._fromTexture(e)
            }
            fromCubemap(e) {
                return this._fromTexture(e)
            }
            compileCubemapShader() {
                this._cubemapShader === null && (this._cubemapShader = Su(), this._compileMaterial(this._cubemapShader))
            }
            compileEquirectangularShader() {
                this._equirectShader === null && (this._equirectShader = wu(), this._compileMaterial(this._equirectShader))
            }
            dispose() {
                this._blurMaterial.dispose(), this._cubemapShader !== null && this._cubemapShader.dispose(), this._equirectShader !== null && this._equirectShader.dispose();
                for (let e = 0; e < cs.length; e++) cs[e].dispose()
            }
            _cleanup(e) {
                this._pingPongRenderTarget.dispose(), this._renderer.setRenderTarget(Vo), e.scissorTest = !1, ba(e, 0, 0, e.width, e.height)
            }
            _fromTexture(e) {
                Vo = this._renderer.getRenderTarget();
                const t = this._allocateTargets(e);
                return this._textureToCubeUV(e, t), this._applyPMREM(t), this._cleanup(t), t
            }
            _allocateTargets(e) {
                const t = {
                        magFilter: st,
                        minFilter: st,
                        generateMipmaps: !1,
                        type: Un,
                        format: yp,
                        encoding: q0(e) ? e.encoding : ho,
                        depthBuffer: !1
                    },
                    n = bu(t);
                return n.depthBuffer = !e, this._pingPongRenderTarget = bu(t), n
            }
            _compileMaterial(e) {
                const t = new Ge(cs[0], e);
                this._renderer.compile(t, Ho)
            }
            _sceneToCubeUV(e, t, n, i) {
                const r = 90,
                    s = 1,
                    o = new yt(r, s, t, n),
                    l = [1, -1, 1, 1, 1, 1],
                    c = [1, 1, 1, -1, -1, -1],
                    u = this._renderer,
                    h = u.autoClear,
                    f = u.outputEncoding,
                    d = u.toneMapping;
                u.getClearColor(xu), u.toneMapping = xi, u.outputEncoding = vt, u.autoClear = !1;
                const m = new un({
                        name: "PMREM.Background",
                        side: nt,
                        depthWrite: !1,
                        depthTest: !1
                    }),
                    g = new Ge(new Yn, m);
                let v = !1;
                const p = e.background;
                p ? p.isColor && (m.color.copy(p), e.background = null, v = !0) : (m.color.copy(xu), v = !0);
                for (let _ = 0; _ < 6; _++) {
                    const M = _ % 3;
                    M == 0 ? (o.up.set(0, l[_], 0), o.lookAt(c[_], 0, 0)) : M == 1 ? (o.up.set(0, 0, l[_]), o.lookAt(0, c[_], 0)) : (o.up.set(0, l[_], 0), o.lookAt(0, 0, c[_])), ba(i, M * fn, _ > 2 ? fn : 0, fn, fn), u.setRenderTarget(i), v && u.render(g, o), u.render(e, o)
                }
                g.geometry.dispose(), g.material.dispose(), u.toneMapping = d, u.outputEncoding = f, u.autoClear = h, e.background = p
            }
            _setEncoding(e, t) {
                this._renderer.capabilities.isWebGL2 === !0 && t.format === ct && t.type === Un && t.encoding === Ot ? e.value = $n[vt] : e.value = $n[t.encoding]
            }
            _textureToCubeUV(e, t) {
                const n = this._renderer;
                e.isCubeTexture ? this._cubemapShader == null && (this._cubemapShader = Su()) : this._equirectShader == null && (this._equirectShader = wu());
                const i = e.isCubeTexture ? this._cubemapShader : this._equirectShader,
                    r = new Ge(cs[0], i),
                    s = i.uniforms;
                s.envMap.value = e, e.isCubeTexture || s.texelSize.value.set(1 / e.image.width, 1 / e.image.height), this._setEncoding(s.inputEncoding, e), this._setEncoding(s.outputEncoding, t.texture), ba(t, 0, 0, 3 * fn, 2 * fn), n.setRenderTarget(t), n.render(r, Ho)
            }
            _applyPMREM(e) {
                const t = this._renderer,
                    n = t.autoClear;
                t.autoClear = !1;
                for (let i = 1; i < _u; i++) {
                    const r = Math.sqrt(Ma[i] * Ma[i] - Ma[i - 1] * Ma[i - 1]),
                        s = yu[(i - 1) % yu.length];
                    this._blur(e, i - 1, i, r, s)
                }
                t.autoClear = n
            }
            _blur(e, t, n, i, r) {
                const s = this._pingPongRenderTarget;
                this._halfBlur(e, s, t, n, i, "latitudinal", r), this._halfBlur(s, e, n, n, i, "longitudinal", r)
            }
            _halfBlur(e, t, n, i, r, s, o) {
                const l = this._renderer,
                    c = this._blurMaterial;
                s !== "latitudinal" && s !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
                const u = 3,
                    h = new Ge(cs[i], c),
                    f = c.uniforms,
                    d = vu[n] - 1,
                    m = isFinite(r) ? Math.PI / (2 * d) : 2 * Math.PI / (2 * mr - 1),
                    g = r / m,
                    v = isFinite(r) ? 1 + Math.floor(u * g) : mr;
                v > mr && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${v} samples when the maximum is set to ${mr}`);
                const p = [];
                let _ = 0;
                for (let T = 0; T < mr; ++T) {
                    const x = T / g,
                        R = Math.exp(-x * x / 2);
                    p.push(R), T == 0 ? _ += R : T < v && (_ += 2 * R)
                }
                for (let T = 0; T < p.length; T++) p[T] = p[T] / _;
                f.envMap.value = e.texture, f.samples.value = v, f.weights.value = p, f.latitudinal.value = s === "latitudinal", o && (f.poleAxis.value = o), f.dTheta.value = m, f.mipInt.value = Jn - n, this._setEncoding(f.inputEncoding, e.texture), this._setEncoding(f.outputEncoding, e.texture);
                const M = vu[i],
                    y = 3 * Math.max(0, fn - 2 * M),
                    b = (i === 0 ? 0 : 2 * fn) + 2 * M * (i > Jn - pr ? i - Jn + pr : 0);
                ba(t, y, b, 3 * M, 2 * M), l.setRenderTarget(t), l.render(h, Ho)
            }
        }

        function q0(a) {
            return a === void 0 || a.type !== Un ? !1 : a.encoding === vt || a.encoding === Ot || a.encoding === uo
        }

        function X0() {
            const a = [],
                e = [],
                t = [];
            let n = Jn;
            for (let i = 0; i < _u; i++) {
                const r = Math.pow(2, n);
                e.push(r);
                let s = 1 / r;
                i > Jn - pr ? s = gu[i - Jn + pr - 1] : i == 0 && (s = 0), t.push(s);
                const o = 1 / (r - 1),
                    l = -o / 2,
                    c = 1 + o / 2,
                    u = [l, l, c, l, c, c, l, l, c, c, l, c],
                    h = 6,
                    f = 6,
                    d = 3,
                    m = 2,
                    g = 1,
                    v = new Float32Array(d * f * h),
                    p = new Float32Array(m * f * h),
                    _ = new Float32Array(g * f * h);
                for (let y = 0; y < h; y++) {
                    const b = y % 3 * 2 / 3 - 1,
                        T = y > 2 ? 0 : -1,
                        x = [b, T, 0, b + 2 / 3, T, 0, b + 2 / 3, T + 1, 0, b, T, 0, b + 2 / 3, T + 1, 0, b, T + 1, 0];
                    v.set(x, d * f * y), p.set(u, m * f * y);
                    const R = [y, y, y, y, y, y];
                    _.set(R, g * f * y)
                }
                const M = new ke;
                M.setAttribute("position", new Qe(v, d)), M.setAttribute("uv", new Qe(p, m)), M.setAttribute("faceIndex", new Qe(_, g)), a.push(M), n > pr && n--
            }
            return {
                _lodPlanes: a,
                _sizeLods: e,
                _sigmas: t
            }
        }

        function bu(a) {
            const e = new Dt(3 * fn, 3 * fn, a);
            return e.texture.mapping = Ys, e.texture.name = "PMREM.cubeUv", e.scissorTest = !0, e
        }

        function ba(a, e, t, n, i) {
            a.viewport.set(e, t, n, i), a.scissor.set(e, t, n, i)
        }

        function j0(a) {
            const e = new Float32Array(a),
                t = new E(0, 1, 0);
            return new An({
                name: "SphericalGaussianBlur",
                defines: {
                    n: a
                },
                uniforms: {
                    envMap: {
                        value: null
                    },
                    samples: {
                        value: 1
                    },
                    weights: {
                        value: e
                    },
                    latitudinal: {
                        value: !1
                    },
                    dTheta: {
                        value: 0
                    },
                    mipInt: {
                        value: 0
                    },
                    poleAxis: {
                        value: t
                    },
                    inputEncoding: {
                        value: $n[vt]
                    },
                    outputEncoding: {
                        value: $n[vt]
                    }
                },
                vertexShader: Wo(),
                fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			${qo()}

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,
                blending: On,
                depthTest: !1,
                depthWrite: !1
            })
        }

        function wu() {
            const a = new X(1, 1);
            return new An({
                name: "EquirectangularToCubeUV",
                uniforms: {
                    envMap: {
                        value: null
                    },
                    texelSize: {
                        value: a
                    },
                    inputEncoding: {
                        value: $n[vt]
                    },
                    outputEncoding: {
                        value: $n[vt]
                    }
                },
                vertexShader: Wo(),
                fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform vec2 texelSize;

			${qo()}

			#include <common>

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				vec2 f = fract( uv / texelSize - 0.5 );
				uv -= f * texelSize;
				vec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x += texelSize.x;
				vec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.y += texelSize.y;
				vec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x -= texelSize.x;
				vec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;

				vec3 tm = mix( tl, tr, f.x );
				vec3 bm = mix( bl, br, f.x );
				gl_FragColor.rgb = mix( tm, bm, f.y );

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,
                blending: On,
                depthTest: !1,
                depthWrite: !1
            })
        }

        function Su() {
            return new An({
                name: "CubemapToCubeUV",
                uniforms: {
                    envMap: {
                        value: null
                    },
                    inputEncoding: {
                        value: $n[vt]
                    },
                    outputEncoding: {
                        value: $n[vt]
                    }
                },
                vertexShader: Wo(),
                fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			${qo()}

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;
				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,
                blending: On,
                depthTest: !1,
                depthWrite: !1
            })
        }

        function Wo() {
            return `

		precision mediump float;
		precision mediump int;

		attribute vec3 position;
		attribute vec2 uv;
		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
        }

        function qo() {
            return `

		uniform int inputEncoding;
		uniform int outputEncoding;

		#include <encodings_pars_fragment>

		vec4 inputTexelToLinear( vec4 value ) {

			if ( inputEncoding == 0 ) {

				return value;

			} else if ( inputEncoding == 1 ) {

				return sRGBToLinear( value );

			} else if ( inputEncoding == 2 ) {

				return RGBEToLinear( value );

			} else if ( inputEncoding == 3 ) {

				return RGBMToLinear( value, 7.0 );

			} else if ( inputEncoding == 4 ) {

				return RGBMToLinear( value, 16.0 );

			} else if ( inputEncoding == 5 ) {

				return RGBDToLinear( value, 256.0 );

			} else {

				return GammaToLinear( value, 2.2 );

			}

		}

		vec4 linearToOutputTexel( vec4 value ) {

			if ( outputEncoding == 0 ) {

				return value;

			} else if ( outputEncoding == 1 ) {

				return LinearTosRGB( value );

			} else if ( outputEncoding == 2 ) {

				return LinearToRGBE( value );

			} else if ( outputEncoding == 3 ) {

				return LinearToRGBM( value, 7.0 );

			} else if ( outputEncoding == 4 ) {

				return LinearToRGBM( value, 16.0 );

			} else if ( outputEncoding == 5 ) {

				return LinearToRGBD( value, 256.0 );

			} else {

				return LinearToGamma( value, 2.2 );

			}

		}

		vec4 envMapTexelToLinear( vec4 color ) {

			return inputTexelToLinear( color );

		}
	`
        }

        function Y0(a) {
            let e = new WeakMap,
                t = null;

            function n(o) {
                if (o && o.isTexture && o.isRenderTargetTexture === !1) {
                    const l = o.mapping,
                        c = l === io || l === ro,
                        u = l === Xs || l === js;
                    if (c || u) {
                        if (e.has(o)) return e.get(o).texture; {
                            const h = o.image;
                            if (c && h && h.height > 0 || u && h && i(h)) {
                                const f = a.getRenderTarget();
                                t === null && (t = new Mu(a));
                                const d = c ? t.fromEquirectangular(o) : t.fromCubemap(o);
                                return e.set(o, d), a.setRenderTarget(f), o.addEventListener("dispose", r), d.texture
                            } else return null
                        }
                    }
                }
                return o
            }

            function i(o) {
                let l = 0;
                const c = 6;
                for (let u = 0; u < c; u++) o[u] !== void 0 && l++;
                return l === c
            }

            function r(o) {
                const l = o.target;
                l.removeEventListener("dispose", r);
                const c = e.get(l);
                c !== void 0 && (e.delete(l), c.dispose())
            }

            function s() {
                e = new WeakMap, t !== null && (t.dispose(), t = null)
            }
            return {
                get: n,
                dispose: s
            }
        }

        function Z0(a) {
            const e = {};

            function t(n) {
                if (e[n] !== void 0) return e[n];
                let i;
                switch (n) {
                    case "WEBGL_depth_texture":
                        i = a.getExtension("WEBGL_depth_texture") || a.getExtension("MOZ_WEBGL_depth_texture") || a.getExtension("WEBKIT_WEBGL_depth_texture");
                        break;
                    case "EXT_texture_filter_anisotropic":
                        i = a.getExtension("EXT_texture_filter_anisotropic") || a.getExtension("MOZ_EXT_texture_filter_anisotropic") || a.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                        break;
                    case "WEBGL_compressed_texture_s3tc":
                        i = a.getExtension("WEBGL_compressed_texture_s3tc") || a.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || a.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                        break;
                    case "WEBGL_compressed_texture_pvrtc":
                        i = a.getExtension("WEBGL_compressed_texture_pvrtc") || a.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                        break;
                    default:
                        i = a.getExtension(n)
                }
                return e[n] = i, i
            }
            return {
                has: function(n) {
                    return t(n) !== null
                },
                init: function(n) {
                    n.isWebGL2 ? t("EXT_color_buffer_float") : (t("WEBGL_depth_texture"), t("OES_texture_float"), t("OES_texture_half_float"), t("OES_texture_half_float_linear"), t("OES_standard_derivatives"), t("OES_element_index_uint"), t("OES_vertex_array_object"), t("ANGLE_instanced_arrays")), t("OES_texture_float_linear"), t("EXT_color_buffer_half_float")
                },
                get: function(n) {
                    const i = t(n);
                    return i === null && console.warn("THREE.WebGLRenderer: " + n + " extension not supported."), i
                }
            }
        }

        function J0(a, e, t, n) {
            const i = {},
                r = new WeakMap;

            function s(h) {
                const f = h.target;
                f.index !== null && e.remove(f.index);
                for (const m in f.attributes) e.remove(f.attributes[m]);
                f.removeEventListener("dispose", s), delete i[f.id];
                const d = r.get(f);
                d && (e.remove(d), r.delete(f)), n.releaseStatesOfGeometry(f), f.isInstancedBufferGeometry === !0 && delete f._maxInstanceCount, t.memory.geometries--
            }

            function o(h, f) {
                return i[f.id] === !0 || (f.addEventListener("dispose", s), i[f.id] = !0, t.memory.geometries++), f
            }

            function l(h) {
                const f = h.attributes;
                for (const m in f) e.update(f[m], 34962);
                const d = h.morphAttributes;
                for (const m in d) {
                    const g = d[m];
                    for (let v = 0, p = g.length; v < p; v++) e.update(g[v], 34962)
                }
            }

            function c(h) {
                const f = [],
                    d = h.index,
                    m = h.attributes.position;
                let g = 0;
                if (d !== null) {
                    const _ = d.array;
                    g = d.version;
                    for (let M = 0, y = _.length; M < y; M += 3) {
                        const b = _[M + 0],
                            T = _[M + 1],
                            x = _[M + 2];
                        f.push(b, T, T, x, x, b)
                    }
                } else {
                    const _ = m.array;
                    g = m.version;
                    for (let M = 0, y = _.length / 3 - 1; M < y; M += 3) {
                        const b = M + 0,
                            T = M + 1,
                            x = M + 2;
                        f.push(b, T, T, x, x, b)
                    }
                }
                const v = new(Kc(f) > 65535 ? fu : hu)(f, 1);
                v.version = g;
                const p = r.get(h);
                p && e.remove(p), r.set(h, v)
            }

            function u(h) {
                const f = r.get(h);
                if (f) {
                    const d = h.index;
                    d !== null && f.version < d.version && c(h)
                } else c(h);
                return r.get(h)
            }
            return {
                get: o,
                update: l,
                getWireframeAttribute: u
            }
        }

        function $0(a, e, t, n) {
            const i = n.isWebGL2;
            let r;

            function s(f) {
                r = f
            }
            let o, l;

            function c(f) {
                o = f.type, l = f.bytesPerElement
            }

            function u(f, d) {
                a.drawElements(r, d, o, f * l), t.update(d, r, 1)
            }

            function h(f, d, m) {
                if (m === 0) return;
                let g, v;
                if (i) g = a, v = "drawElementsInstanced";
                else if (g = e.get("ANGLE_instanced_arrays"), v = "drawElementsInstancedANGLE", g === null) {
                    console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                    return
                }
                g[v](r, d, o, f * l, m), t.update(d, r, m)
            }
            this.setMode = s, this.setIndex = c, this.render = u, this.renderInstances = h
        }

        function K0(a) {
            const e = {
                    geometries: 0,
                    textures: 0
                },
                t = {
                    frame: 0,
                    calls: 0,
                    triangles: 0,
                    points: 0,
                    lines: 0
                };

            function n(r, s, o) {
                switch (t.calls++, s) {
                    case 4:
                        t.triangles += o * (r / 3);
                        break;
                    case 1:
                        t.lines += o * (r / 2);
                        break;
                    case 3:
                        t.lines += o * (r - 1);
                        break;
                    case 2:
                        t.lines += o * r;
                        break;
                    case 0:
                        t.points += o * r;
                        break;
                    default:
                        console.error("THREE.WebGLInfo: Unknown draw mode:", s);
                        break
                }
            }

            function i() {
                t.frame++, t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0
            }
            return {
                memory: e,
                render: t,
                programs: null,
                autoReset: !0,
                reset: i,
                update: n
            }
        }
        class Xo extends at {
            constructor(e = null, t = 1, n = 1, i = 1) {
                super(null);
                this.image = {
                    data: e,
                    width: t,
                    height: n,
                    depth: i
                }, this.magFilter = st, this.minFilter = st, this.wrapR = Ct, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0
            }
        }
        Xo.prototype.isDataTexture2DArray = !0;

        function Q0(a, e) {
            return a[0] - e[0]
        }

        function e_(a, e) {
            return Math.abs(e[1]) - Math.abs(a[1])
        }

        function Tu(a, e) {
            let t = 1;
            const n = e.isInterleavedBufferAttribute ? e.data.array : e.array;
            n instanceof Int8Array ? t = 127 : n instanceof Int16Array ? t = 32767 : n instanceof Int32Array ? t = 2147483647 : console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ", n), a.divideScalar(t)
        }

        function t_(a, e, t) {
            const n = {},
                i = new Float32Array(8),
                r = new WeakMap,
                s = new E,
                o = [];
            for (let c = 0; c < 8; c++) o[c] = [c, 0];

            function l(c, u, h, f) {
                const d = c.morphTargetInfluences;
                if (e.isWebGL2 === !0) {
                    const m = u.morphAttributes.position.length;
                    let g = r.get(u);
                    if (g === void 0 || g.count !== m) {
                        g !== void 0 && g.texture.dispose();
                        const _ = u.morphAttributes.normal !== void 0,
                            M = u.morphAttributes.position,
                            y = u.morphAttributes.normal || [],
                            b = u.attributes.position.count,
                            T = _ === !0 ? 2 : 1;
                        let x = b * T,
                            R = 1;
                        x > e.maxTextureSize && (R = Math.ceil(x / e.maxTextureSize), x = e.maxTextureSize);
                        const P = new Float32Array(x * R * 4 * m),
                            I = new Xo(P, x, R, m);
                        I.format = ct, I.type = yn;
                        const L = T * 4;
                        for (let Y = 0; Y < m; Y++) {
                            const D = M[Y],
                                F = y[Y],
                                N = x * R * 4 * Y;
                            for (let z = 0; z < D.count; z++) {
                                s.fromBufferAttribute(D, z), D.normalized === !0 && Tu(s, D);
                                const k = z * L;
                                P[N + k + 0] = s.x, P[N + k + 1] = s.y, P[N + k + 2] = s.z, P[N + k + 3] = 0, _ === !0 && (s.fromBufferAttribute(F, z), F.normalized === !0 && Tu(s, F), P[N + k + 4] = s.x, P[N + k + 5] = s.y, P[N + k + 6] = s.z, P[N + k + 7] = 0)
                            }
                        }
                        g = {
                            count: m,
                            texture: I,
                            size: new X(x, R)
                        }, r.set(u, g)
                    }
                    let v = 0;
                    for (let _ = 0; _ < d.length; _++) v += d[_];
                    const p = u.morphTargetsRelative ? 1 : 1 - v;
                    f.getUniforms().setValue(a, "morphTargetBaseInfluence", p), f.getUniforms().setValue(a, "morphTargetInfluences", d), f.getUniforms().setValue(a, "morphTargetsTexture", g.texture, t), f.getUniforms().setValue(a, "morphTargetsTextureSize", g.size)
                } else {
                    const m = d === void 0 ? 0 : d.length;
                    let g = n[u.id];
                    if (g === void 0 || g.length !== m) {
                        g = [];
                        for (let y = 0; y < m; y++) g[y] = [y, 0];
                        n[u.id] = g
                    }
                    for (let y = 0; y < m; y++) {
                        const b = g[y];
                        b[0] = y, b[1] = d[y]
                    }
                    g.sort(e_);
                    for (let y = 0; y < 8; y++) y < m && g[y][1] ? (o[y][0] = g[y][0], o[y][1] = g[y][1]) : (o[y][0] = Number.MAX_SAFE_INTEGER, o[y][1] = 0);
                    o.sort(Q0);
                    const v = u.morphAttributes.position,
                        p = u.morphAttributes.normal;
                    let _ = 0;
                    for (let y = 0; y < 8; y++) {
                        const b = o[y],
                            T = b[0],
                            x = b[1];
                        T !== Number.MAX_SAFE_INTEGER && x ? (v && u.getAttribute("morphTarget" + y) !== v[T] && u.setAttribute("morphTarget" + y, v[T]), p && u.getAttribute("morphNormal" + y) !== p[T] && u.setAttribute("morphNormal" + y, p[T]), i[y] = x, _ += x) : (v && u.hasAttribute("morphTarget" + y) === !0 && u.deleteAttribute("morphTarget" + y), p && u.hasAttribute("morphNormal" + y) === !0 && u.deleteAttribute("morphNormal" + y), i[y] = 0)
                    }
                    const M = u.morphTargetsRelative ? 1 : 1 - _;
                    f.getUniforms().setValue(a, "morphTargetBaseInfluence", M), f.getUniforms().setValue(a, "morphTargetInfluences", i)
                }
            }
            return {
                update: l
            }
        }

        function n_(a, e, t, n) {
            let i = new WeakMap;

            function r(l) {
                const c = n.render.frame,
                    u = l.geometry,
                    h = e.get(l, u);
                return i.get(h) !== c && (e.update(h), i.set(h, c)), l.isInstancedMesh && (l.hasEventListener("dispose", o) === !1 && l.addEventListener("dispose", o), t.update(l.instanceMatrix, 34962), l.instanceColor !== null && t.update(l.instanceColor, 34962)), h
            }

            function s() {
                i = new WeakMap
            }

            function o(l) {
                const c = l.target;
                c.removeEventListener("dispose", o), t.remove(c.instanceMatrix), c.instanceColor !== null && t.remove(c.instanceColor)
            }
            return {
                update: r,
                dispose: s
            }
        }
        class Eu extends at {
            constructor(e = null, t = 1, n = 1, i = 1) {
                super(null);
                this.image = {
                    data: e,
                    width: t,
                    height: n,
                    depth: i
                }, this.magFilter = st, this.minFilter = st, this.wrapR = Ct, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0
            }
        }
        Eu.prototype.isDataTexture3D = !0;
        const Au = new at,
            i_ = new Xo,
            r_ = new Eu,
            Lu = new va,
            Ru = [],
            Cu = [],
            Pu = new Float32Array(16),
            Du = new Float32Array(9),
            Iu = new Float32Array(4);

        function _r(a, e, t) {
            const n = a[0];
            if (n <= 0 || n > 0) return a;
            const i = e * t;
            let r = Ru[i];
            if (r === void 0 && (r = new Float32Array(i), Ru[i] = r), e !== 0) {
                n.toArray(r, 0);
                for (let s = 1, o = 0; s !== e; ++s) o += t, a[s].toArray(r, o)
            }
            return r
        }

        function Lt(a, e) {
            if (a.length !== e.length) return !1;
            for (let t = 0, n = a.length; t < n; t++)
                if (a[t] !== e[t]) return !1;
            return !0
        }

        function Mt(a, e) {
            for (let t = 0, n = e.length; t < n; t++) a[t] = e[t]
        }

        function Fu(a, e) {
            let t = Cu[e];
            t === void 0 && (t = new Int32Array(e), Cu[e] = t);
            for (let n = 0; n !== e; ++n) t[n] = a.allocateTextureUnit();
            return t
        }

        function s_(a, e) {
            const t = this.cache;
            t[0] !== e && (a.uniform1f(this.addr, e), t[0] = e)
        }

        function a_(a, e) {
            const t = this.cache;
            if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y) && (a.uniform2f(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
            else {
                if (Lt(t, e)) return;
                a.uniform2fv(this.addr, e), Mt(t, e)
            }
        }

        function o_(a, e) {
            const t = this.cache;
            if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (a.uniform3f(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
            else if (e.r !== void 0)(t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (a.uniform3f(this.addr, e.r, e.g, e.b), t[0] = e.r, t[1] = e.g, t[2] = e.b);
            else {
                if (Lt(t, e)) return;
                a.uniform3fv(this.addr, e), Mt(t, e)
            }
        }

        function l_(a, e) {
            const t = this.cache;
            if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (a.uniform4f(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
            else {
                if (Lt(t, e)) return;
                a.uniform4fv(this.addr, e), Mt(t, e)
            }
        }

        function c_(a, e) {
            const t = this.cache,
                n = e.elements;
            if (n === void 0) {
                if (Lt(t, e)) return;
                a.uniformMatrix2fv(this.addr, !1, e), Mt(t, e)
            } else {
                if (Lt(t, n)) return;
                Iu.set(n), a.uniformMatrix2fv(this.addr, !1, Iu), Mt(t, n)
            }
        }

        function u_(a, e) {
            const t = this.cache,
                n = e.elements;
            if (n === void 0) {
                if (Lt(t, e)) return;
                a.uniformMatrix3fv(this.addr, !1, e), Mt(t, e)
            } else {
                if (Lt(t, n)) return;
                Du.set(n), a.uniformMatrix3fv(this.addr, !1, Du), Mt(t, n)
            }
        }

        function h_(a, e) {
            const t = this.cache,
                n = e.elements;
            if (n === void 0) {
                if (Lt(t, e)) return;
                a.uniformMatrix4fv(this.addr, !1, e), Mt(t, e)
            } else {
                if (Lt(t, n)) return;
                Pu.set(n), a.uniformMatrix4fv(this.addr, !1, Pu), Mt(t, n)
            }
        }

        function f_(a, e) {
            const t = this.cache;
            t[0] !== e && (a.uniform1i(this.addr, e), t[0] = e)
        }

        function d_(a, e) {
            const t = this.cache;
            Lt(t, e) || (a.uniform2iv(this.addr, e), Mt(t, e))
        }

        function p_(a, e) {
            const t = this.cache;
            Lt(t, e) || (a.uniform3iv(this.addr, e), Mt(t, e))
        }

        function m_(a, e) {
            const t = this.cache;
            Lt(t, e) || (a.uniform4iv(this.addr, e), Mt(t, e))
        }

        function g_(a, e) {
            const t = this.cache;
            t[0] !== e && (a.uniform1ui(this.addr, e), t[0] = e)
        }

        function __(a, e) {
            const t = this.cache;
            Lt(t, e) || (a.uniform2uiv(this.addr, e), Mt(t, e))
        }

        function v_(a, e) {
            const t = this.cache;
            Lt(t, e) || (a.uniform3uiv(this.addr, e), Mt(t, e))
        }

        function x_(a, e) {
            const t = this.cache;
            Lt(t, e) || (a.uniform4uiv(this.addr, e), Mt(t, e))
        }

        function y_(a, e, t) {
            const n = this.cache,
                i = t.allocateTextureUnit();
            n[0] !== i && (a.uniform1i(this.addr, i), n[0] = i), t.safeSetTexture2D(e || Au, i)
        }

        function M_(a, e, t) {
            const n = this.cache,
                i = t.allocateTextureUnit();
            n[0] !== i && (a.uniform1i(this.addr, i), n[0] = i), t.setTexture3D(e || r_, i)
        }

        function b_(a, e, t) {
            const n = this.cache,
                i = t.allocateTextureUnit();
            n[0] !== i && (a.uniform1i(this.addr, i), n[0] = i), t.safeSetTextureCube(e || Lu, i)
        }

        function w_(a, e, t) {
            const n = this.cache,
                i = t.allocateTextureUnit();
            n[0] !== i && (a.uniform1i(this.addr, i), n[0] = i), t.setTexture2DArray(e || i_, i)
        }

        function S_(a) {
            switch (a) {
                case 5126:
                    return s_;
                case 35664:
                    return a_;
                case 35665:
                    return o_;
                case 35666:
                    return l_;
                case 35674:
                    return c_;
                case 35675:
                    return u_;
                case 35676:
                    return h_;
                case 5124:
                case 35670:
                    return f_;
                case 35667:
                case 35671:
                    return d_;
                case 35668:
                case 35672:
                    return p_;
                case 35669:
                case 35673:
                    return m_;
                case 5125:
                    return g_;
                case 36294:
                    return __;
                case 36295:
                    return v_;
                case 36296:
                    return x_;
                case 35678:
                case 36198:
                case 36298:
                case 36306:
                case 35682:
                    return y_;
                case 35679:
                case 36299:
                case 36307:
                    return M_;
                case 35680:
                case 36300:
                case 36308:
                case 36293:
                    return b_;
                case 36289:
                case 36303:
                case 36311:
                case 36292:
                    return w_
            }
        }

        function T_(a, e) {
            a.uniform1fv(this.addr, e)
        }

        function E_(a, e) {
            const t = _r(e, this.size, 2);
            a.uniform2fv(this.addr, t)
        }

        function A_(a, e) {
            const t = _r(e, this.size, 3);
            a.uniform3fv(this.addr, t)
        }

        function L_(a, e) {
            const t = _r(e, this.size, 4);
            a.uniform4fv(this.addr, t)
        }

        function R_(a, e) {
            const t = _r(e, this.size, 4);
            a.uniformMatrix2fv(this.addr, !1, t)
        }

        function C_(a, e) {
            const t = _r(e, this.size, 9);
            a.uniformMatrix3fv(this.addr, !1, t)
        }

        function P_(a, e) {
            const t = _r(e, this.size, 16);
            a.uniformMatrix4fv(this.addr, !1, t)
        }

        function D_(a, e) {
            a.uniform1iv(this.addr, e)
        }

        function I_(a, e) {
            a.uniform2iv(this.addr, e)
        }

        function F_(a, e) {
            a.uniform3iv(this.addr, e)
        }

        function z_(a, e) {
            a.uniform4iv(this.addr, e)
        }

        function N_(a, e) {
            a.uniform1uiv(this.addr, e)
        }

        function B_(a, e) {
            a.uniform2uiv(this.addr, e)
        }

        function O_(a, e) {
            a.uniform3uiv(this.addr, e)
        }

        function U_(a, e) {
            a.uniform4uiv(this.addr, e)
        }

        function k_(a, e, t) {
            const n = e.length,
                i = Fu(t, n);
            a.uniform1iv(this.addr, i);
            for (let r = 0; r !== n; ++r) t.safeSetTexture2D(e[r] || Au, i[r])
        }

        function G_(a, e, t) {
            const n = e.length,
                i = Fu(t, n);
            a.uniform1iv(this.addr, i);
            for (let r = 0; r !== n; ++r) t.safeSetTextureCube(e[r] || Lu, i[r])
        }

        function H_(a) {
            switch (a) {
                case 5126:
                    return T_;
                case 35664:
                    return E_;
                case 35665:
                    return A_;
                case 35666:
                    return L_;
                case 35674:
                    return R_;
                case 35675:
                    return C_;
                case 35676:
                    return P_;
                case 5124:
                case 35670:
                    return D_;
                case 35667:
                case 35671:
                    return I_;
                case 35668:
                case 35672:
                    return F_;
                case 35669:
                case 35673:
                    return z_;
                case 5125:
                    return N_;
                case 36294:
                    return B_;
                case 36295:
                    return O_;
                case 36296:
                    return U_;
                case 35678:
                case 36198:
                case 36298:
                case 36306:
                case 35682:
                    return k_;
                case 35680:
                case 36300:
                case 36308:
                case 36293:
                    return G_
            }
        }

        function V_(a, e, t) {
            this.id = a, this.addr = t, this.cache = [], this.setValue = S_(e.type)
        }

        function zu(a, e, t) {
            this.id = a, this.addr = t, this.cache = [], this.size = e.size, this.setValue = H_(e.type)
        }
        zu.prototype.updateCache = function(a) {
            const e = this.cache;
            a instanceof Float32Array && e.length !== a.length && (this.cache = new Float32Array(a.length)), Mt(e, a)
        };

        function Nu(a) {
            this.id = a, this.seq = [], this.map = {}
        }
        Nu.prototype.setValue = function(a, e, t) {
            const n = this.seq;
            for (let i = 0, r = n.length; i !== r; ++i) {
                const s = n[i];
                s.setValue(a, e[s.id], t)
            }
        };
        const jo = /(\w+)(\])?(\[|\.)?/g;

        function Bu(a, e) {
            a.seq.push(e), a.map[e.id] = e
        }

        function W_(a, e, t) {
            const n = a.name,
                i = n.length;
            for (jo.lastIndex = 0;;) {
                const r = jo.exec(n),
                    s = jo.lastIndex;
                let o = r[1];
                const l = r[2] === "]",
                    c = r[3];
                if (l && (o = o | 0), c === void 0 || c === "[" && s + 2 === i) {
                    Bu(t, c === void 0 ? new V_(o, a, e) : new zu(o, a, e));
                    break
                } else {
                    let h = t.map[o];
                    h === void 0 && (h = new Nu(o), Bu(t, h)), t = h
                }
            }
        }

        function Kn(a, e) {
            this.seq = [], this.map = {};
            const t = a.getProgramParameter(e, 35718);
            for (let n = 0; n < t; ++n) {
                const i = a.getActiveUniform(e, n),
                    r = a.getUniformLocation(e, i.name);
                W_(i, r, this)
            }
        }
        Kn.prototype.setValue = function(a, e, t, n) {
            const i = this.map[e];
            i !== void 0 && i.setValue(a, t, n)
        }, Kn.prototype.setOptional = function(a, e, t) {
            const n = e[t];
            n !== void 0 && this.setValue(a, t, n)
        }, Kn.upload = function(a, e, t, n) {
            for (let i = 0, r = e.length; i !== r; ++i) {
                const s = e[i],
                    o = t[s.id];
                o.needsUpdate !== !1 && s.setValue(a, o.value, n)
            }
        }, Kn.seqWithValue = function(a, e) {
            const t = [];
            for (let n = 0, i = a.length; n !== i; ++n) {
                const r = a[n];
                r.id in e && t.push(r)
            }
            return t
        };

        function Ou(a, e, t) {
            const n = a.createShader(e);
            return a.shaderSource(n, t), a.compileShader(n), n
        }
        let q_ = 0;

        function X_(a) {
            const e = a.split(`
`);
            for (let t = 0; t < e.length; t++) e[t] = t + 1 + ": " + e[t];
            return e.join(`
`)
        }

        function Uu(a) {
            switch (a) {
                case vt:
                    return ["Linear", "( value )"];
                case Ot:
                    return ["sRGB", "( value )"];
                case ho:
                    return ["RGBE", "( value )"];
                case Xc:
                    return ["RGBM", "( value, 7.0 )"];
                case jc:
                    return ["RGBM", "( value, 16.0 )"];
                case Yc:
                    return ["RGBD", "( value, 256.0 )"];
                case uo:
                    return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
                case lm:
                    return ["LogLuv", "( value )"];
                default:
                    return console.warn("THREE.WebGLProgram: Unsupported encoding:", a), ["Linear", "( value )"]
            }
        }

        function ku(a, e, t) {
            const n = a.getShaderParameter(e, 35713),
                i = a.getShaderInfoLog(e).trim();
            return n && i === "" ? "" : t.toUpperCase() + `

` + i + `

` + X_(a.getShaderSource(e))
        }

        function vr(a, e) {
            const t = Uu(e);
            return "vec4 " + a + "( vec4 value ) { return " + t[0] + "ToLinear" + t[1] + "; }"
        }

        function j_(a, e) {
            const t = Uu(e);
            return "vec4 " + a + "( vec4 value ) { return LinearTo" + t[0] + t[1] + "; }"
        }

        function Y_(a, e) {
            let t;
            switch (e) {
                case op:
                    t = "Linear";
                    break;
                case lp:
                    t = "Reinhard";
                    break;
                case cp:
                    t = "OptimizedCineon";
                    break;
                case Pc:
                    t = "ACESFilmic";
                    break;
                case up:
                    t = "Custom";
                    break;
                default:
                    console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), t = "Linear"
            }
            return "vec3 " + a + "( vec3 color ) { return " + t + "ToneMapping( color ); }"
        }

        function Z_(a) {
            return [a.extensionDerivatives || a.envMapCubeUV || a.bumpMap || a.tangentSpaceNormalMap || a.clearcoatNormalMap || a.flatShading || a.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "", (a.extensionFragDepth || a.logarithmicDepthBuffer) && a.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", a.extensionDrawBuffers && a.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (a.extensionShaderTextureLOD || a.envMap || a.transmission) && a.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(us).join(`
`)
        }

        function J_(a) {
            const e = [];
            for (const t in a) {
                const n = a[t];
                n !== !1 && e.push("#define " + t + " " + n)
            }
            return e.join(`
`)
        }

        function $_(a, e) {
            const t = {},
                n = a.getProgramParameter(e, 35721);
            for (let i = 0; i < n; i++) {
                const r = a.getActiveAttrib(e, i),
                    s = r.name;
                let o = 1;
                r.type === 35674 && (o = 2), r.type === 35675 && (o = 3), r.type === 35676 && (o = 4), t[s] = {
                    type: r.type,
                    location: a.getAttribLocation(e, s),
                    locationSize: o
                }
            }
            return t
        }

        function us(a) {
            return a !== ""
        }

        function Gu(a, e) {
            return a.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
        }

        function Hu(a, e) {
            return a.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
        }
        const K_ = /^[ \t]*#include +<([\w\d./]+)>/gm;

        function Yo(a) {
            return a.replace(K_, Q_)
        }

        function Q_(a, e) {
            const t = Re[e];
            if (t === void 0) throw new Error("Can not resolve #include <" + e + ">");
            return Yo(t)
        }
        const ev = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
            tv = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

        function Vu(a) {
            return a.replace(tv, Wu).replace(ev, nv)
        }

        function nv(a, e, t, n) {
            return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), Wu(a, e, t, n)
        }

        function Wu(a, e, t, n) {
            let i = "";
            for (let r = parseInt(e); r < parseInt(t); r++) i += n.replace(/\[\s*i\s*\]/g, "[ " + r + " ]").replace(/UNROLLED_LOOP_INDEX/g, r);
            return i
        }

        function qu(a) {
            let e = "precision " + a.precision + ` float;
precision ` + a.precision + " int;";
            return a.precision === "highp" ? e += `
#define HIGH_PRECISION` : a.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : a.precision === "lowp" && (e += `
#define LOW_PRECISION`), e
        }

        function iv(a) {
            let e = "SHADOWMAP_TYPE_BASIC";
            return a.shadowMapType === wc ? e = "SHADOWMAP_TYPE_PCF" : a.shadowMapType === Ud ? e = "SHADOWMAP_TYPE_PCF_SOFT" : a.shadowMapType === Zr && (e = "SHADOWMAP_TYPE_VSM"), e
        }

        function rv(a) {
            let e = "ENVMAP_TYPE_CUBE";
            if (a.envMap) switch (a.envMapMode) {
                case Xs:
                case js:
                    e = "ENVMAP_TYPE_CUBE";
                    break;
                case Ys:
                case so:
                    e = "ENVMAP_TYPE_CUBE_UV";
                    break
            }
            return e
        }

        function sv(a) {
            let e = "ENVMAP_MODE_REFLECTION";
            if (a.envMap) switch (a.envMapMode) {
                case js:
                case so:
                    e = "ENVMAP_MODE_REFRACTION";
                    break
            }
            return e
        }

        function av(a) {
            let e = "ENVMAP_BLENDING_NONE";
            if (a.envMap) switch (a.combine) {
                case qs:
                    e = "ENVMAP_BLENDING_MULTIPLY";
                    break;
                case sp:
                    e = "ENVMAP_BLENDING_MIX";
                    break;
                case ap:
                    e = "ENVMAP_BLENDING_ADD";
                    break
            }
            return e
        }

        function ov(a, e, t, n) {
            const i = a.getContext(),
                r = t.defines;
            let s = t.vertexShader,
                o = t.fragmentShader;
            const l = iv(t),
                c = rv(t),
                u = sv(t),
                h = av(t),
                f = a.gammaFactor > 0 ? a.gammaFactor : 1,
                d = t.isWebGL2 ? "" : Z_(t),
                m = J_(r),
                g = i.createProgram();
            let v, p, _ = t.glslVersion ? "#version " + t.glslVersion + `
` : "";
            t.isRawShaderMaterial ? (v = [m].filter(us).join(`
`), v.length > 0 && (v += `
`), p = [d, m].filter(us).join(`
`), p.length > 0 && (p += `
`)) : (v = [qu(t), "#define SHADER_NAME " + t.shaderName, m, t.instancing ? "#define USE_INSTANCING" : "", t.instancingColor ? "#define USE_INSTANCING_COLOR" : "", t.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + f, "#define MAX_BONES " + t.maxBones, t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.map ? "#define USE_MAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + u : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMap && t.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", t.normalMap && t.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.displacementMap && t.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", t.specularTintMap ? "#define USE_SPECULARTINTMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.vertexTangents ? "#define USE_TANGENT" : "", t.vertexColors ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUvs ? "#define USE_UV" : "", t.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.skinning ? "#define USE_SKINNING" : "", t.useVertexTexture ? "#define BONE_TEXTURE" : "", t.morphTargets ? "#define USE_MORPHTARGETS" : "", t.morphNormals && t.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", t.morphTargets && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", t.morphTargets && t.isWebGL2 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + l : "", t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", `
`].filter(us).join(`
`), p = [d, qu(t), "#define SHADER_NAME " + t.shaderName, m, "#define GAMMA_FACTOR " + f, t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.map ? "#define USE_MAP" : "", t.matcap ? "#define USE_MATCAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + c : "", t.envMap ? "#define " + u : "", t.envMap ? "#define " + h : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMap && t.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", t.normalMap && t.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", t.clearcoat ? "#define USE_CLEARCOAT" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", t.specularTintMap ? "#define USE_SPECULARTINTMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaTest ? "#define USE_ALPHATEST" : "", t.sheen ? "#define USE_SHEEN" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.vertexTangents ? "#define USE_TANGENT" : "", t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUvs ? "#define USE_UV" : "", t.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", t.gradientMap ? "#define USE_GRADIENTMAP" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + l : "", t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", t.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (t.extensionShaderTextureLOD || t.envMap) && t.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", t.toneMapping !== xi ? "#define TONE_MAPPING" : "", t.toneMapping !== xi ? Re.tonemapping_pars_fragment : "", t.toneMapping !== xi ? Y_("toneMapping", t.toneMapping) : "", t.dithering ? "#define DITHERING" : "", t.format === yi ? "#define OPAQUE" : "", Re.encodings_pars_fragment, t.map ? vr("mapTexelToLinear", t.mapEncoding) : "", t.matcap ? vr("matcapTexelToLinear", t.matcapEncoding) : "", t.envMap ? vr("envMapTexelToLinear", t.envMapEncoding) : "", t.emissiveMap ? vr("emissiveMapTexelToLinear", t.emissiveMapEncoding) : "", t.specularTintMap ? vr("specularTintMapTexelToLinear", t.specularTintMapEncoding) : "", t.lightMap ? vr("lightMapTexelToLinear", t.lightMapEncoding) : "", j_("linearToOutputTexel", t.outputEncoding), t.depthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "", `
`].filter(us).join(`
`)), s = Yo(s), s = Gu(s, t), s = Hu(s, t), o = Yo(o), o = Gu(o, t), o = Hu(o, t), s = Vu(s), o = Vu(o), t.isWebGL2 && t.isRawShaderMaterial !== !0 && (_ = `#version 300 es
`, v = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) + `
` + v, p = ["#define varying in", t.glslVersion === Zc ? "" : "out highp vec4 pc_fragColor;", t.glslVersion === Zc ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join(`
`) + `
` + p);
            const M = _ + v + s,
                y = _ + p + o,
                b = Ou(i, 35633, M),
                T = Ou(i, 35632, y);
            if (i.attachShader(g, b), i.attachShader(g, T), t.index0AttributeName !== void 0 ? i.bindAttribLocation(g, 0, t.index0AttributeName) : t.morphTargets === !0 && i.bindAttribLocation(g, 0, "position"), i.linkProgram(g), a.debug.checkShaderErrors) {
                const P = i.getProgramInfoLog(g).trim(),
                    I = i.getShaderInfoLog(b).trim(),
                    L = i.getShaderInfoLog(T).trim();
                let Y = !0,
                    D = !0;
                if (i.getProgramParameter(g, 35714) === !1) {
                    Y = !1;
                    const F = ku(i, b, "vertex"),
                        N = ku(i, T, "fragment");
                    console.error("THREE.WebGLProgram: Shader Error " + i.getError() + " - VALIDATE_STATUS " + i.getProgramParameter(g, 35715) + `

Program Info Log: ` + P + `
` + F + `
` + N)
                } else P !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", P) : (I === "" || L === "") && (D = !1);
                D && (this.diagnostics = {
                    runnable: Y,
                    programLog: P,
                    vertexShader: {
                        log: I,
                        prefix: v
                    },
                    fragmentShader: {
                        log: L,
                        prefix: p
                    }
                })
            }
            i.deleteShader(b), i.deleteShader(T);
            let x;
            this.getUniforms = function() {
                return x === void 0 && (x = new Kn(i, g)), x
            };
            let R;
            return this.getAttributes = function() {
                return R === void 0 && (R = $_(i, g)), R
            }, this.destroy = function() {
                n.releaseStatesOfProgram(this), i.deleteProgram(g), this.program = void 0
            }, this.name = t.shaderName, this.id = q_++, this.cacheKey = e, this.usedTimes = 1, this.program = g, this.vertexShader = b, this.fragmentShader = T, this
        }

        function lv(a, e, t, n, i, r, s) {
            const o = [],
                l = i.isWebGL2,
                c = i.logarithmicDepthBuffer,
                u = i.floatVertexTextures,
                h = i.maxVertexUniforms,
                f = i.vertexTextures;
            let d = i.precision;
            const m = {
                    MeshDepthMaterial: "depth",
                    MeshDistanceMaterial: "distanceRGBA",
                    MeshNormalMaterial: "normal",
                    MeshBasicMaterial: "basic",
                    MeshLambertMaterial: "lambert",
                    MeshPhongMaterial: "phong",
                    MeshToonMaterial: "toon",
                    MeshStandardMaterial: "physical",
                    MeshPhysicalMaterial: "physical",
                    MeshMatcapMaterial: "matcap",
                    LineBasicMaterial: "basic",
                    LineDashedMaterial: "dashed",
                    PointsMaterial: "points",
                    ShadowMaterial: "shadow",
                    SpriteMaterial: "sprite"
                },
                g = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "instancingColor", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoat", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap", "specularIntensityMap", "specularTintMap", "specularTintMapEncoding", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "alphaTest", "combine", "vertexColors", "vertexAlphas", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "morphTargetsCount", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "format", "sheen", "transmission", "transmissionMap", "thicknessMap"];

            function v(x) {
                const P = x.skeleton.bones;
                if (u) return 1024; {
                    const L = Math.floor((h - 20) / 4),
                        Y = Math.min(L, P.length);
                    return Y < P.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + P.length + " bones. This GPU supports " + Y + "."), 0) : Y
                }
            }

            function p(x) {
                let R;
                return x && x.isTexture ? R = x.encoding : x && x.isWebGLRenderTarget ? (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), R = x.texture.encoding) : R = vt, l && x && x.isTexture && x.format === ct && x.type === Un && x.encoding === Ot && (R = vt), R
            }

            function _(x, R, P, I, L) {
                const Y = I.fog,
                    D = x.isMeshStandardMaterial ? I.environment : null,
                    F = (x.isMeshStandardMaterial ? t : e).get(x.envMap || D),
                    N = m[x.type],
                    z = L.isSkinnedMesh ? v(L) : 0;
                x.precision !== null && (d = i.getMaxPrecision(x.precision), d !== x.precision && console.warn("THREE.WebGLProgram.getParameters:", x.precision, "not supported, using", d, "instead."));
                let k, J;
                if (N) {
                    const W = hn[N];
                    k = W.vertexShader, J = W.fragmentShader
                } else k = x.vertexShader, J = x.fragmentShader;
                const oe = a.getRenderTarget(),
                    he = x.alphaTest > 0,
                    ie = x.clearcoat > 0;
                return {
                    isWebGL2: l,
                    shaderID: N,
                    shaderName: x.type,
                    vertexShader: k,
                    fragmentShader: J,
                    defines: x.defines,
                    isRawShaderMaterial: x.isRawShaderMaterial === !0,
                    glslVersion: x.glslVersion,
                    precision: d,
                    instancing: L.isInstancedMesh === !0,
                    instancingColor: L.isInstancedMesh === !0 && L.instanceColor !== null,
                    supportsVertexTextures: f,
                    outputEncoding: oe !== null ? p(oe.texture) : a.outputEncoding,
                    map: !!x.map,
                    mapEncoding: p(x.map),
                    matcap: !!x.matcap,
                    matcapEncoding: p(x.matcap),
                    envMap: !!F,
                    envMapMode: F && F.mapping,
                    envMapEncoding: p(F),
                    envMapCubeUV: !!F && (F.mapping === Ys || F.mapping === so),
                    lightMap: !!x.lightMap,
                    lightMapEncoding: p(x.lightMap),
                    aoMap: !!x.aoMap,
                    emissiveMap: !!x.emissiveMap,
                    emissiveMapEncoding: p(x.emissiveMap),
                    bumpMap: !!x.bumpMap,
                    normalMap: !!x.normalMap,
                    objectSpaceNormalMap: x.normalMapType === hm,
                    tangentSpaceNormalMap: x.normalMapType === kn,
                    clearcoat: ie,
                    clearcoatMap: ie && !!x.clearcoatMap,
                    clearcoatRoughnessMap: ie && !!x.clearcoatRoughnessMap,
                    clearcoatNormalMap: ie && !!x.clearcoatNormalMap,
                    displacementMap: !!x.displacementMap,
                    roughnessMap: !!x.roughnessMap,
                    metalnessMap: !!x.metalnessMap,
                    specularMap: !!x.specularMap,
                    specularIntensityMap: !!x.specularIntensityMap,
                    specularTintMap: !!x.specularTintMap,
                    specularTintMapEncoding: p(x.specularTintMap),
                    alphaMap: !!x.alphaMap,
                    alphaTest: he,
                    gradientMap: !!x.gradientMap,
                    sheen: x.sheen > 0,
                    transmission: x.transmission > 0,
                    transmissionMap: !!x.transmissionMap,
                    thicknessMap: !!x.thicknessMap,
                    combine: x.combine,
                    vertexTangents: !!x.normalMap && !!L.geometry && !!L.geometry.attributes.tangent,
                    vertexColors: x.vertexColors,
                    vertexAlphas: x.vertexColors === !0 && !!L.geometry && !!L.geometry.attributes.color && L.geometry.attributes.color.itemSize === 4,
                    vertexUvs: !!x.map || !!x.bumpMap || !!x.normalMap || !!x.specularMap || !!x.alphaMap || !!x.emissiveMap || !!x.roughnessMap || !!x.metalnessMap || !!x.clearcoatMap || !!x.clearcoatRoughnessMap || !!x.clearcoatNormalMap || !!x.displacementMap || !!x.transmissionMap || !!x.thicknessMap || !!x.specularIntensityMap || !!x.specularTintMap,
                    uvsVertexOnly: !(!!x.map || !!x.bumpMap || !!x.normalMap || !!x.specularMap || !!x.alphaMap || !!x.emissiveMap || !!x.roughnessMap || !!x.metalnessMap || !!x.clearcoatNormalMap || x.transmission > 0 || !!x.transmissionMap || !!x.thicknessMap || !!x.specularIntensityMap || !!x.specularTintMap) && !!x.displacementMap,
                    fog: !!Y,
                    useFog: x.fog,
                    fogExp2: Y && Y.isFogExp2,
                    flatShading: !!x.flatShading,
                    sizeAttenuation: x.sizeAttenuation,
                    logarithmicDepthBuffer: c,
                    skinning: L.isSkinnedMesh === !0 && z > 0,
                    maxBones: z,
                    useVertexTexture: u,
                    morphTargets: !!L.geometry && !!L.geometry.morphAttributes.position,
                    morphNormals: !!L.geometry && !!L.geometry.morphAttributes.normal,
                    morphTargetsCount: !!L.geometry && !!L.geometry.morphAttributes.position ? L.geometry.morphAttributes.position.length : 0,
                    numDirLights: R.directional.length,
                    numPointLights: R.point.length,
                    numSpotLights: R.spot.length,
                    numRectAreaLights: R.rectArea.length,
                    numHemiLights: R.hemi.length,
                    numDirLightShadows: R.directionalShadowMap.length,
                    numPointLightShadows: R.pointShadowMap.length,
                    numSpotLightShadows: R.spotShadowMap.length,
                    numClippingPlanes: s.numPlanes,
                    numClipIntersection: s.numIntersection,
                    format: x.format,
                    dithering: x.dithering,
                    shadowMapEnabled: a.shadowMap.enabled && P.length > 0,
                    shadowMapType: a.shadowMap.type,
                    toneMapping: x.toneMapped ? a.toneMapping : xi,
                    physicallyCorrectLights: a.physicallyCorrectLights,
                    premultipliedAlpha: x.premultipliedAlpha,
                    doubleSided: x.side === vi,
                    flipSided: x.side === nt,
                    depthPacking: x.depthPacking !== void 0 ? x.depthPacking : !1,
                    index0AttributeName: x.index0AttributeName,
                    extensionDerivatives: x.extensions && x.extensions.derivatives,
                    extensionFragDepth: x.extensions && x.extensions.fragDepth,
                    extensionDrawBuffers: x.extensions && x.extensions.drawBuffers,
                    extensionShaderTextureLOD: x.extensions && x.extensions.shaderTextureLOD,
                    rendererExtensionFragDepth: l || n.has("EXT_frag_depth"),
                    rendererExtensionDrawBuffers: l || n.has("WEBGL_draw_buffers"),
                    rendererExtensionShaderTextureLod: l || n.has("EXT_shader_texture_lod"),
                    customProgramCacheKey: x.customProgramCacheKey()
                }
            }

            function M(x) {
                const R = [];
                if (x.shaderID ? R.push(x.shaderID) : (R.push(x.fragmentShader), R.push(x.vertexShader)), x.defines !== void 0)
                    for (const P in x.defines) R.push(P), R.push(x.defines[P]);
                if (x.isRawShaderMaterial === !1) {
                    for (let P = 0; P < g.length; P++) R.push(x[g[P]]);
                    R.push(a.outputEncoding), R.push(a.gammaFactor)
                }
                return R.push(x.customProgramCacheKey), R.join()
            }

            function y(x) {
                const R = m[x.type];
                let P;
                if (R) {
                    const I = hn[R];
                    P = ls.clone(I.uniforms)
                } else P = x.uniforms;
                return P
            }

            function b(x, R) {
                let P;
                for (let I = 0, L = o.length; I < L; I++) {
                    const Y = o[I];
                    if (Y.cacheKey === R) {
                        P = Y, ++P.usedTimes;
                        break
                    }
                }
                return P === void 0 && (P = new ov(a, R, x, r), o.push(P)), P
            }

            function T(x) {
                if (--x.usedTimes == 0) {
                    const R = o.indexOf(x);
                    o[R] = o[o.length - 1], o.pop(), x.destroy()
                }
            }
            return {
                getParameters: _,
                getProgramCacheKey: M,
                getUniforms: y,
                acquireProgram: b,
                releaseProgram: T,
                programs: o
            }
        }

        function cv() {
            let a = new WeakMap;

            function e(r) {
                let s = a.get(r);
                return s === void 0 && (s = {}, a.set(r, s)), s
            }

            function t(r) {
                a.delete(r)
            }

            function n(r, s, o) {
                a.get(r)[s] = o
            }

            function i() {
                a = new WeakMap
            }
            return {
                get: e,
                remove: t,
                update: n,
                dispose: i
            }
        }

        function uv(a, e) {
            return a.groupOrder !== e.groupOrder ? a.groupOrder - e.groupOrder : a.renderOrder !== e.renderOrder ? a.renderOrder - e.renderOrder : a.program !== e.program ? a.program.id - e.program.id : a.material.id !== e.material.id ? a.material.id - e.material.id : a.z !== e.z ? a.z - e.z : a.id - e.id
        }

        function Xu(a, e) {
            return a.groupOrder !== e.groupOrder ? a.groupOrder - e.groupOrder : a.renderOrder !== e.renderOrder ? a.renderOrder - e.renderOrder : a.z !== e.z ? e.z - a.z : a.id - e.id
        }

        function ju(a) {
            const e = [];
            let t = 0;
            const n = [],
                i = [],
                r = [],
                s = {
                    id: -1
                };

            function o() {
                t = 0, n.length = 0, i.length = 0, r.length = 0
            }

            function l(d, m, g, v, p, _) {
                let M = e[t];
                const y = a.get(g);
                return M === void 0 ? (M = {
                    id: d.id,
                    object: d,
                    geometry: m,
                    material: g,
                    program: y.program || s,
                    groupOrder: v,
                    renderOrder: d.renderOrder,
                    z: p,
                    group: _
                }, e[t] = M) : (M.id = d.id, M.object = d, M.geometry = m, M.material = g, M.program = y.program || s, M.groupOrder = v, M.renderOrder = d.renderOrder, M.z = p, M.group = _), t++, M
            }

            function c(d, m, g, v, p, _) {
                const M = l(d, m, g, v, p, _);
                g.transmission > 0 ? i.push(M) : g.transparent === !0 ? r.push(M) : n.push(M)
            }

            function u(d, m, g, v, p, _) {
                const M = l(d, m, g, v, p, _);
                g.transmission > 0 ? i.unshift(M) : g.transparent === !0 ? r.unshift(M) : n.unshift(M)
            }

            function h(d, m) {
                n.length > 1 && n.sort(d || uv), i.length > 1 && i.sort(m || Xu), r.length > 1 && r.sort(m || Xu)
            }

            function f() {
                for (let d = t, m = e.length; d < m; d++) {
                    const g = e[d];
                    if (g.id === null) break;
                    g.id = null, g.object = null, g.geometry = null, g.material = null, g.program = null, g.group = null
                }
            }
            return {
                opaque: n,
                transmissive: i,
                transparent: r,
                init: o,
                push: c,
                unshift: u,
                finish: f,
                sort: h
            }
        }

        function hv(a) {
            let e = new WeakMap;

            function t(i, r) {
                let s;
                return e.has(i) === !1 ? (s = new ju(a), e.set(i, [s])) : r >= e.get(i).length ? (s = new ju(a), e.get(i).push(s)) : s = e.get(i)[r], s
            }

            function n() {
                e = new WeakMap
            }
            return {
                get: t,
                dispose: n
            }
        }

        function fv() {
            const a = {};
            return {
                get: function(e) {
                    if (a[e.id] !== void 0) return a[e.id];
                    let t;
                    switch (e.type) {
                        case "DirectionalLight":
                            t = {
                                direction: new E,
                                color: new ne
                            };
                            break;
                        case "SpotLight":
                            t = {
                                position: new E,
                                direction: new E,
                                color: new ne,
                                distance: 0,
                                coneCos: 0,
                                penumbraCos: 0,
                                decay: 0
                            };
                            break;
                        case "PointLight":
                            t = {
                                position: new E,
                                color: new ne,
                                distance: 0,
                                decay: 0
                            };
                            break;
                        case "HemisphereLight":
                            t = {
                                direction: new E,
                                skyColor: new ne,
                                groundColor: new ne
                            };
                            break;
                        case "RectAreaLight":
                            t = {
                                color: new ne,
                                position: new E,
                                halfWidth: new E,
                                halfHeight: new E
                            };
                            break
                    }
                    return a[e.id] = t, t
                }
            }
        }

        function dv() {
            const a = {};
            return {
                get: function(e) {
                    if (a[e.id] !== void 0) return a[e.id];
                    let t;
                    switch (e.type) {
                        case "DirectionalLight":
                            t = {
                                shadowBias: 0,
                                shadowNormalBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new X
                            };
                            break;
                        case "SpotLight":
                            t = {
                                shadowBias: 0,
                                shadowNormalBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new X
                            };
                            break;
                        case "PointLight":
                            t = {
                                shadowBias: 0,
                                shadowNormalBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new X,
                                shadowCameraNear: 1,
                                shadowCameraFar: 1e3
                            };
                            break
                    }
                    return a[e.id] = t, t
                }
            }
        }
        let pv = 0;

        function mv(a, e) {
            return (e.castShadow ? 1 : 0) - (a.castShadow ? 1 : 0)
        }

        function gv(a, e) {
            const t = new fv,
                n = dv(),
                i = {
                    version: 0,
                    hash: {
                        directionalLength: -1,
                        pointLength: -1,
                        spotLength: -1,
                        rectAreaLength: -1,
                        hemiLength: -1,
                        numDirectionalShadows: -1,
                        numPointShadows: -1,
                        numSpotShadows: -1
                    },
                    ambient: [0, 0, 0],
                    probe: [],
                    directional: [],
                    directionalShadow: [],
                    directionalShadowMap: [],
                    directionalShadowMatrix: [],
                    spot: [],
                    spotShadow: [],
                    spotShadowMap: [],
                    spotShadowMatrix: [],
                    rectArea: [],
                    rectAreaLTC1: null,
                    rectAreaLTC2: null,
                    point: [],
                    pointShadow: [],
                    pointShadowMap: [],
                    pointShadowMatrix: [],
                    hemi: []
                };
            for (let u = 0; u < 9; u++) i.probe.push(new E);
            const r = new E,
                s = new fe,
                o = new fe;

            function l(u, h) {
                let f = 0,
                    d = 0,
                    m = 0;
                for (let P = 0; P < 9; P++) i.probe[P].set(0, 0, 0);
                let g = 0,
                    v = 0,
                    p = 0,
                    _ = 0,
                    M = 0,
                    y = 0,
                    b = 0,
                    T = 0;
                u.sort(mv);
                const x = h !== !0 ? Math.PI : 1;
                for (let P = 0, I = u.length; P < I; P++) {
                    const L = u[P],
                        Y = L.color,
                        D = L.intensity,
                        F = L.distance,
                        N = L.shadow && L.shadow.map ? L.shadow.map.texture : null;
                    if (L.isAmbientLight) f += Y.r * D * x, d += Y.g * D * x, m += Y.b * D * x;
                    else if (L.isLightProbe)
                        for (let z = 0; z < 9; z++) i.probe[z].addScaledVector(L.sh.coefficients[z], D);
                    else if (L.isDirectionalLight) {
                        const z = t.get(L);
                        if (z.color.copy(L.color).multiplyScalar(L.intensity * x), L.castShadow) {
                            const k = L.shadow,
                                J = n.get(L);
                            J.shadowBias = k.bias, J.shadowNormalBias = k.normalBias, J.shadowRadius = k.radius, J.shadowMapSize = k.mapSize, i.directionalShadow[g] = J, i.directionalShadowMap[g] = N, i.directionalShadowMatrix[g] = L.shadow.matrix, y++
                        }
                        i.directional[g] = z, g++
                    } else if (L.isSpotLight) {
                        const z = t.get(L);
                        if (z.position.setFromMatrixPosition(L.matrixWorld), z.color.copy(Y).multiplyScalar(D * x), z.distance = F, z.coneCos = Math.cos(L.angle), z.penumbraCos = Math.cos(L.angle * (1 - L.penumbra)), z.decay = L.decay, L.castShadow) {
                            const k = L.shadow,
                                J = n.get(L);
                            J.shadowBias = k.bias, J.shadowNormalBias = k.normalBias, J.shadowRadius = k.radius, J.shadowMapSize = k.mapSize, i.spotShadow[p] = J, i.spotShadowMap[p] = N, i.spotShadowMatrix[p] = L.shadow.matrix, T++
                        }
                        i.spot[p] = z, p++
                    } else if (L.isRectAreaLight) {
                        const z = t.get(L);
                        z.color.copy(Y).multiplyScalar(D), z.halfWidth.set(L.width * .5, 0, 0), z.halfHeight.set(0, L.height * .5, 0), i.rectArea[_] = z, _++
                    } else if (L.isPointLight) {
                        const z = t.get(L);
                        if (z.color.copy(L.color).multiplyScalar(L.intensity * x), z.distance = L.distance, z.decay = L.decay, L.castShadow) {
                            const k = L.shadow,
                                J = n.get(L);
                            J.shadowBias = k.bias, J.shadowNormalBias = k.normalBias, J.shadowRadius = k.radius, J.shadowMapSize = k.mapSize, J.shadowCameraNear = k.camera.near, J.shadowCameraFar = k.camera.far, i.pointShadow[v] = J, i.pointShadowMap[v] = N, i.pointShadowMatrix[v] = L.shadow.matrix, b++
                        }
                        i.point[v] = z, v++
                    } else if (L.isHemisphereLight) {
                        const z = t.get(L);
                        z.skyColor.copy(L.color).multiplyScalar(D * x), z.groundColor.copy(L.groundColor).multiplyScalar(D * x), i.hemi[M] = z, M++
                    }
                }
                _ > 0 && (e.isWebGL2 || a.has("OES_texture_float_linear") === !0 ? (i.rectAreaLTC1 = re.LTC_FLOAT_1, i.rectAreaLTC2 = re.LTC_FLOAT_2) : a.has("OES_texture_half_float_linear") === !0 ? (i.rectAreaLTC1 = re.LTC_HALF_1, i.rectAreaLTC2 = re.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), i.ambient[0] = f, i.ambient[1] = d, i.ambient[2] = m;
                const R = i.hash;
                (R.directionalLength !== g || R.pointLength !== v || R.spotLength !== p || R.rectAreaLength !== _ || R.hemiLength !== M || R.numDirectionalShadows !== y || R.numPointShadows !== b || R.numSpotShadows !== T) && (i.directional.length = g, i.spot.length = p, i.rectArea.length = _, i.point.length = v, i.hemi.length = M, i.directionalShadow.length = y, i.directionalShadowMap.length = y, i.pointShadow.length = b, i.pointShadowMap.length = b, i.spotShadow.length = T, i.spotShadowMap.length = T, i.directionalShadowMatrix.length = y, i.pointShadowMatrix.length = b, i.spotShadowMatrix.length = T, R.directionalLength = g, R.pointLength = v, R.spotLength = p, R.rectAreaLength = _, R.hemiLength = M, R.numDirectionalShadows = y, R.numPointShadows = b, R.numSpotShadows = T, i.version = pv++)
            }

            function c(u, h) {
                let f = 0,
                    d = 0,
                    m = 0,
                    g = 0,
                    v = 0;
                const p = h.matrixWorldInverse;
                for (let _ = 0, M = u.length; _ < M; _++) {
                    const y = u[_];
                    if (y.isDirectionalLight) {
                        const b = i.directional[f];
                        b.direction.setFromMatrixPosition(y.matrixWorld), r.setFromMatrixPosition(y.target.matrixWorld), b.direction.sub(r), b.direction.transformDirection(p), f++
                    } else if (y.isSpotLight) {
                        const b = i.spot[m];
                        b.position.setFromMatrixPosition(y.matrixWorld), b.position.applyMatrix4(p), b.direction.setFromMatrixPosition(y.matrixWorld), r.setFromMatrixPosition(y.target.matrixWorld), b.direction.sub(r), b.direction.transformDirection(p), m++
                    } else if (y.isRectAreaLight) {
                        const b = i.rectArea[g];
                        b.position.setFromMatrixPosition(y.matrixWorld), b.position.applyMatrix4(p), o.identity(), s.copy(y.matrixWorld), s.premultiply(p), o.extractRotation(s), b.halfWidth.set(y.width * .5, 0, 0), b.halfHeight.set(0, y.height * .5, 0), b.halfWidth.applyMatrix4(o), b.halfHeight.applyMatrix4(o), g++
                    } else if (y.isPointLight) {
                        const b = i.point[d];
                        b.position.setFromMatrixPosition(y.matrixWorld), b.position.applyMatrix4(p), d++
                    } else if (y.isHemisphereLight) {
                        const b = i.hemi[v];
                        b.direction.setFromMatrixPosition(y.matrixWorld), b.direction.transformDirection(p), b.direction.normalize(), v++
                    }
                }
            }
            return {
                setup: l,
                setupView: c,
                state: i
            }
        }

        function Yu(a, e) {
            const t = new gv(a, e),
                n = [],
                i = [];

            function r() {
                n.length = 0, i.length = 0
            }

            function s(h) {
                n.push(h)
            }

            function o(h) {
                i.push(h)
            }

            function l(h) {
                t.setup(n, h)
            }

            function c(h) {
                t.setupView(n, h)
            }
            return {
                init: r,
                state: {
                    lightsArray: n,
                    shadowsArray: i,
                    lights: t
                },
                setupLights: l,
                setupLightsView: c,
                pushLight: s,
                pushShadow: o
            }
        }

        function _v(a, e) {
            let t = new WeakMap;

            function n(r, s = 0) {
                let o;
                return t.has(r) === !1 ? (o = new Yu(a, e), t.set(r, [o])) : s >= t.get(r).length ? (o = new Yu(a, e), t.get(r).push(o)) : o = t.get(r)[s], o
            }

            function i() {
                t = new WeakMap
            }
            return {
                get: n,
                dispose: i
            }
        }
        class Zu extends ot {
            constructor(e) {
                super();
                this.type = "MeshDepthMaterial", this.depthPacking = cm, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.setValues(e)
            }
            copy(e) {
                return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this
            }
        }
        Zu.prototype.isMeshDepthMaterial = !0;
        class Ju extends ot {
            constructor(e) {
                super();
                this.type = "MeshDistanceMaterial", this.referencePosition = new E, this.nearDistance = 1, this.farDistance = 1e3, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.setValues(e)
            }
            copy(e) {
                return super.copy(e), this.referencePosition.copy(e.referencePosition), this.nearDistance = e.nearDistance, this.farDistance = e.farDistance, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this
            }
        }
        Ju.prototype.isMeshDistanceMaterial = !0;
        const vv = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
            xv = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
uniform float samples;
#include <packing>
void main() {
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;

        function $u(a, e, t) {
            let n = new ya;
            const i = new X,
                r = new X,
                s = new Ue,
                o = new Zu({
                    depthPacking: um
                }),
                l = new Ju,
                c = {},
                u = t.maxTextureSize,
                h = {
                    0: nt,
                    1: Vi,
                    2: vi
                },
                f = new It({
                    uniforms: {
                        shadow_pass: {
                            value: null
                        },
                        resolution: {
                            value: new X
                        },
                        radius: {
                            value: 4
                        },
                        samples: {
                            value: 8
                        }
                    },
                    vertexShader: vv,
                    fragmentShader: xv
                }),
                d = f.clone();
            d.defines.HORIZONTAL_PASS = 1;
            const m = new ke;
            m.setAttribute("position", new Qe(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
            const g = new Ge(m, f),
                v = this;
            this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = wc, this.render = function(y, b, T) {
                if (v.enabled === !1 || v.autoUpdate === !1 && v.needsUpdate === !1 || y.length === 0) return;
                const x = a.getRenderTarget(),
                    R = a.getActiveCubeFace(),
                    P = a.getActiveMipmapLevel(),
                    I = a.state;
                I.setBlending(On), I.buffers.color.setClear(1, 1, 1, 1), I.buffers.depth.setTest(!0), I.setScissorTest(!1);
                for (let L = 0, Y = y.length; L < Y; L++) {
                    const D = y[L],
                        F = D.shadow;
                    if (F === void 0) {
                        console.warn("THREE.WebGLShadowMap:", D, "has no shadow.");
                        continue
                    }
                    if (F.autoUpdate === !1 && F.needsUpdate === !1) continue;
                    i.copy(F.mapSize);
                    const N = F.getFrameExtents();
                    if (i.multiply(N), r.copy(F.mapSize), (i.x > u || i.y > u) && (i.x > u && (r.x = Math.floor(u / N.x), i.x = r.x * N.x, F.mapSize.x = r.x), i.y > u && (r.y = Math.floor(u / N.y), i.y = r.y * N.y, F.mapSize.y = r.y)), F.map === null && !F.isPointLightShadow && this.type === Zr) {
                        const k = {
                            minFilter: lt,
                            magFilter: lt,
                            format: ct
                        };
                        F.map = new Dt(i.x, i.y, k), F.map.texture.name = D.name + ".shadowMap", F.mapPass = new Dt(i.x, i.y, k), F.camera.updateProjectionMatrix()
                    }
                    if (F.map === null) {
                        const k = {
                            minFilter: st,
                            magFilter: st,
                            format: ct
                        };
                        F.map = new Dt(i.x, i.y, k), F.map.texture.name = D.name + ".shadowMap", F.camera.updateProjectionMatrix()
                    }
                    a.setRenderTarget(F.map), a.clear();
                    const z = F.getViewportCount();
                    for (let k = 0; k < z; k++) {
                        const J = F.getViewport(k);
                        s.set(r.x * J.x, r.y * J.y, r.x * J.z, r.y * J.w), I.viewport(s), F.updateMatrices(D, k), n = F.getFrustum(), M(b, T, F.camera, D, this.type)
                    }!F.isPointLightShadow && this.type === Zr && p(F, T), F.needsUpdate = !1
                }
                v.needsUpdate = !1, a.setRenderTarget(x, R, P)
            };

            function p(y, b) {
                const T = e.update(g);
                f.uniforms.shadow_pass.value = y.map.texture, f.uniforms.resolution.value = y.mapSize, f.uniforms.radius.value = y.radius, f.uniforms.samples.value = y.blurSamples, a.setRenderTarget(y.mapPass), a.clear(), a.renderBufferDirect(b, null, T, f, g, null), d.uniforms.shadow_pass.value = y.mapPass.texture, d.uniforms.resolution.value = y.mapSize, d.uniforms.radius.value = y.radius, d.uniforms.samples.value = y.blurSamples, a.setRenderTarget(y.map), a.clear(), a.renderBufferDirect(b, null, T, d, g, null)
            }

            function _(y, b, T, x, R, P, I) {
                let L = null;
                const Y = x.isPointLight === !0 ? y.customDistanceMaterial : y.customDepthMaterial;
                if (Y !== void 0 ? L = Y : L = x.isPointLight === !0 ? l : o, a.localClippingEnabled && T.clipShadows === !0 && T.clippingPlanes.length !== 0 || T.displacementMap && T.displacementScale !== 0 || T.alphaMap && T.alphaTest > 0) {
                    const D = L.uuid,
                        F = T.uuid;
                    let N = c[D];
                    N === void 0 && (N = {}, c[D] = N);
                    let z = N[F];
                    z === void 0 && (z = L.clone(), N[F] = z), L = z
                }
                return L.visible = T.visible, L.wireframe = T.wireframe, I === Zr ? L.side = T.shadowSide !== null ? T.shadowSide : T.side : L.side = T.shadowSide !== null ? T.shadowSide : h[T.side], L.alphaMap = T.alphaMap, L.alphaTest = T.alphaTest, L.clipShadows = T.clipShadows, L.clippingPlanes = T.clippingPlanes, L.clipIntersection = T.clipIntersection, L.displacementMap = T.displacementMap, L.displacementScale = T.displacementScale, L.displacementBias = T.displacementBias, L.wireframeLinewidth = T.wireframeLinewidth, L.linewidth = T.linewidth, x.isPointLight === !0 && L.isMeshDistanceMaterial === !0 && (L.referencePosition.setFromMatrixPosition(x.matrixWorld), L.nearDistance = R, L.farDistance = P), L
            }

            function M(y, b, T, x, R) {
                if (y.visible === !1) return;
                if (y.layers.test(b.layers) && (y.isMesh || y.isLine || y.isPoints) && (y.castShadow || y.receiveShadow && R === Zr) && (!y.frustumCulled || n.intersectsObject(y))) {
                    y.modelViewMatrix.multiplyMatrices(T.matrixWorldInverse, y.matrixWorld);
                    const L = e.update(y),
                        Y = y.material;
                    if (Array.isArray(Y)) {
                        const D = L.groups;
                        for (let F = 0, N = D.length; F < N; F++) {
                            const z = D[F],
                                k = Y[z.materialIndex];
                            if (k && k.visible) {
                                const J = _(y, L, k, x, T.near, T.far, R);
                                a.renderBufferDirect(T, null, L, J, y, z)
                            }
                        }
                    } else if (Y.visible) {
                        const D = _(y, L, Y, x, T.near, T.far, R);
                        a.renderBufferDirect(T, null, L, D, y, null)
                    }
                }
                const I = y.children;
                for (let L = 0, Y = I.length; L < Y; L++) M(I[L], b, T, x, R)
            }
        }

        function yv(a, e, t) {
            const n = t.isWebGL2;

            function i() {
                let C = !1;
                const ae = new Ue;
                let j = null;
                const ue = new Ue(0, 0, 0, 0);
                return {
                    setMask: function(pe) {
                        j !== pe && !C && (a.colorMask(pe, pe, pe, pe), j = pe)
                    },
                    setLocked: function(pe) {
                        C = pe
                    },
                    setClear: function(pe, Pe, St, Tt, gi) {
                        gi === !0 && (pe *= Tt, Pe *= Tt, St *= Tt), ae.set(pe, Pe, St, Tt), ue.equals(ae) === !1 && (a.clearColor(pe, Pe, St, Tt), ue.copy(ae))
                    },
                    reset: function() {
                        C = !1, j = null, ue.set(-1, 0, 0, 0)
                    }
                }
            }

            function r() {
                let C = !1,
                    ae = null,
                    j = null,
                    ue = null;
                return {
                    setTest: function(pe) {
                        pe ? $(2929) : me(2929)
                    },
                    setMask: function(pe) {
                        ae !== pe && !C && (a.depthMask(pe), ae = pe)
                    },
                    setFunc: function(pe) {
                        if (j !== pe) {
                            if (pe) switch (pe) {
                                case Kd:
                                    a.depthFunc(512);
                                    break;
                                case Qd:
                                    a.depthFunc(519);
                                    break;
                                case ep:
                                    a.depthFunc(513);
                                    break;
                                case no:
                                    a.depthFunc(515);
                                    break;
                                case tp:
                                    a.depthFunc(514);
                                    break;
                                case np:
                                    a.depthFunc(518);
                                    break;
                                case ip:
                                    a.depthFunc(516);
                                    break;
                                case rp:
                                    a.depthFunc(517);
                                    break;
                                default:
                                    a.depthFunc(515)
                            } else a.depthFunc(515);
                            j = pe
                        }
                    },
                    setLocked: function(pe) {
                        C = pe
                    },
                    setClear: function(pe) {
                        ue !== pe && (a.clearDepth(pe), ue = pe)
                    },
                    reset: function() {
                        C = !1, ae = null, j = null, ue = null
                    }
                }
            }

            function s() {
                let C = !1,
                    ae = null,
                    j = null,
                    ue = null,
                    pe = null,
                    Pe = null,
                    St = null,
                    Tt = null,
                    gi = null;
                return {
                    setTest: function(tt) {
                        C || (tt ? $(2960) : me(2960))
                    },
                    setMask: function(tt) {
                        ae !== tt && !C && (a.stencilMask(tt), ae = tt)
                    },
                    setFunc: function(tt, Nn, Bn) {
                        (j !== tt || ue !== Nn || pe !== Bn) && (a.stencilFunc(tt, Nn, Bn), j = tt, ue = Nn, pe = Bn)
                    },
                    setOp: function(tt, Nn, Bn) {
                        (Pe !== tt || St !== Nn || Tt !== Bn) && (a.stencilOp(tt, Nn, Bn), Pe = tt, St = Nn, Tt = Bn)
                    },
                    setLocked: function(tt) {
                        C = tt
                    },
                    setClear: function(tt) {
                        gi !== tt && (a.clearStencil(tt), gi = tt)
                    },
                    reset: function() {
                        C = !1, ae = null, j = null, ue = null, pe = null, Pe = null, St = null, Tt = null, gi = null
                    }
                }
            }
            const o = new i,
                l = new r,
                c = new s;
            let u = {},
                h = null,
                f = {},
                d = null,
                m = !1,
                g = null,
                v = null,
                p = null,
                _ = null,
                M = null,
                y = null,
                b = null,
                T = !1,
                x = null,
                R = null,
                P = null,
                I = null,
                L = null;
            const Y = a.getParameter(35661);
            let D = !1,
                F = 0;
            const N = a.getParameter(7938);
            N.indexOf("WebGL") !== -1 ? (F = parseFloat(/^WebGL (\d)/.exec(N)[1]), D = F >= 1) : N.indexOf("OpenGL ES") !== -1 && (F = parseFloat(/^OpenGL ES (\d)/.exec(N)[1]), D = F >= 2);
            let z = null,
                k = {};
            const J = a.getParameter(3088),
                oe = a.getParameter(2978),
                he = new Ue().fromArray(J),
                ie = new Ue().fromArray(oe);

            function be(C, ae, j) {
                const ue = new Uint8Array(4),
                    pe = a.createTexture();
                a.bindTexture(C, pe), a.texParameteri(C, 10241, 9728), a.texParameteri(C, 10240, 9728);
                for (let Pe = 0; Pe < j; Pe++) a.texImage2D(ae + Pe, 0, 6408, 1, 1, 0, 6408, 5121, ue);
                return pe
            }
            const W = {};
            W[3553] = be(3553, 3553, 1), W[34067] = be(34067, 34069, 6), o.setClear(0, 0, 0, 1), l.setClear(1), c.setClear(0), $(2929), l.setFunc(no), Z(!1), te(bc), $(2884), Le(On);

            function $(C) {
                u[C] !== !0 && (a.enable(C), u[C] = !0)
            }

            function me(C) {
                u[C] !== !1 && (a.disable(C), u[C] = !1)
            }

            function G(C) {
                C !== h && (a.bindFramebuffer(36160, C), h = C)
            }

            function xe(C, ae) {
                return ae === null && h !== null && (ae = h), f[C] !== ae ? (a.bindFramebuffer(C, ae), f[C] = ae, n && (C === 36009 && (f[36160] = ae), C === 36160 && (f[36009] = ae)), !0) : !1
            }

            function Se(C) {
                return d !== C ? (a.useProgram(C), d = C, !0) : !1
            }
            const le = {
                [Wi]: 32774,
                [Gd]: 32778,
                [Hd]: 32779
            };
            if (n) le[Ac] = 32775, le[Lc] = 32776;
            else {
                const C = e.get("EXT_blend_minmax");
                C !== null && (le[Ac] = C.MIN_EXT, le[Lc] = C.MAX_EXT)
            }
            const de = {
                [Vd]: 0,
                [Wd]: 1,
                [qd]: 768,
                [Rc]: 770,
                [$d]: 776,
                [Zd]: 774,
                [jd]: 772,
                [Xd]: 769,
                [Cc]: 771,
                [Jd]: 775,
                [Yd]: 773
            };

            function Le(C, ae, j, ue, pe, Pe, St, Tt) {
                if (C === On) {
                    m === !0 && (me(3042), m = !1);
                    return
                }
                if (m === !1 && ($(3042), m = !0), C !== kd) {
                    if (C !== g || Tt !== T) {
                        if ((v !== Wi || M !== Wi) && (a.blendEquation(32774), v = Wi, M = Wi), Tt) switch (C) {
                            case Jr:
                                a.blendFuncSeparate(1, 771, 1, 771);
                                break;
                            case to:
                                a.blendFunc(1, 1);
                                break;
                            case Tc:
                                a.blendFuncSeparate(0, 0, 769, 771);
                                break;
                            case Ec:
                                a.blendFuncSeparate(0, 768, 0, 770);
                                break;
                            default:
                                console.error("THREE.WebGLState: Invalid blending: ", C);
                                break
                        } else switch (C) {
                            case Jr:
                                a.blendFuncSeparate(770, 771, 1, 771);
                                break;
                            case to:
                                a.blendFunc(770, 1);
                                break;
                            case Tc:
                                a.blendFunc(0, 769);
                                break;
                            case Ec:
                                a.blendFunc(0, 768);
                                break;
                            default:
                                console.error("THREE.WebGLState: Invalid blending: ", C);
                                break
                        }
                        p = null, _ = null, y = null, b = null, g = C, T = Tt
                    }
                    return
                }
                pe = pe || ae, Pe = Pe || j, St = St || ue, (ae !== v || pe !== M) && (a.blendEquationSeparate(le[ae], le[pe]), v = ae, M = pe), (j !== p || ue !== _ || Pe !== y || St !== b) && (a.blendFuncSeparate(de[j], de[ue], de[Pe], de[St]), p = j, _ = ue, y = Pe, b = St), g = C, T = null
            }

            function V(C, ae) {
                C.side === vi ? me(2884) : $(2884);
                let j = C.side === nt;
                ae && (j = !j), Z(j), C.blending === Jr && C.transparent === !1 ? Le(On) : Le(C.blending, C.blendEquation, C.blendSrc, C.blendDst, C.blendEquationAlpha, C.blendSrcAlpha, C.blendDstAlpha, C.premultipliedAlpha), l.setFunc(C.depthFunc), l.setTest(C.depthTest), l.setMask(C.depthWrite), o.setMask(C.colorWrite);
                const ue = C.stencilWrite;
                c.setTest(ue), ue && (c.setMask(C.stencilWriteMask), c.setFunc(C.stencilFunc, C.stencilRef, C.stencilFuncMask), c.setOp(C.stencilFail, C.stencilZFail, C.stencilZPass)), se(C.polygonOffset, C.polygonOffsetFactor, C.polygonOffsetUnits), C.alphaToCoverage === !0 ? $(32926) : me(32926)
            }

            function Z(C) {
                x !== C && (C ? a.frontFace(2304) : a.frontFace(2305), x = C)
            }

            function te(C) {
                C !== Et ? ($(2884), C !== R && (C === bc ? a.cullFace(1029) : C === Od ? a.cullFace(1028) : a.cullFace(1032))) : me(2884), R = C
            }

            function ge(C) {
                C !== P && (D && a.lineWidth(C), P = C)
            }

            function se(C, ae, j) {
                C ? ($(32823), (I !== ae || L !== j) && (a.polygonOffset(ae, j), I = ae, L = j)) : me(32823)
            }

            function A(C) {
                C ? $(3089) : me(3089)
            }

            function S(C) {
                C === void 0 && (C = 33984 + Y - 1), z !== C && (a.activeTexture(C), z = C)
            }

            function H(C, ae) {
                z === null && S();
                let j = k[z];
                j === void 0 && (j = {
                    type: void 0,
                    texture: void 0
                }, k[z] = j), (j.type !== C || j.texture !== ae) && (a.bindTexture(C, ae || W[C]), j.type = C, j.texture = ae)
            }

            function K() {
                const C = k[z];
                C !== void 0 && C.type !== void 0 && (a.bindTexture(C.type, null), C.type = void 0, C.texture = void 0)
            }

            function Q() {
                try {
                    a.compressedTexImage2D.apply(a, arguments)
                } catch (C) {
                    console.error("THREE.WebGLState:", C)
                }
            }

            function ce() {
                try {
                    a.texImage2D.apply(a, arguments)
                } catch (C) {
                    console.error("THREE.WebGLState:", C)
                }
            }

            function we() {
                try {
                    a.texImage3D.apply(a, arguments)
                } catch (C) {
                    console.error("THREE.WebGLState:", C)
                }
            }

            function ve(C) {
                he.equals(C) === !1 && (a.scissor(C.x, C.y, C.z, C.w), he.copy(C))
            }

            function Ee(C) {
                ie.equals(C) === !1 && (a.viewport(C.x, C.y, C.z, C.w), ie.copy(C))
            }

            function _e() {
                a.disable(3042), a.disable(2884), a.disable(2929), a.disable(32823), a.disable(3089), a.disable(2960), a.disable(32926), a.blendEquation(32774), a.blendFunc(1, 0), a.blendFuncSeparate(1, 0, 1, 0), a.colorMask(!0, !0, !0, !0), a.clearColor(0, 0, 0, 0), a.depthMask(!0), a.depthFunc(513), a.clearDepth(1), a.stencilMask(4294967295), a.stencilFunc(519, 0, 4294967295), a.stencilOp(7680, 7680, 7680), a.clearStencil(0), a.cullFace(1029), a.frontFace(2305), a.polygonOffset(0, 0), a.activeTexture(33984), a.bindFramebuffer(36160, null), n === !0 && (a.bindFramebuffer(36009, null), a.bindFramebuffer(36008, null)), a.useProgram(null), a.lineWidth(1), a.scissor(0, 0, a.canvas.width, a.canvas.height), a.viewport(0, 0, a.canvas.width, a.canvas.height), u = {}, z = null, k = {}, h = null, f = {}, d = null, m = !1, g = null, v = null, p = null, _ = null, M = null, y = null, b = null, T = !1, x = null, R = null, P = null, I = null, L = null, he.set(0, 0, a.canvas.width, a.canvas.height), ie.set(0, 0, a.canvas.width, a.canvas.height), o.reset(), l.reset(), c.reset()
            }
            return {
                buffers: {
                    color: o,
                    depth: l,
                    stencil: c
                },
                enable: $,
                disable: me,
                bindFramebuffer: xe,
                bindXRFramebuffer: G,
                useProgram: Se,
                setBlending: Le,
                setMaterial: V,
                setFlipSided: Z,
                setCullFace: te,
                setLineWidth: ge,
                setPolygonOffset: se,
                setScissorTest: A,
                activeTexture: S,
                bindTexture: H,
                unbindTexture: K,
                compressedTexImage2D: Q,
                texImage2D: ce,
                texImage3D: we,
                scissor: ve,
                viewport: Ee,
                reset: _e
            }
        }

        function Mv(a, e, t, n, i, r, s) {
            const o = i.isWebGL2,
                l = i.maxTextures,
                c = i.maxCubemapSize,
                u = i.maxTextureSize,
                h = i.maxSamples,
                f = new WeakMap;
            let d, m = !1;
            try {
                m = typeof OffscreenCanvas != "undefined" && new OffscreenCanvas(1, 1).getContext("2d") !== null
            } catch {}

            function g(A, S) {
                return m ? new OffscreenCanvas(A, S) : ea("canvas")
            }

            function v(A, S, H, K) {
                let Q = 1;
                if ((A.width > K || A.height > K) && (Q = K / Math.max(A.width, A.height)), Q < 1 || S === !0)
                    if (typeof HTMLImageElement != "undefined" && A instanceof HTMLImageElement || typeof HTMLCanvasElement != "undefined" && A instanceof HTMLCanvasElement || typeof ImageBitmap != "undefined" && A instanceof ImageBitmap) {
                        const ce = S ? $c : Math.floor,
                            we = ce(Q * A.width),
                            ve = ce(Q * A.height);
                        d === void 0 && (d = g(we, ve));
                        const Ee = H ? g(we, ve) : d;
                        return Ee.width = we, Ee.height = ve, Ee.getContext("2d").drawImage(A, 0, 0, we, ve), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + A.width + "x" + A.height + ") to (" + we + "x" + ve + ")."), Ee
                    } else return "data" in A && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + A.width + "x" + A.height + ")."), A;
                return A
            }

            function p(A) {
                return mo(A.width) && mo(A.height)
            }

            function _(A) {
                return o ? !1 : A.wrapS !== Ct || A.wrapT !== Ct || A.minFilter !== st && A.minFilter !== lt
            }

            function M(A, S) {
                return A.generateMipmaps && S && A.minFilter !== st && A.minFilter !== lt
            }

            function y(A, S, H, K, Q = 1) {
                a.generateMipmap(A);
                const ce = n.get(S);
                ce.__maxMipLevel = Math.log2(Math.max(H, K, Q))
            }

            function b(A, S, H, K) {
                if (o === !1) return S;
                if (A !== null) {
                    if (a[A] !== void 0) return a[A];
                    console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + A + "'")
                }
                let Q = S;
                return S === 6403 && (H === 5126 && (Q = 33326), H === 5131 && (Q = 33325), H === 5121 && (Q = 33321)), S === 6407 && (H === 5126 && (Q = 34837), H === 5131 && (Q = 34843), H === 5121 && (Q = 32849)), S === 6408 && (H === 5126 && (Q = 34836), H === 5131 && (Q = 34842), H === 5121 && (Q = K === Ot ? 35907 : 32856)), (Q === 33325 || Q === 33326 || Q === 34842 || Q === 34836) && e.get("EXT_color_buffer_float"), Q
            }

            function T(A) {
                return A === st || A === ao || A === oo ? 9728 : 9729
            }

            function x(A) {
                const S = A.target;
                S.removeEventListener("dispose", x), P(S), S.isVideoTexture && f.delete(S), s.memory.textures--
            }

            function R(A) {
                const S = A.target;
                S.removeEventListener("dispose", R), I(S)
            }

            function P(A) {
                const S = n.get(A);
                S.__webglInit !== void 0 && (a.deleteTexture(S.__webglTexture), n.remove(A))
            }

            function I(A) {
                const S = A.texture,
                    H = n.get(A),
                    K = n.get(S);
                if (!!A) {
                    if (K.__webglTexture !== void 0 && (a.deleteTexture(K.__webglTexture), s.memory.textures--), A.depthTexture && A.depthTexture.dispose(), A.isWebGLCubeRenderTarget)
                        for (let Q = 0; Q < 6; Q++) a.deleteFramebuffer(H.__webglFramebuffer[Q]), H.__webglDepthbuffer && a.deleteRenderbuffer(H.__webglDepthbuffer[Q]);
                    else a.deleteFramebuffer(H.__webglFramebuffer), H.__webglDepthbuffer && a.deleteRenderbuffer(H.__webglDepthbuffer), H.__webglMultisampledFramebuffer && a.deleteFramebuffer(H.__webglMultisampledFramebuffer), H.__webglColorRenderbuffer && a.deleteRenderbuffer(H.__webglColorRenderbuffer), H.__webglDepthRenderbuffer && a.deleteRenderbuffer(H.__webglDepthRenderbuffer);
                    if (A.isWebGLMultipleRenderTargets)
                        for (let Q = 0, ce = S.length; Q < ce; Q++) {
                            const we = n.get(S[Q]);
                            we.__webglTexture && (a.deleteTexture(we.__webglTexture), s.memory.textures--), n.remove(S[Q])
                        }
                    n.remove(S), n.remove(A)
                }
            }
            let L = 0;

            function Y() {
                L = 0
            }

            function D() {
                const A = L;
                return A >= l && console.warn("THREE.WebGLTextures: Trying to use " + A + " texture units while this GPU supports only " + l), L += 1, A
            }

            function F(A, S) {
                const H = n.get(A);
                if (A.isVideoTexture && V(A), A.version > 0 && H.__version !== A.version) {
                    const K = A.image;
                    if (K === void 0) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
                    else if (K.complete === !1) console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
                    else {
                        be(H, A, S);
                        return
                    }
                }
                t.activeTexture(33984 + S), t.bindTexture(3553, H.__webglTexture)
            }

            function N(A, S) {
                const H = n.get(A);
                if (A.version > 0 && H.__version !== A.version) {
                    be(H, A, S);
                    return
                }
                t.activeTexture(33984 + S), t.bindTexture(35866, H.__webglTexture)
            }

            function z(A, S) {
                const H = n.get(A);
                if (A.version > 0 && H.__version !== A.version) {
                    be(H, A, S);
                    return
                }
                t.activeTexture(33984 + S), t.bindTexture(32879, H.__webglTexture)
            }

            function k(A, S) {
                const H = n.get(A);
                if (A.version > 0 && H.__version !== A.version) {
                    W(H, A, S);
                    return
                }
                t.activeTexture(33984 + S), t.bindTexture(34067, H.__webglTexture)
            }
            const J = {
                    [xn]: 10497,
                    [Ct]: 33071,
                    [Zs]: 33648
                },
                oe = {
                    [st]: 9728,
                    [ao]: 9984,
                    [oo]: 9986,
                    [lt]: 9729,
                    [Ic]: 9985,
                    [qi]: 9987
                };

            function he(A, S, H) {
                if (H ? (a.texParameteri(A, 10242, J[S.wrapS]), a.texParameteri(A, 10243, J[S.wrapT]), (A === 32879 || A === 35866) && a.texParameteri(A, 32882, J[S.wrapR]), a.texParameteri(A, 10240, oe[S.magFilter]), a.texParameteri(A, 10241, oe[S.minFilter])) : (a.texParameteri(A, 10242, 33071), a.texParameteri(A, 10243, 33071), (A === 32879 || A === 35866) && a.texParameteri(A, 32882, 33071), (S.wrapS !== Ct || S.wrapT !== Ct) && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), a.texParameteri(A, 10240, T(S.magFilter)), a.texParameteri(A, 10241, T(S.minFilter)), S.minFilter !== st && S.minFilter !== lt && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), e.has("EXT_texture_filter_anisotropic") === !0) {
                    const K = e.get("EXT_texture_filter_anisotropic");
                    if (S.type === yn && e.has("OES_texture_float_linear") === !1 || o === !1 && S.type === Xi && e.has("OES_texture_half_float_linear") === !1) return;
                    (S.anisotropy > 1 || n.get(S).__currentAnisotropy) && (a.texParameterf(A, K.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(S.anisotropy, i.getMaxAnisotropy())), n.get(S).__currentAnisotropy = S.anisotropy)
                }
            }

            function ie(A, S) {
                A.__webglInit === void 0 && (A.__webglInit = !0, S.addEventListener("dispose", x), A.__webglTexture = a.createTexture(), s.memory.textures++)
            }

            function be(A, S, H) {
                let K = 3553;
                S.isDataTexture2DArray && (K = 35866), S.isDataTexture3D && (K = 32879), ie(A, S), t.activeTexture(33984 + H), t.bindTexture(K, A.__webglTexture), a.pixelStorei(37440, S.flipY), a.pixelStorei(37441, S.premultiplyAlpha), a.pixelStorei(3317, S.unpackAlignment), a.pixelStorei(37443, 0);
                const Q = _(S) && p(S.image) === !1,
                    ce = v(S.image, Q, !1, u),
                    we = p(ce) || o,
                    ve = r.convert(S.format);
                let Ee = r.convert(S.type),
                    _e = b(S.internalFormat, ve, Ee, S.encoding);
                he(K, S, we);
                let C;
                const ae = S.mipmaps;
                if (S.isDepthTexture) _e = 6402, o ? S.type === yn ? _e = 36012 : S.type === $s ? _e = 33190 : S.type === $r ? _e = 35056 : _e = 33189 : S.type === yn && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), S.format === ji && _e === 6402 && S.type !== Js && S.type !== $s && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), S.type = Js, Ee = r.convert(S.type)), S.format === Kr && _e === 6402 && (_e = 34041, S.type !== $r && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), S.type = $r, Ee = r.convert(S.type))), t.texImage2D(3553, 0, _e, ce.width, ce.height, 0, ve, Ee, null);
                else if (S.isDataTexture)
                    if (ae.length > 0 && we) {
                        for (let j = 0, ue = ae.length; j < ue; j++) C = ae[j], t.texImage2D(3553, j, _e, C.width, C.height, 0, ve, Ee, C.data);
                        S.generateMipmaps = !1, A.__maxMipLevel = ae.length - 1
                    } else t.texImage2D(3553, 0, _e, ce.width, ce.height, 0, ve, Ee, ce.data), A.__maxMipLevel = 0;
                else if (S.isCompressedTexture) {
                    for (let j = 0, ue = ae.length; j < ue; j++) C = ae[j], S.format !== ct && S.format !== yi ? ve !== null ? t.compressedTexImage2D(3553, j, _e, C.width, C.height, 0, C.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : t.texImage2D(3553, j, _e, C.width, C.height, 0, ve, Ee, C.data);
                    A.__maxMipLevel = ae.length - 1
                } else if (S.isDataTexture2DArray) t.texImage3D(35866, 0, _e, ce.width, ce.height, ce.depth, 0, ve, Ee, ce.data), A.__maxMipLevel = 0;
                else if (S.isDataTexture3D) t.texImage3D(32879, 0, _e, ce.width, ce.height, ce.depth, 0, ve, Ee, ce.data), A.__maxMipLevel = 0;
                else if (ae.length > 0 && we) {
                    for (let j = 0, ue = ae.length; j < ue; j++) C = ae[j], t.texImage2D(3553, j, _e, ve, Ee, C);
                    S.generateMipmaps = !1, A.__maxMipLevel = ae.length - 1
                } else t.texImage2D(3553, 0, _e, ve, Ee, ce), A.__maxMipLevel = 0;
                M(S, we) && y(K, S, ce.width, ce.height), A.__version = S.version, S.onUpdate && S.onUpdate(S)
            }

            function W(A, S, H) {
                if (S.image.length !== 6) return;
                ie(A, S), t.activeTexture(33984 + H), t.bindTexture(34067, A.__webglTexture), a.pixelStorei(37440, S.flipY), a.pixelStorei(37441, S.premultiplyAlpha), a.pixelStorei(3317, S.unpackAlignment), a.pixelStorei(37443, 0);
                const K = S && (S.isCompressedTexture || S.image[0].isCompressedTexture),
                    Q = S.image[0] && S.image[0].isDataTexture,
                    ce = [];
                for (let j = 0; j < 6; j++) !K && !Q ? ce[j] = v(S.image[j], !1, !0, c) : ce[j] = Q ? S.image[j].image : S.image[j];
                const we = ce[0],
                    ve = p(we) || o,
                    Ee = r.convert(S.format),
                    _e = r.convert(S.type),
                    C = b(S.internalFormat, Ee, _e, S.encoding);
                he(34067, S, ve);
                let ae;
                if (K) {
                    for (let j = 0; j < 6; j++) {
                        ae = ce[j].mipmaps;
                        for (let ue = 0; ue < ae.length; ue++) {
                            const pe = ae[ue];
                            S.format !== ct && S.format !== yi ? Ee !== null ? t.compressedTexImage2D(34069 + j, ue, C, pe.width, pe.height, 0, pe.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : t.texImage2D(34069 + j, ue, C, pe.width, pe.height, 0, Ee, _e, pe.data)
                        }
                    }
                    A.__maxMipLevel = ae.length - 1
                } else {
                    ae = S.mipmaps;
                    for (let j = 0; j < 6; j++)
                        if (Q) {
                            t.texImage2D(34069 + j, 0, C, ce[j].width, ce[j].height, 0, Ee, _e, ce[j].data);
                            for (let ue = 0; ue < ae.length; ue++) {
                                const Pe = ae[ue].image[j].image;
                                t.texImage2D(34069 + j, ue + 1, C, Pe.width, Pe.height, 0, Ee, _e, Pe.data)
                            }
                        } else {
                            t.texImage2D(34069 + j, 0, C, Ee, _e, ce[j]);
                            for (let ue = 0; ue < ae.length; ue++) {
                                const pe = ae[ue];
                                t.texImage2D(34069 + j, ue + 1, C, Ee, _e, pe.image[j])
                            }
                        }
                    A.__maxMipLevel = ae.length
                }
                M(S, ve) && y(34067, S, we.width, we.height), A.__version = S.version, S.onUpdate && S.onUpdate(S)
            }

            function $(A, S, H, K, Q) {
                const ce = r.convert(H.format),
                    we = r.convert(H.type),
                    ve = b(H.internalFormat, ce, we, H.encoding);
                Q === 32879 || Q === 35866 ? t.texImage3D(Q, 0, ve, S.width, S.height, S.depth, 0, ce, we, null) : t.texImage2D(Q, 0, ve, S.width, S.height, 0, ce, we, null), t.bindFramebuffer(36160, A), a.framebufferTexture2D(36160, K, Q, n.get(H).__webglTexture, 0), t.bindFramebuffer(36160, null)
            }

            function me(A, S, H) {
                if (a.bindRenderbuffer(36161, A), S.depthBuffer && !S.stencilBuffer) {
                    let K = 33189;
                    if (H) {
                        const Q = S.depthTexture;
                        Q && Q.isDepthTexture && (Q.type === yn ? K = 36012 : Q.type === $s && (K = 33190));
                        const ce = Le(S);
                        a.renderbufferStorageMultisample(36161, ce, K, S.width, S.height)
                    } else a.renderbufferStorage(36161, K, S.width, S.height);
                    a.framebufferRenderbuffer(36160, 36096, 36161, A)
                } else if (S.depthBuffer && S.stencilBuffer) {
                    if (H) {
                        const K = Le(S);
                        a.renderbufferStorageMultisample(36161, K, 35056, S.width, S.height)
                    } else a.renderbufferStorage(36161, 34041, S.width, S.height);
                    a.framebufferRenderbuffer(36160, 33306, 36161, A)
                } else {
                    const K = S.isWebGLMultipleRenderTargets === !0 ? S.texture[0] : S.texture,
                        Q = r.convert(K.format),
                        ce = r.convert(K.type),
                        we = b(K.internalFormat, Q, ce, K.encoding);
                    if (H) {
                        const ve = Le(S);
                        a.renderbufferStorageMultisample(36161, ve, we, S.width, S.height)
                    } else a.renderbufferStorage(36161, we, S.width, S.height)
                }
                a.bindRenderbuffer(36161, null)
            }

            function G(A, S) {
                if (S && S.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
                if (t.bindFramebuffer(36160, A), !(S.depthTexture && S.depthTexture.isDepthTexture)) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                (!n.get(S.depthTexture).__webglTexture || S.depthTexture.image.width !== S.width || S.depthTexture.image.height !== S.height) && (S.depthTexture.image.width = S.width, S.depthTexture.image.height = S.height, S.depthTexture.needsUpdate = !0), F(S.depthTexture, 0);
                const K = n.get(S.depthTexture).__webglTexture;
                if (S.depthTexture.format === ji) a.framebufferTexture2D(36160, 36096, 3553, K, 0);
                else if (S.depthTexture.format === Kr) a.framebufferTexture2D(36160, 33306, 3553, K, 0);
                else throw new Error("Unknown depthTexture format")
            }

            function xe(A) {
                const S = n.get(A),
                    H = A.isWebGLCubeRenderTarget === !0;
                if (A.depthTexture) {
                    if (H) throw new Error("target.depthTexture not supported in Cube render targets");
                    G(S.__webglFramebuffer, A)
                } else if (H) {
                    S.__webglDepthbuffer = [];
                    for (let K = 0; K < 6; K++) t.bindFramebuffer(36160, S.__webglFramebuffer[K]), S.__webglDepthbuffer[K] = a.createRenderbuffer(), me(S.__webglDepthbuffer[K], A, !1)
                } else t.bindFramebuffer(36160, S.__webglFramebuffer), S.__webglDepthbuffer = a.createRenderbuffer(), me(S.__webglDepthbuffer, A, !1);
                t.bindFramebuffer(36160, null)
            }

            function Se(A) {
                const S = A.texture,
                    H = n.get(A),
                    K = n.get(S);
                A.addEventListener("dispose", R), A.isWebGLMultipleRenderTargets !== !0 && (K.__webglTexture = a.createTexture(), K.__version = S.version, s.memory.textures++);
                const Q = A.isWebGLCubeRenderTarget === !0,
                    ce = A.isWebGLMultipleRenderTargets === !0,
                    we = A.isWebGLMultisampleRenderTarget === !0,
                    ve = S.isDataTexture3D || S.isDataTexture2DArray,
                    Ee = p(A) || o;
                if (o && S.format === yi && (S.type === yn || S.type === Xi) && (S.format = ct, console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")), Q) {
                    H.__webglFramebuffer = [];
                    for (let _e = 0; _e < 6; _e++) H.__webglFramebuffer[_e] = a.createFramebuffer()
                } else if (H.__webglFramebuffer = a.createFramebuffer(), ce)
                    if (i.drawBuffers) {
                        const _e = A.texture;
                        for (let C = 0, ae = _e.length; C < ae; C++) {
                            const j = n.get(_e[C]);
                            j.__webglTexture === void 0 && (j.__webglTexture = a.createTexture(), s.memory.textures++)
                        }
                    } else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
                else if (we)
                    if (o) {
                        H.__webglMultisampledFramebuffer = a.createFramebuffer(), H.__webglColorRenderbuffer = a.createRenderbuffer(), a.bindRenderbuffer(36161, H.__webglColorRenderbuffer);
                        const _e = r.convert(S.format),
                            C = r.convert(S.type),
                            ae = b(S.internalFormat, _e, C, S.encoding),
                            j = Le(A);
                        a.renderbufferStorageMultisample(36161, j, ae, A.width, A.height), t.bindFramebuffer(36160, H.__webglMultisampledFramebuffer), a.framebufferRenderbuffer(36160, 36064, 36161, H.__webglColorRenderbuffer), a.bindRenderbuffer(36161, null), A.depthBuffer && (H.__webglDepthRenderbuffer = a.createRenderbuffer(), me(H.__webglDepthRenderbuffer, A, !0)), t.bindFramebuffer(36160, null)
                    } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
                if (Q) {
                    t.bindTexture(34067, K.__webglTexture), he(34067, S, Ee);
                    for (let _e = 0; _e < 6; _e++) $(H.__webglFramebuffer[_e], A, S, 36064, 34069 + _e);
                    M(S, Ee) && y(34067, S, A.width, A.height), t.unbindTexture()
                } else if (ce) {
                    const _e = A.texture;
                    for (let C = 0, ae = _e.length; C < ae; C++) {
                        const j = _e[C],
                            ue = n.get(j);
                        t.bindTexture(3553, ue.__webglTexture), he(3553, j, Ee), $(H.__webglFramebuffer, A, j, 36064 + C, 3553), M(j, Ee) && y(3553, j, A.width, A.height)
                    }
                    t.unbindTexture()
                } else {
                    let _e = 3553;
                    ve && (o ? _e = S.isDataTexture3D ? 32879 : 35866 : console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.")), t.bindTexture(_e, K.__webglTexture), he(_e, S, Ee), $(H.__webglFramebuffer, A, S, 36064, _e), M(S, Ee) && y(_e, S, A.width, A.height, A.depth), t.unbindTexture()
                }
                A.depthBuffer && xe(A)
            }

            function le(A) {
                const S = p(A) || o,
                    H = A.isWebGLMultipleRenderTargets === !0 ? A.texture : [A.texture];
                for (let K = 0, Q = H.length; K < Q; K++) {
                    const ce = H[K];
                    if (M(ce, S)) {
                        const we = A.isWebGLCubeRenderTarget ? 34067 : 3553,
                            ve = n.get(ce).__webglTexture;
                        t.bindTexture(we, ve), y(we, ce, A.width, A.height), t.unbindTexture()
                    }
                }
            }

            function de(A) {
                if (A.isWebGLMultisampleRenderTarget)
                    if (o) {
                        const S = A.width,
                            H = A.height;
                        let K = 16384;
                        A.depthBuffer && (K |= 256), A.stencilBuffer && (K |= 1024);
                        const Q = n.get(A);
                        t.bindFramebuffer(36008, Q.__webglMultisampledFramebuffer), t.bindFramebuffer(36009, Q.__webglFramebuffer), a.blitFramebuffer(0, 0, S, H, 0, 0, S, H, K, 9728), t.bindFramebuffer(36008, null), t.bindFramebuffer(36009, Q.__webglMultisampledFramebuffer)
                    } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")
            }

            function Le(A) {
                return o && A.isWebGLMultisampleRenderTarget ? Math.min(h, A.samples) : 0
            }

            function V(A) {
                const S = s.render.frame;
                f.get(A) !== S && (f.set(A, S), A.update())
            }
            let Z = !1,
                te = !1;

            function ge(A, S) {
                A && A.isWebGLRenderTarget && (Z === !1 && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), Z = !0), A = A.texture), F(A, S)
            }

            function se(A, S) {
                A && A.isWebGLCubeRenderTarget && (te === !1 && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), te = !0), A = A.texture), k(A, S)
            }
            this.allocateTextureUnit = D, this.resetTextureUnits = Y, this.setTexture2D = F, this.setTexture2DArray = N, this.setTexture3D = z, this.setTextureCube = k, this.setupRenderTarget = Se, this.updateRenderTargetMipmap = le, this.updateMultisampleRenderTarget = de, this.safeSetTexture2D = ge, this.safeSetTextureCube = se
        }

        function bv(a, e, t) {
            const n = t.isWebGL2;

            function i(r) {
                let s;
                if (r === Un) return 5121;
                if (r === pp) return 32819;
                if (r === mp) return 32820;
                if (r === gp) return 33635;
                if (r === hp) return 5120;
                if (r === fp) return 5122;
                if (r === Js) return 5123;
                if (r === dp) return 5124;
                if (r === $s) return 5125;
                if (r === yn) return 5126;
                if (r === Xi) return n ? 5131 : (s = e.get("OES_texture_half_float"), s !== null ? s.HALF_FLOAT_OES : null);
                if (r === _p) return 6406;
                if (r === yi) return 6407;
                if (r === ct) return 6408;
                if (r === vp) return 6409;
                if (r === xp) return 6410;
                if (r === ji) return 6402;
                if (r === Kr) return 34041;
                if (r === Mp) return 6403;
                if (r === bp) return 36244;
                if (r === wp) return 33319;
                if (r === Sp) return 33320;
                if (r === Tp) return 36248;
                if (r === Ep) return 36249;
                if (r === Fc || r === zc || r === Nc || r === Bc)
                    if (s = e.get("WEBGL_compressed_texture_s3tc"), s !== null) {
                        if (r === Fc) return s.COMPRESSED_RGB_S3TC_DXT1_EXT;
                        if (r === zc) return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                        if (r === Nc) return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                        if (r === Bc) return s.COMPRESSED_RGBA_S3TC_DXT5_EXT
                    } else return null;
                if (r === Oc || r === Uc || r === kc || r === Gc)
                    if (s = e.get("WEBGL_compressed_texture_pvrtc"), s !== null) {
                        if (r === Oc) return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                        if (r === Uc) return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                        if (r === kc) return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                        if (r === Gc) return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                    } else return null;
                if (r === Ap) return s = e.get("WEBGL_compressed_texture_etc1"), s !== null ? s.COMPRESSED_RGB_ETC1_WEBGL : null;
                if ((r === Hc || r === Vc) && (s = e.get("WEBGL_compressed_texture_etc"), s !== null)) {
                    if (r === Hc) return s.COMPRESSED_RGB8_ETC2;
                    if (r === Vc) return s.COMPRESSED_RGBA8_ETC2_EAC
                }
                if (r === Lp || r === Rp || r === Cp || r === Pp || r === Dp || r === Ip || r === Fp || r === zp || r === Np || r === Bp || r === Op || r === Up || r === kp || r === Gp || r === Vp || r === Wp || r === qp || r === Xp || r === jp || r === Yp || r === Zp || r === Jp || r === $p || r === Kp || r === Qp || r === em || r === tm || r === nm) return s = e.get("WEBGL_compressed_texture_astc"), s !== null ? r : null;
                if (r === Hp) return s = e.get("EXT_texture_compression_bptc"), s !== null ? r : null;
                if (r === $r) return n ? 34042 : (s = e.get("WEBGL_depth_texture"), s !== null ? s.UNSIGNED_INT_24_8_WEBGL : null)
            }
            return {
                convert: i
            }
        }
        class Ku extends yt {
            constructor(e = []) {
                super();
                this.cameras = e
            }
        }
        Ku.prototype.isArrayCamera = !0;
        class Qn extends Te {
            constructor() {
                super();
                this.type = "Group"
            }
        }
        Qn.prototype.isGroup = !0;
        const wv = {
            type: "move"
        };
        class Zo {
            constructor() {
                this._targetRay = null, this._grip = null, this._hand = null
            }
            getHandSpace() {
                return this._hand === null && (this._hand = new Qn, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
                    pinching: !1
                }), this._hand
            }
            getTargetRaySpace() {
                return this._targetRay === null && (this._targetRay = new Qn, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new E, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new E), this._targetRay
            }
            getGripSpace() {
                return this._grip === null && (this._grip = new Qn, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new E, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new E), this._grip
            }
            dispatchEvent(e) {
                return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this
            }
            disconnect(e) {
                return this.dispatchEvent({
                    type: "disconnected",
                    data: e
                }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this
            }
            update(e, t, n) {
                let i = null,
                    r = null,
                    s = null;
                const o = this._targetRay,
                    l = this._grip,
                    c = this._hand;
                if (e && t.session.visibilityState !== "visible-blurred")
                    if (o !== null && (i = t.getPose(e.targetRaySpace, n), i !== null && (o.matrix.fromArray(i.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), i.linearVelocity ? (o.hasLinearVelocity = !0, o.linearVelocity.copy(i.linearVelocity)) : o.hasLinearVelocity = !1, i.angularVelocity ? (o.hasAngularVelocity = !0, o.angularVelocity.copy(i.angularVelocity)) : o.hasAngularVelocity = !1, this.dispatchEvent(wv))), c && e.hand) {
                        s = !0;
                        for (const g of e.hand.values()) {
                            const v = t.getJointPose(g, n);
                            if (c.joints[g.jointName] === void 0) {
                                const _ = new Qn;
                                _.matrixAutoUpdate = !1, _.visible = !1, c.joints[g.jointName] = _, c.add(_)
                            }
                            const p = c.joints[g.jointName];
                            v !== null && (p.matrix.fromArray(v.transform.matrix), p.matrix.decompose(p.position, p.rotation, p.scale), p.jointRadius = v.radius), p.visible = v !== null
                        }
                        const u = c.joints["index-finger-tip"],
                            h = c.joints["thumb-tip"],
                            f = u.position.distanceTo(h.position),
                            d = .02,
                            m = .005;
                        c.inputState.pinching && f > d + m ? (c.inputState.pinching = !1, this.dispatchEvent({
                            type: "pinchend",
                            handedness: e.handedness,
                            target: this
                        })) : !c.inputState.pinching && f <= d - m && (c.inputState.pinching = !0, this.dispatchEvent({
                            type: "pinchstart",
                            handedness: e.handedness,
                            target: this
                        }))
                    } else l !== null && e.gripSpace && (r = t.getPose(e.gripSpace, n), r !== null && (l.matrix.fromArray(r.transform.matrix), l.matrix.decompose(l.position, l.rotation, l.scale), r.linearVelocity ? (l.hasLinearVelocity = !0, l.linearVelocity.copy(r.linearVelocity)) : l.hasLinearVelocity = !1, r.angularVelocity ? (l.hasAngularVelocity = !0, l.angularVelocity.copy(r.angularVelocity)) : l.hasAngularVelocity = !1));
                return o !== null && (o.visible = i !== null), l !== null && (l.visible = r !== null), c !== null && (c.visible = s !== null), this
            }
        }
        class Sv extends bi {
            constructor(e, t) {
                super();
                const n = this,
                    i = e.state;
                let r = null,
                    s = 1,
                    o = null,
                    l = "local-floor",
                    c = null,
                    u = null,
                    h = null,
                    f = null,
                    d = null,
                    m = !1,
                    g = null,
                    v = null,
                    p = null,
                    _ = null,
                    M = null,
                    y = null;
                const b = [],
                    T = new Map,
                    x = new yt;
                x.layers.enable(1), x.viewport = new Ue;
                const R = new yt;
                R.layers.enable(2), R.viewport = new Ue;
                const P = [x, R],
                    I = new Ku;
                I.layers.enable(1), I.layers.enable(2);
                let L = null,
                    Y = null;
                this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(W) {
                    let $ = b[W];
                    return $ === void 0 && ($ = new Zo, b[W] = $), $.getTargetRaySpace()
                }, this.getControllerGrip = function(W) {
                    let $ = b[W];
                    return $ === void 0 && ($ = new Zo, b[W] = $), $.getGripSpace()
                }, this.getHand = function(W) {
                    let $ = b[W];
                    return $ === void 0 && ($ = new Zo, b[W] = $), $.getHandSpace()
                };

                function D(W) {
                    const $ = T.get(W.inputSource);
                    $ && $.dispatchEvent({
                        type: W.type,
                        data: W.inputSource
                    })
                }

                function F() {
                    T.forEach(function(W, $) {
                        W.disconnect($)
                    }), T.clear(), L = null, Y = null, i.bindXRFramebuffer(null), e.setRenderTarget(e.getRenderTarget()), h && t.deleteFramebuffer(h), g && t.deleteFramebuffer(g), v && t.deleteRenderbuffer(v), p && t.deleteRenderbuffer(p), h = null, g = null, v = null, p = null, d = null, f = null, u = null, r = null, be.stop(), n.isPresenting = !1, n.dispatchEvent({
                        type: "sessionend"
                    })
                }
                this.setFramebufferScaleFactor = function(W) {
                    s = W, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
                }, this.setReferenceSpaceType = function(W) {
                    l = W, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
                }, this.getReferenceSpace = function() {
                    return o
                }, this.getBaseLayer = function() {
                    return f !== null ? f : d
                }, this.getBinding = function() {
                    return u
                }, this.getFrame = function() {
                    return _
                }, this.getSession = function() {
                    return r
                }, this.setSession = async function(W) {
                    if (r = W, r !== null) {
                        r.addEventListener("select", D), r.addEventListener("selectstart", D), r.addEventListener("selectend", D), r.addEventListener("squeeze", D), r.addEventListener("squeezestart", D), r.addEventListener("squeezeend", D), r.addEventListener("end", F), r.addEventListener("inputsourceschange", N);
                        const $ = t.getContextAttributes();
                        if ($.xrCompatible !== !0 && await t.makeXRCompatible(), r.renderState.layers === void 0) {
                            const me = {
                                antialias: $.antialias,
                                alpha: $.alpha,
                                depth: $.depth,
                                stencil: $.stencil,
                                framebufferScaleFactor: s
                            };
                            d = new XRWebGLLayer(r, t, me), r.updateRenderState({
                                baseLayer: d
                            })
                        } else if (t instanceof WebGLRenderingContext) {
                            const me = {
                                antialias: !0,
                                alpha: $.alpha,
                                depth: $.depth,
                                stencil: $.stencil,
                                framebufferScaleFactor: s
                            };
                            d = new XRWebGLLayer(r, t, me), r.updateRenderState({
                                layers: [d]
                            })
                        } else {
                            m = $.antialias;
                            let me = null;
                            $.depth && (y = 256, $.stencil && (y |= 1024), M = $.stencil ? 33306 : 36096, me = $.stencil ? 35056 : 33190);
                            const G = {
                                colorFormat: $.alpha ? 32856 : 32849,
                                depthFormat: me,
                                scaleFactor: s
                            };
                            u = new XRWebGLBinding(r, t), f = u.createProjectionLayer(G), h = t.createFramebuffer(), r.updateRenderState({
                                layers: [f]
                            }), m && (g = t.createFramebuffer(), v = t.createRenderbuffer(), t.bindRenderbuffer(36161, v), t.renderbufferStorageMultisample(36161, 4, 32856, f.textureWidth, f.textureHeight), i.bindFramebuffer(36160, g), t.framebufferRenderbuffer(36160, 36064, 36161, v), t.bindRenderbuffer(36161, null), me !== null && (p = t.createRenderbuffer(), t.bindRenderbuffer(36161, p), t.renderbufferStorageMultisample(36161, 4, me, f.textureWidth, f.textureHeight), t.framebufferRenderbuffer(36160, M, 36161, p), t.bindRenderbuffer(36161, null)), i.bindFramebuffer(36160, null))
                        }
                        o = await r.requestReferenceSpace(l), be.setContext(r), be.start(), n.isPresenting = !0, n.dispatchEvent({
                            type: "sessionstart"
                        })
                    }
                };

                function N(W) {
                    const $ = r.inputSources;
                    for (let me = 0; me < b.length; me++) T.set($[me], b[me]);
                    for (let me = 0; me < W.removed.length; me++) {
                        const G = W.removed[me],
                            xe = T.get(G);
                        xe && (xe.dispatchEvent({
                            type: "disconnected",
                            data: G
                        }), T.delete(G))
                    }
                    for (let me = 0; me < W.added.length; me++) {
                        const G = W.added[me],
                            xe = T.get(G);
                        xe && xe.dispatchEvent({
                            type: "connected",
                            data: G
                        })
                    }
                }
                const z = new E,
                    k = new E;

                function J(W, $, me) {
                    z.setFromMatrixPosition($.matrixWorld), k.setFromMatrixPosition(me.matrixWorld);
                    const G = z.distanceTo(k),
                        xe = $.projectionMatrix.elements,
                        Se = me.projectionMatrix.elements,
                        le = xe[14] / (xe[10] - 1),
                        de = xe[14] / (xe[10] + 1),
                        Le = (xe[9] + 1) / xe[5],
                        V = (xe[9] - 1) / xe[5],
                        Z = (xe[8] - 1) / xe[0],
                        te = (Se[8] + 1) / Se[0],
                        ge = le * Z,
                        se = le * te,
                        A = G / (-Z + te),
                        S = A * -Z;
                    $.matrixWorld.decompose(W.position, W.quaternion, W.scale), W.translateX(S), W.translateZ(A), W.matrixWorld.compose(W.position, W.quaternion, W.scale), W.matrixWorldInverse.copy(W.matrixWorld).invert();
                    const H = le + A,
                        K = de + A,
                        Q = ge - S,
                        ce = se + (G - S),
                        we = Le * de / K * H,
                        ve = V * de / K * H;
                    W.projectionMatrix.makePerspective(Q, ce, we, ve, H, K)
                }

                function oe(W, $) {
                    $ === null ? W.matrixWorld.copy(W.matrix) : W.matrixWorld.multiplyMatrices($.matrixWorld, W.matrix), W.matrixWorldInverse.copy(W.matrixWorld).invert()
                }
                this.updateCamera = function(W) {
                    if (r === null) return;
                    I.near = R.near = x.near = W.near, I.far = R.far = x.far = W.far, (L !== I.near || Y !== I.far) && (r.updateRenderState({
                        depthNear: I.near,
                        depthFar: I.far
                    }), L = I.near, Y = I.far);
                    const $ = W.parent,
                        me = I.cameras;
                    oe(I, $);
                    for (let xe = 0; xe < me.length; xe++) oe(me[xe], $);
                    I.matrixWorld.decompose(I.position, I.quaternion, I.scale), W.position.copy(I.position), W.quaternion.copy(I.quaternion), W.scale.copy(I.scale), W.matrix.copy(I.matrix), W.matrixWorld.copy(I.matrixWorld);
                    const G = W.children;
                    for (let xe = 0, Se = G.length; xe < Se; xe++) G[xe].updateMatrixWorld(!0);
                    me.length === 2 ? J(I, x, R) : I.projectionMatrix.copy(x.projectionMatrix)
                }, this.getCamera = function() {
                    return I
                }, this.getFoveation = function() {
                    if (f !== null) return f.fixedFoveation;
                    if (d !== null) return d.fixedFoveation
                }, this.setFoveation = function(W) {
                    f !== null && (f.fixedFoveation = W), d !== null && d.fixedFoveation !== void 0 && (d.fixedFoveation = W)
                };
                let he = null;

                function ie(W, $) {
                    if (c = $.getViewerPose(o), _ = $, c !== null) {
                        const G = c.views;
                        d !== null && i.bindXRFramebuffer(d.framebuffer);
                        let xe = !1;
                        G.length !== I.cameras.length && (I.cameras.length = 0, xe = !0);
                        for (let Se = 0; Se < G.length; Se++) {
                            const le = G[Se];
                            let de = null;
                            if (d !== null) de = d.getViewport(le);
                            else {
                                const V = u.getViewSubImage(f, le);
                                i.bindXRFramebuffer(h), V.depthStencilTexture !== void 0 && t.framebufferTexture2D(36160, M, 3553, V.depthStencilTexture, 0), t.framebufferTexture2D(36160, 36064, 3553, V.colorTexture, 0), de = V.viewport
                            }
                            const Le = P[Se];
                            Le.matrix.fromArray(le.transform.matrix), Le.projectionMatrix.fromArray(le.projectionMatrix), Le.viewport.set(de.x, de.y, de.width, de.height), Se === 0 && I.matrix.copy(Le.matrix), xe === !0 && I.cameras.push(Le)
                        }
                        m && (i.bindXRFramebuffer(g), y !== null && t.clear(y))
                    }
                    const me = r.inputSources;
                    for (let G = 0; G < b.length; G++) {
                        const xe = b[G],
                            Se = me[G];
                        xe.update(Se, $, o)
                    }
                    if (he && he(W, $), m) {
                        const G = f.textureWidth,
                            xe = f.textureHeight;
                        i.bindFramebuffer(36008, g), i.bindFramebuffer(36009, h), t.invalidateFramebuffer(36008, [M]), t.invalidateFramebuffer(36009, [M]), t.blitFramebuffer(0, 0, G, xe, 0, 0, G, xe, 16384, 9728), t.invalidateFramebuffer(36008, [36064]), i.bindFramebuffer(36008, null), i.bindFramebuffer(36009, null), i.bindFramebuffer(36160, g)
                    }
                    _ = null
                }
                const be = new mu;
                be.setAnimationLoop(ie), this.setAnimationLoop = function(W) {
                    he = W
                }, this.dispose = function() {}
            }
        }

        function Tv(a) {
            function e(p, _) {
                p.fogColor.value.copy(_.color), _.isFog ? (p.fogNear.value = _.near, p.fogFar.value = _.far) : _.isFogExp2 && (p.fogDensity.value = _.density)
            }

            function t(p, _, M, y, b) {
                _.isMeshBasicMaterial ? n(p, _) : _.isMeshLambertMaterial ? (n(p, _), l(p, _)) : _.isMeshToonMaterial ? (n(p, _), u(p, _)) : _.isMeshPhongMaterial ? (n(p, _), c(p, _)) : _.isMeshStandardMaterial ? (n(p, _), _.isMeshPhysicalMaterial ? f(p, _, b) : h(p, _)) : _.isMeshMatcapMaterial ? (n(p, _), d(p, _)) : _.isMeshDepthMaterial ? (n(p, _), m(p, _)) : _.isMeshDistanceMaterial ? (n(p, _), g(p, _)) : _.isMeshNormalMaterial ? (n(p, _), v(p, _)) : _.isLineBasicMaterial ? (i(p, _), _.isLineDashedMaterial && r(p, _)) : _.isPointsMaterial ? s(p, _, M, y) : _.isSpriteMaterial ? o(p, _) : _.isShadowMaterial ? (p.color.value.copy(_.color), p.opacity.value = _.opacity) : _.isShaderMaterial && (_.uniformsNeedUpdate = !1)
            }

            function n(p, _) {
                p.opacity.value = _.opacity, _.color && p.diffuse.value.copy(_.color), _.emissive && p.emissive.value.copy(_.emissive).multiplyScalar(_.emissiveIntensity), _.map && (p.map.value = _.map), _.alphaMap && (p.alphaMap.value = _.alphaMap), _.specularMap && (p.specularMap.value = _.specularMap), _.alphaTest > 0 && (p.alphaTest.value = _.alphaTest);
                const M = a.get(_).envMap;
                if (M) {
                    p.envMap.value = M, p.flipEnvMap.value = M.isCubeTexture && M.isRenderTargetTexture === !1 ? -1 : 1, p.reflectivity.value = _.reflectivity, p.ior.value = _.ior, p.refractionRatio.value = _.refractionRatio;
                    const T = a.get(M).__maxMipLevel;
                    T !== void 0 && (p.maxMipLevel.value = T)
                }
                _.lightMap && (p.lightMap.value = _.lightMap, p.lightMapIntensity.value = _.lightMapIntensity), _.aoMap && (p.aoMap.value = _.aoMap, p.aoMapIntensity.value = _.aoMapIntensity);
                let y;
                _.map ? y = _.map : _.specularMap ? y = _.specularMap : _.displacementMap ? y = _.displacementMap : _.normalMap ? y = _.normalMap : _.bumpMap ? y = _.bumpMap : _.roughnessMap ? y = _.roughnessMap : _.metalnessMap ? y = _.metalnessMap : _.alphaMap ? y = _.alphaMap : _.emissiveMap ? y = _.emissiveMap : _.clearcoatMap ? y = _.clearcoatMap : _.clearcoatNormalMap ? y = _.clearcoatNormalMap : _.clearcoatRoughnessMap ? y = _.clearcoatRoughnessMap : _.specularIntensityMap ? y = _.specularIntensityMap : _.specularTintMap ? y = _.specularTintMap : _.transmissionMap ? y = _.transmissionMap : _.thicknessMap && (y = _.thicknessMap), y !== void 0 && (y.isWebGLRenderTarget && (y = y.texture), y.matrixAutoUpdate === !0 && y.updateMatrix(), p.uvTransform.value.copy(y.matrix));
                let b;
                _.aoMap ? b = _.aoMap : _.lightMap && (b = _.lightMap), b !== void 0 && (b.isWebGLRenderTarget && (b = b.texture), b.matrixAutoUpdate === !0 && b.updateMatrix(), p.uv2Transform.value.copy(b.matrix))
            }

            function i(p, _) {
                p.diffuse.value.copy(_.color), p.opacity.value = _.opacity
            }

            function r(p, _) {
                p.dashSize.value = _.dashSize, p.totalSize.value = _.dashSize + _.gapSize, p.scale.value = _.scale
            }

            function s(p, _, M, y) {
                p.diffuse.value.copy(_.color), p.opacity.value = _.opacity, p.size.value = _.size * M, p.scale.value = y * .5, _.map && (p.map.value = _.map), _.alphaMap && (p.alphaMap.value = _.alphaMap), _.alphaTest > 0 && (p.alphaTest.value = _.alphaTest);
                let b;
                _.map ? b = _.map : _.alphaMap && (b = _.alphaMap), b !== void 0 && (b.matrixAutoUpdate === !0 && b.updateMatrix(), p.uvTransform.value.copy(b.matrix))
            }

            function o(p, _) {
                p.diffuse.value.copy(_.color), p.opacity.value = _.opacity, p.rotation.value = _.rotation, _.map && (p.map.value = _.map), _.alphaMap && (p.alphaMap.value = _.alphaMap), _.alphaTest > 0 && (p.alphaTest.value = _.alphaTest);
                let M;
                _.map ? M = _.map : _.alphaMap && (M = _.alphaMap), M !== void 0 && (M.matrixAutoUpdate === !0 && M.updateMatrix(), p.uvTransform.value.copy(M.matrix))
            }

            function l(p, _) {
                _.emissiveMap && (p.emissiveMap.value = _.emissiveMap)
            }

            function c(p, _) {
                p.specular.value.copy(_.specular), p.shininess.value = Math.max(_.shininess, 1e-4), _.emissiveMap && (p.emissiveMap.value = _.emissiveMap), _.bumpMap && (p.bumpMap.value = _.bumpMap, p.bumpScale.value = _.bumpScale, _.side === nt && (p.bumpScale.value *= -1)), _.normalMap && (p.normalMap.value = _.normalMap, p.normalScale.value.copy(_.normalScale), _.side === nt && p.normalScale.value.negate()), _.displacementMap && (p.displacementMap.value = _.displacementMap, p.displacementScale.value = _.displacementScale, p.displacementBias.value = _.displacementBias)
            }

            function u(p, _) {
                _.gradientMap && (p.gradientMap.value = _.gradientMap), _.emissiveMap && (p.emissiveMap.value = _.emissiveMap), _.bumpMap && (p.bumpMap.value = _.bumpMap, p.bumpScale.value = _.bumpScale, _.side === nt && (p.bumpScale.value *= -1)), _.normalMap && (p.normalMap.value = _.normalMap, p.normalScale.value.copy(_.normalScale), _.side === nt && p.normalScale.value.negate()), _.displacementMap && (p.displacementMap.value = _.displacementMap, p.displacementScale.value = _.displacementScale, p.displacementBias.value = _.displacementBias)
            }

            function h(p, _) {
                p.roughness.value = _.roughness, p.metalness.value = _.metalness, _.roughnessMap && (p.roughnessMap.value = _.roughnessMap), _.metalnessMap && (p.metalnessMap.value = _.metalnessMap), _.emissiveMap && (p.emissiveMap.value = _.emissiveMap), _.bumpMap && (p.bumpMap.value = _.bumpMap, p.bumpScale.value = _.bumpScale, _.side === nt && (p.bumpScale.value *= -1)), _.normalMap && (p.normalMap.value = _.normalMap, p.normalScale.value.copy(_.normalScale), _.side === nt && p.normalScale.value.negate()), _.displacementMap && (p.displacementMap.value = _.displacementMap, p.displacementScale.value = _.displacementScale, p.displacementBias.value = _.displacementBias), a.get(_).envMap && (p.envMapIntensity.value = _.envMapIntensity)
            }

            function f(p, _, M) {
                h(p, _), p.ior.value = _.ior, _.sheen > 0 && (p.sheenTint.value.copy(_.sheenTint).multiplyScalar(_.sheen), p.sheenRoughness.value = _.sheenRoughness), _.clearcoat > 0 && (p.clearcoat.value = _.clearcoat, p.clearcoatRoughness.value = _.clearcoatRoughness, _.clearcoatMap && (p.clearcoatMap.value = _.clearcoatMap), _.clearcoatRoughnessMap && (p.clearcoatRoughnessMap.value = _.clearcoatRoughnessMap), _.clearcoatNormalMap && (p.clearcoatNormalScale.value.copy(_.clearcoatNormalScale), p.clearcoatNormalMap.value = _.clearcoatNormalMap, _.side === nt && p.clearcoatNormalScale.value.negate())), _.transmission > 0 && (p.transmission.value = _.transmission, p.transmissionSamplerMap.value = M.texture, p.transmissionSamplerSize.value.set(M.width, M.height), _.transmissionMap && (p.transmissionMap.value = _.transmissionMap), p.thickness.value = _.thickness, _.thicknessMap && (p.thicknessMap.value = _.thicknessMap), p.attenuationDistance.value = _.attenuationDistance, p.attenuationTint.value.copy(_.attenuationTint)), p.specularIntensity.value = _.specularIntensity, p.specularTint.value.copy(_.specularTint), _.specularIntensityMap && (p.specularIntensityMap.value = _.specularIntensityMap), _.specularTintMap && (p.specularTintMap.value = _.specularTintMap)
            }

            function d(p, _) {
                _.matcap && (p.matcap.value = _.matcap), _.bumpMap && (p.bumpMap.value = _.bumpMap, p.bumpScale.value = _.bumpScale, _.side === nt && (p.bumpScale.value *= -1)), _.normalMap && (p.normalMap.value = _.normalMap, p.normalScale.value.copy(_.normalScale), _.side === nt && p.normalScale.value.negate()), _.displacementMap && (p.displacementMap.value = _.displacementMap, p.displacementScale.value = _.displacementScale, p.displacementBias.value = _.displacementBias)
            }

            function m(p, _) {
                _.displacementMap && (p.displacementMap.value = _.displacementMap, p.displacementScale.value = _.displacementScale, p.displacementBias.value = _.displacementBias)
            }

            function g(p, _) {
                _.displacementMap && (p.displacementMap.value = _.displacementMap, p.displacementScale.value = _.displacementScale, p.displacementBias.value = _.displacementBias), p.referencePosition.value.copy(_.referencePosition), p.nearDistance.value = _.nearDistance, p.farDistance.value = _.farDistance
            }

            function v(p, _) {
                _.bumpMap && (p.bumpMap.value = _.bumpMap, p.bumpScale.value = _.bumpScale, _.side === nt && (p.bumpScale.value *= -1)), _.normalMap && (p.normalMap.value = _.normalMap, p.normalScale.value.copy(_.normalScale), _.side === nt && p.normalScale.value.negate()), _.displacementMap && (p.displacementMap.value = _.displacementMap, p.displacementScale.value = _.displacementScale, p.displacementBias.value = _.displacementBias)
            }
            return {
                refreshFogUniforms: e,
                refreshMaterialUniforms: t
            }
        }

        function Ev() {
            const a = ea("canvas");
            return a.style.display = "block", a
        }

        function He(a = {}) {
            const e = a.canvas !== void 0 ? a.canvas : Ev(),
                t = a.context !== void 0 ? a.context : null,
                n = a.alpha !== void 0 ? a.alpha : !1,
                i = a.depth !== void 0 ? a.depth : !0,
                r = a.stencil !== void 0 ? a.stencil : !0,
                s = a.antialias !== void 0 ? a.antialias : !1,
                o = a.premultipliedAlpha !== void 0 ? a.premultipliedAlpha : !0,
                l = a.preserveDrawingBuffer !== void 0 ? a.preserveDrawingBuffer : !1,
                c = a.powerPreference !== void 0 ? a.powerPreference : "default",
                u = a.failIfMajorPerformanceCaveat !== void 0 ? a.failIfMajorPerformanceCaveat : !1;
            let h = null,
                f = null;
            const d = [],
                m = [];
            this.domElement = e, this.debug = {
                checkShaderErrors: !0
            }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.outputEncoding = vt, this.physicallyCorrectLights = !1, this.toneMapping = xi, this.toneMappingExposure = 1;
            const g = this;
            let v = !1,
                p = 0,
                _ = 0,
                M = null,
                y = -1,
                b = null;
            const T = new Ue,
                x = new Ue;
            let R = null,
                P = e.width,
                I = e.height,
                L = 1,
                Y = null,
                D = null;
            const F = new Ue(0, 0, P, I),
                N = new Ue(0, 0, P, I);
            let z = !1;
            const k = [],
                J = new ya;
            let oe = !1,
                he = !1,
                ie = null;
            const be = new fe,
                W = new E,
                $ = {
                    background: null,
                    fog: null,
                    environment: null,
                    overrideMaterial: null,
                    isScene: !0
                };

            function me() {
                return M === null ? L : 1
            }
            let G = t;

            function xe(w, B) {
                for (let U = 0; U < w.length; U++) {
                    const O = w[U],
                        q = e.getContext(O, B);
                    if (q !== null) return q
                }
                return null
            }
            try {
                const w = {
                    alpha: n,
                    depth: i,
                    stencil: r,
                    antialias: s,
                    premultipliedAlpha: o,
                    preserveDrawingBuffer: l,
                    powerPreference: c,
                    failIfMajorPerformanceCaveat: u
                };
                if (e.addEventListener("webglcontextlost", St, !1), e.addEventListener("webglcontextrestored", Tt, !1), G === null) {
                    const B = ["webgl2", "webgl", "experimental-webgl"];
                    if (g.isWebGL1Renderer === !0 && B.shift(), G = xe(B, w), G === null) throw xe(B) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
                }
                G.getShaderPrecisionFormat === void 0 && (G.getShaderPrecisionFormat = function() {
                    return {
                        rangeMin: 1,
                        rangeMax: 1,
                        precision: 1
                    }
                })
            } catch (w) {
                throw console.error("THREE.WebGLRenderer: " + w.message), w
            }
            let Se, le, de, Le, V, Z, te, ge, se, A, S, H, K, Q, ce, we, ve, Ee, _e, C, ae, j, ue;

            function pe() {
                Se = new Z0(G), le = new H0(G, Se, a), Se.init(le), j = new bv(G, Se, le), de = new yv(G, Se, le), k[0] = 1029, Le = new K0(G), V = new cv, Z = new Mv(G, Se, de, V, le, j, Le), te = new W0(g), ge = new Y0(g), se = new Wm(G, le), ue = new k0(G, Se, se, le), A = new J0(G, se, Le, ue), S = new n_(G, A, se, Le), _e = new t_(G, le, Z), we = new V0(V), H = new lv(g, te, ge, Se, le, ue, we), K = new Tv(V), Q = new hv(V), ce = new _v(Se, le), Ee = new U0(g, te, de, S, o), ve = new $u(g, S, le), C = new G0(G, Se, Le, le), ae = new $0(G, Se, Le, le), Le.programs = H.programs, g.capabilities = le, g.extensions = Se, g.properties = V, g.renderLists = Q, g.shadowMap = ve, g.state = de, g.info = Le
            }
            pe();
            const Pe = new Sv(g, G);
            this.xr = Pe, this.getContext = function() {
                return G
            }, this.getContextAttributes = function() {
                return G.getContextAttributes()
            }, this.forceContextLoss = function() {
                const w = Se.get("WEBGL_lose_context");
                w && w.loseContext()
            }, this.forceContextRestore = function() {
                const w = Se.get("WEBGL_lose_context");
                w && w.restoreContext()
            }, this.getPixelRatio = function() {
                return L
            }, this.setPixelRatio = function(w) {
                w !== void 0 && (L = w, this.setSize(P, I, !1))
            }, this.getSize = function(w) {
                return w.set(P, I)
            }, this.setSize = function(w, B, U) {
                if (Pe.isPresenting) {
                    console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
                    return
                }
                P = w, I = B, e.width = Math.floor(w * L), e.height = Math.floor(B * L), U !== !1 && (e.style.width = w + "px", e.style.height = B + "px"), this.setViewport(0, 0, w, B)
            }, this.getDrawingBufferSize = function(w) {
                return w.set(P * L, I * L).floor()
            }, this.setDrawingBufferSize = function(w, B, U) {
                P = w, I = B, L = U, e.width = Math.floor(w * U), e.height = Math.floor(B * U), this.setViewport(0, 0, w, B)
            }, this.getCurrentViewport = function(w) {
                return w.copy(T)
            }, this.getViewport = function(w) {
                return w.copy(F)
            }, this.setViewport = function(w, B, U, O) {
                w.isVector4 ? F.set(w.x, w.y, w.z, w.w) : F.set(w, B, U, O), de.viewport(T.copy(F).multiplyScalar(L).floor())
            }, this.getScissor = function(w) {
                return w.copy(N)
            }, this.setScissor = function(w, B, U, O) {
                w.isVector4 ? N.set(w.x, w.y, w.z, w.w) : N.set(w, B, U, O), de.scissor(x.copy(N).multiplyScalar(L).floor())
            }, this.getScissorTest = function() {
                return z
            }, this.setScissorTest = function(w) {
                de.setScissorTest(z = w)
            }, this.setOpaqueSort = function(w) {
                Y = w
            }, this.setTransparentSort = function(w) {
                D = w
            }, this.getClearColor = function(w) {
                return w.copy(Ee.getClearColor())
            }, this.setClearColor = function() {
                Ee.setClearColor.apply(Ee, arguments)
            }, this.getClearAlpha = function() {
                return Ee.getClearAlpha()
            }, this.setClearAlpha = function() {
                Ee.setClearAlpha.apply(Ee, arguments)
            }, this.clear = function(w, B, U) {
                let O = 0;
                (w === void 0 || w) && (O |= 16384), (B === void 0 || B) && (O |= 256), (U === void 0 || U) && (O |= 1024), G.clear(O)
            }, this.clearColor = function() {
                this.clear(!0, !1, !1)
            }, this.clearDepth = function() {
                this.clear(!1, !0, !1)
            }, this.clearStencil = function() {
                this.clear(!1, !1, !0)
            }, this.dispose = function() {
                e.removeEventListener("webglcontextlost", St, !1), e.removeEventListener("webglcontextrestored", Tt, !1), Q.dispose(), ce.dispose(), V.dispose(), te.dispose(), ge.dispose(), S.dispose(), ue.dispose(), Pe.dispose(), Pe.removeEventListener("sessionstart", Cd), Pe.removeEventListener("sessionend", Pd), ie && (ie.dispose(), ie = null), Oi.stop()
            };

            function St(w) {
                w.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), v = !0
            }

            function Tt() {
                console.log("THREE.WebGLRenderer: Context Restored."), v = !1;
                const w = Le.autoReset,
                    B = ve.enabled,
                    U = ve.autoUpdate,
                    O = ve.needsUpdate,
                    q = ve.type;
                pe(), Le.autoReset = w, ve.enabled = B, ve.autoUpdate = U, ve.needsUpdate = O, ve.type = q
            }

            function gi(w) {
                const B = w.target;
                B.removeEventListener("dispose", gi), tt(B)
            }

            function tt(w) {
                Nn(w), V.remove(w)
            }

            function Nn(w) {
                const B = V.get(w).programs;
                B !== void 0 && B.forEach(function(U) {
                    H.releaseProgram(U)
                })
            }

            function Bn(w, B) {
                w.render(function(U) {
                    g.renderBufferImmediate(U, B)
                })
            }
            this.renderBufferImmediate = function(w, B) {
                ue.initAttributes();
                const U = V.get(w);
                w.hasPositions && !U.position && (U.position = G.createBuffer()), w.hasNormals && !U.normal && (U.normal = G.createBuffer()), w.hasUvs && !U.uv && (U.uv = G.createBuffer()), w.hasColors && !U.color && (U.color = G.createBuffer());
                const O = B.getAttributes();
                w.hasPositions && (G.bindBuffer(34962, U.position), G.bufferData(34962, w.positionArray, 35048), ue.enableAttribute(O.position.location), G.vertexAttribPointer(O.position.location, 3, 5126, !1, 0, 0)), w.hasNormals && (G.bindBuffer(34962, U.normal), G.bufferData(34962, w.normalArray, 35048), ue.enableAttribute(O.normal.location), G.vertexAttribPointer(O.normal.location, 3, 5126, !1, 0, 0)), w.hasUvs && (G.bindBuffer(34962, U.uv), G.bufferData(34962, w.uvArray, 35048), ue.enableAttribute(O.uv.location), G.vertexAttribPointer(O.uv.location, 2, 5126, !1, 0, 0)), w.hasColors && (G.bindBuffer(34962, U.color), G.bufferData(34962, w.colorArray, 35048), ue.enableAttribute(O.color.location), G.vertexAttribPointer(O.color.location, 3, 5126, !1, 0, 0)), ue.disableUnusedAttributes(), G.drawArrays(4, 0, w.count), w.count = 0
            }, this.renderBufferDirect = function(w, B, U, O, q, Ae) {
                B === null && (B = $);
                const ye = q.isMesh && q.matrixWorld.determinant() < 0,
                    Me = zd(w, B, U, O, q);
                de.setMaterial(O, ye);
                let Ce = U.index;
                const Oe = U.attributes.position;
                if (Ce === null) {
                    if (Oe === void 0 || Oe.count === 0) return
                } else if (Ce.count === 0) return;
                let De = 1;
                O.wireframe === !0 && (Ce = A.getWireframeAttribute(U), De = 2), ue.setup(q, O, Me, U, Ce);
                let ze, $e = C;
                Ce !== null && (ze = se.get(Ce), $e = ae, $e.setIndex(ze));
                const Ui = Ce !== null ? Ce.count : Oe.count,
                    Ne = U.drawRange.start * De,
                    Vs = U.drawRange.count * De,
                    Xe = Ae !== null ? Ae.start * De : 0,
                    ki = Ae !== null ? Ae.count * De : 1 / 0,
                    Gi = Math.max(Ne, Xe),
                    Hi = Math.min(Ui, Ne + Vs, Xe + ki) - 1,
                    _i = Math.max(0, Hi - Gi + 1);
                if (_i !== 0) {
                    if (q.isMesh) O.wireframe === !0 ? (de.setLineWidth(O.wireframeLinewidth * me()), $e.setMode(1)) : $e.setMode(4);
                    else if (q.isLine) {
                        let Ke = O.linewidth;
                        Ke === void 0 && (Ke = 1), de.setLineWidth(Ke * me()), q.isLineSegments ? $e.setMode(1) : q.isLineLoop ? $e.setMode(2) : $e.setMode(3)
                    } else q.isPoints ? $e.setMode(0) : q.isSprite && $e.setMode(4);
                    if (q.isInstancedMesh) $e.renderInstances(Gi, _i, q.count);
                    else if (U.isInstancedBufferGeometry) {
                        const Ke = Math.min(U.instanceCount, U._maxInstanceCount);
                        $e.renderInstances(Gi, _i, Ke)
                    } else $e.render(Gi, _i)
                }
            }, this.compile = function(w, B) {
                f = ce.get(w), f.init(), m.push(f), w.traverseVisible(function(U) {
                    U.isLight && U.layers.test(B.layers) && (f.pushLight(U), U.castShadow && f.pushShadow(U))
                }), f.setupLights(g.physicallyCorrectLights), w.traverse(function(U) {
                    const O = U.material;
                    if (O)
                        if (Array.isArray(O))
                            for (let q = 0; q < O.length; q++) {
                                const Ae = O[q];
                                yc(Ae, w, U)
                            } else yc(O, w, U)
                }), m.pop(), f = null
            };
            let xc = null;

            function iM(w) {
                xc && xc(w)
            }

            function Cd() {
                Oi.stop()
            }

            function Pd() {
                Oi.start()
            }
            const Oi = new mu;
            Oi.setAnimationLoop(iM), typeof window != "undefined" && Oi.setContext(window), this.setAnimationLoop = function(w) {
                xc = w, Pe.setAnimationLoop(w), w === null ? Oi.stop() : Oi.start()
            }, Pe.addEventListener("sessionstart", Cd), Pe.addEventListener("sessionend", Pd), this.render = function(w, B) {
                if (B !== void 0 && B.isCamera !== !0) {
                    console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                    return
                }
                if (v === !0) return;
                w.autoUpdate === !0 && w.updateMatrixWorld(), B.parent === null && B.updateMatrixWorld(), Pe.enabled === !0 && Pe.isPresenting === !0 && (Pe.cameraAutoUpdate === !0 && Pe.updateCamera(B), B = Pe.getCamera()), w.isScene === !0 && w.onBeforeRender(g, w, B, M), f = ce.get(w, m.length), f.init(), m.push(f), be.multiplyMatrices(B.projectionMatrix, B.matrixWorldInverse), J.setFromProjectionMatrix(be), he = this.localClippingEnabled, oe = we.init(this.clippingPlanes, he, B), h = Q.get(w, d.length), h.init(), d.push(h), Dd(w, B, 0, g.sortObjects), h.finish(), g.sortObjects === !0 && h.sort(Y, D), oe === !0 && we.beginShadows();
                const U = f.state.shadowsArray;
                if (ve.render(U, w, B), oe === !0 && we.endShadows(), this.info.autoReset === !0 && this.info.reset(), Ee.render(h, w), f.setupLights(g.physicallyCorrectLights), B.isArrayCamera) {
                    const O = B.cameras;
                    for (let q = 0, Ae = O.length; q < Ae; q++) {
                        const ye = O[q];
                        Id(h, w, ye, ye.viewport)
                    }
                } else Id(h, w, B);
                M !== null && (Z.updateMultisampleRenderTarget(M), Z.updateRenderTargetMipmap(M)), w.isScene === !0 && w.onAfterRender(g, w, B), de.buffers.depth.setTest(!0), de.buffers.depth.setMask(!0), de.buffers.color.setMask(!0), de.setPolygonOffset(!1), ue.resetDefaultState(), y = -1, b = null, m.pop(), m.length > 0 ? f = m[m.length - 1] : f = null, d.pop(), d.length > 0 ? h = d[d.length - 1] : h = null
            };

            function Dd(w, B, U, O) {
                if (w.visible === !1) return;
                if (w.layers.test(B.layers)) {
                    if (w.isGroup) U = w.renderOrder;
                    else if (w.isLOD) w.autoUpdate === !0 && w.update(B);
                    else if (w.isLight) f.pushLight(w), w.castShadow && f.pushShadow(w);
                    else if (w.isSprite) {
                        if (!w.frustumCulled || J.intersectsSprite(w)) {
                            O && W.setFromMatrixPosition(w.matrixWorld).applyMatrix4(be);
                            const ye = S.update(w),
                                Me = w.material;
                            Me.visible && h.push(w, ye, Me, U, W.z, null)
                        }
                    } else if (w.isImmediateRenderObject) O && W.setFromMatrixPosition(w.matrixWorld).applyMatrix4(be), h.push(w, null, w.material, U, W.z, null);
                    else if ((w.isMesh || w.isLine || w.isPoints) && (w.isSkinnedMesh && w.skeleton.frame !== Le.render.frame && (w.skeleton.update(), w.skeleton.frame = Le.render.frame), !w.frustumCulled || J.intersectsObject(w))) {
                        O && W.setFromMatrixPosition(w.matrixWorld).applyMatrix4(be);
                        const ye = S.update(w),
                            Me = w.material;
                        if (Array.isArray(Me)) {
                            const Ce = ye.groups;
                            for (let Oe = 0, De = Ce.length; Oe < De; Oe++) {
                                const ze = Ce[Oe],
                                    $e = Me[ze.materialIndex];
                                $e && $e.visible && h.push(w, ye, $e, U, W.z, ze)
                            }
                        } else Me.visible && h.push(w, ye, Me, U, W.z, null)
                    }
                }
                const Ae = w.children;
                for (let ye = 0, Me = Ae.length; ye < Me; ye++) Dd(Ae[ye], B, U, O)
            }

            function Id(w, B, U, O) {
                const q = w.opaque,
                    Ae = w.transmissive,
                    ye = w.transparent;
                f.setupLightsView(U), Ae.length > 0 && rM(q, B, U), O && de.viewport(T.copy(O)), q.length > 0 && eo(q, B, U), Ae.length > 0 && eo(Ae, B, U), ye.length > 0 && eo(ye, B, U)
            }

            function rM(w, B, U) {
                if (ie === null) {
                    const ye = s === !0 && le.isWebGL2 === !0 ? Qc : Dt;
                    ie = new ye(1024, 1024, {
                        generateMipmaps: !0,
                        type: j.convert(Xi) !== null ? Xi : Un,
                        minFilter: qi,
                        magFilter: st,
                        wrapS: Ct,
                        wrapT: Ct
                    })
                }
                const O = g.getRenderTarget();
                g.setRenderTarget(ie), g.clear();
                const q = g.toneMapping;
                g.toneMapping = xi, eo(w, B, U), g.toneMapping = q, Z.updateMultisampleRenderTarget(ie), Z.updateRenderTargetMipmap(ie), g.setRenderTarget(O)
            }

            function eo(w, B, U) {
                const O = B.isScene === !0 ? B.overrideMaterial : null;
                for (let q = 0, Ae = w.length; q < Ae; q++) {
                    const ye = w[q],
                        Me = ye.object,
                        Ce = ye.geometry,
                        Oe = O === null ? ye.material : O,
                        De = ye.group;
                    Me.layers.test(U.layers) && sM(Me, B, U, Ce, Oe, De)
                }
            }

            function sM(w, B, U, O, q, Ae) {
                if (w.onBeforeRender(g, B, U, O, q, Ae), w.modelViewMatrix.multiplyMatrices(U.matrixWorldInverse, w.matrixWorld), w.normalMatrix.getNormalMatrix(w.modelViewMatrix), q.onBeforeRender(g, B, U, O, w, Ae), w.isImmediateRenderObject) {
                    const ye = zd(U, B, O, q, w);
                    de.setMaterial(q), ue.reset(), Bn(w, ye)
                } else q.transparent === !0 && q.side === vi ? (q.side = nt, q.needsUpdate = !0, g.renderBufferDirect(U, B, O, q, w, Ae), q.side = Vi, q.needsUpdate = !0, g.renderBufferDirect(U, B, O, q, w, Ae), q.side = vi) : g.renderBufferDirect(U, B, O, q, w, Ae);
                w.onAfterRender(g, B, U, O, q, Ae)
            }

            function yc(w, B, U) {
                B.isScene !== !0 && (B = $);
                const O = V.get(w),
                    q = f.state.lights,
                    Ae = f.state.shadowsArray,
                    ye = q.state.version,
                    Me = H.getParameters(w, q.state, Ae, B, U),
                    Ce = H.getProgramCacheKey(Me);
                let Oe = O.programs;
                O.environment = w.isMeshStandardMaterial ? B.environment : null, O.fog = B.fog, O.envMap = (w.isMeshStandardMaterial ? ge : te).get(w.envMap || O.environment), Oe === void 0 && (w.addEventListener("dispose", gi), Oe = new Map, O.programs = Oe);
                let De = Oe.get(Ce);
                if (De !== void 0) {
                    if (O.currentProgram === De && O.lightsStateVersion === ye) return Fd(w, Me), De
                } else Me.uniforms = H.getUniforms(w), w.onBuild(Me, g), w.onBeforeCompile(Me, g), De = H.acquireProgram(Me, Ce), Oe.set(Ce, De), O.uniforms = Me.uniforms;
                const ze = O.uniforms;
                (!w.isShaderMaterial && !w.isRawShaderMaterial || w.clipping === !0) && (ze.clippingPlanes = we.uniform), Fd(w, Me), O.needsLights = oM(w), O.lightsStateVersion = ye, O.needsLights && (ze.ambientLightColor.value = q.state.ambient, ze.lightProbe.value = q.state.probe, ze.directionalLights.value = q.state.directional, ze.directionalLightShadows.value = q.state.directionalShadow, ze.spotLights.value = q.state.spot, ze.spotLightShadows.value = q.state.spotShadow, ze.rectAreaLights.value = q.state.rectArea, ze.ltc_1.value = q.state.rectAreaLTC1, ze.ltc_2.value = q.state.rectAreaLTC2, ze.pointLights.value = q.state.point, ze.pointLightShadows.value = q.state.pointShadow, ze.hemisphereLights.value = q.state.hemi, ze.directionalShadowMap.value = q.state.directionalShadowMap, ze.directionalShadowMatrix.value = q.state.directionalShadowMatrix, ze.spotShadowMap.value = q.state.spotShadowMap, ze.spotShadowMatrix.value = q.state.spotShadowMatrix, ze.pointShadowMap.value = q.state.pointShadowMap, ze.pointShadowMatrix.value = q.state.pointShadowMatrix);
                const $e = De.getUniforms(),
                    Ui = Kn.seqWithValue($e.seq, ze);
                return O.currentProgram = De, O.uniformsList = Ui, De
            }

            function Fd(w, B) {
                const U = V.get(w);
                U.outputEncoding = B.outputEncoding, U.instancing = B.instancing, U.skinning = B.skinning, U.morphTargets = B.morphTargets, U.morphNormals = B.morphNormals, U.morphTargetsCount = B.morphTargetsCount, U.numClippingPlanes = B.numClippingPlanes, U.numIntersection = B.numClipIntersection, U.vertexAlphas = B.vertexAlphas, U.vertexTangents = B.vertexTangents
            }

            function zd(w, B, U, O, q) {
                B.isScene !== !0 && (B = $), Z.resetTextureUnits();
                const Ae = B.fog,
                    ye = O.isMeshStandardMaterial ? B.environment : null,
                    Me = M === null ? g.outputEncoding : M.texture.encoding,
                    Ce = (O.isMeshStandardMaterial ? ge : te).get(O.envMap || ye),
                    Oe = O.vertexColors === !0 && !!U && !!U.attributes.color && U.attributes.color.itemSize === 4,
                    De = !!O.normalMap && !!U && !!U.attributes.tangent,
                    ze = !!U && !!U.morphAttributes.position,
                    $e = !!U && !!U.morphAttributes.normal,
                    Ui = !!U && !!U.morphAttributes.position ? U.morphAttributes.position.length : 0,
                    Ne = V.get(O),
                    Vs = f.state.lights;
                if (oe === !0 && (he === !0 || w !== b)) {
                    const cn = w === b && O.id === y;
                    we.setState(O, w, cn)
                }
                let Xe = !1;
                O.version === Ne.__version ? (Ne.needsLights && Ne.lightsStateVersion !== Vs.state.version || Ne.outputEncoding !== Me || q.isInstancedMesh && Ne.instancing === !1 || !q.isInstancedMesh && Ne.instancing === !0 || q.isSkinnedMesh && Ne.skinning === !1 || !q.isSkinnedMesh && Ne.skinning === !0 || Ne.envMap !== Ce || O.fog && Ne.fog !== Ae || Ne.numClippingPlanes !== void 0 && (Ne.numClippingPlanes !== we.numPlanes || Ne.numIntersection !== we.numIntersection) || Ne.vertexAlphas !== Oe || Ne.vertexTangents !== De || Ne.morphTargets !== ze || Ne.morphNormals !== $e || le.isWebGL2 === !0 && Ne.morphTargetsCount !== Ui) && (Xe = !0) : (Xe = !0, Ne.__version = O.version);
                let ki = Ne.currentProgram;
                Xe === !0 && (ki = yc(O, B, q));
                let Gi = !1,
                    Hi = !1,
                    _i = !1;
                const Ke = ki.getUniforms(),
                    Ws = Ne.uniforms;
                if (de.useProgram(ki.program) && (Gi = !0, Hi = !0, _i = !0), O.id !== y && (y = O.id, Hi = !0), Gi || b !== w) {
                    if (Ke.setValue(G, "projectionMatrix", w.projectionMatrix), le.logarithmicDepthBuffer && Ke.setValue(G, "logDepthBufFC", 2 / (Math.log(w.far + 1) / Math.LN2)), b !== w && (b = w, Hi = !0, _i = !0), O.isShaderMaterial || O.isMeshPhongMaterial || O.isMeshToonMaterial || O.isMeshStandardMaterial || O.envMap) {
                        const cn = Ke.map.cameraPosition;
                        cn !== void 0 && cn.setValue(G, W.setFromMatrixPosition(w.matrixWorld))
                    }(O.isMeshPhongMaterial || O.isMeshToonMaterial || O.isMeshLambertMaterial || O.isMeshBasicMaterial || O.isMeshStandardMaterial || O.isShaderMaterial) && Ke.setValue(G, "isOrthographic", w.isOrthographicCamera === !0), (O.isMeshPhongMaterial || O.isMeshToonMaterial || O.isMeshLambertMaterial || O.isMeshBasicMaterial || O.isMeshStandardMaterial || O.isShaderMaterial || O.isShadowMaterial || q.isSkinnedMesh) && Ke.setValue(G, "viewMatrix", w.matrixWorldInverse)
                }
                if (q.isSkinnedMesh) {
                    Ke.setOptional(G, q, "bindMatrix"), Ke.setOptional(G, q, "bindMatrixInverse");
                    const cn = q.skeleton;
                    cn && (le.floatVertexTextures ? (cn.boneTexture === null && cn.computeBoneTexture(), Ke.setValue(G, "boneTexture", cn.boneTexture, Z), Ke.setValue(G, "boneTextureSize", cn.boneTextureSize)) : Ke.setOptional(G, cn, "boneMatrices"))
                }
                return !!U && (U.morphAttributes.position !== void 0 || U.morphAttributes.normal !== void 0) && _e.update(q, U, O, ki), (Hi || Ne.receiveShadow !== q.receiveShadow) && (Ne.receiveShadow = q.receiveShadow, Ke.setValue(G, "receiveShadow", q.receiveShadow)), Hi && (Ke.setValue(G, "toneMappingExposure", g.toneMappingExposure), Ne.needsLights && aM(Ws, _i), Ae && O.fog && K.refreshFogUniforms(Ws, Ae), K.refreshMaterialUniforms(Ws, O, L, I, ie), Kn.upload(G, Ne.uniformsList, Ws, Z)), O.isShaderMaterial && O.uniformsNeedUpdate === !0 && (Kn.upload(G, Ne.uniformsList, Ws, Z), O.uniformsNeedUpdate = !1), O.isSpriteMaterial && Ke.setValue(G, "center", q.center), Ke.setValue(G, "modelViewMatrix", q.modelViewMatrix), Ke.setValue(G, "normalMatrix", q.normalMatrix), Ke.setValue(G, "modelMatrix", q.matrixWorld), ki
            }

            function aM(w, B) {
                w.ambientLightColor.needsUpdate = B, w.lightProbe.needsUpdate = B, w.directionalLights.needsUpdate = B, w.directionalLightShadows.needsUpdate = B, w.pointLights.needsUpdate = B, w.pointLightShadows.needsUpdate = B, w.spotLights.needsUpdate = B, w.spotLightShadows.needsUpdate = B, w.rectAreaLights.needsUpdate = B, w.hemisphereLights.needsUpdate = B
            }

            function oM(w) {
                return w.isMeshLambertMaterial || w.isMeshToonMaterial || w.isMeshPhongMaterial || w.isMeshStandardMaterial || w.isShadowMaterial || w.isShaderMaterial && w.lights === !0
            }
            this.getActiveCubeFace = function() {
                return p
            }, this.getActiveMipmapLevel = function() {
                return _
            }, this.getRenderTarget = function() {
                return M
            }, this.setRenderTarget = function(w, B = 0, U = 0) {
                M = w, p = B, _ = U, w && V.get(w).__webglFramebuffer === void 0 && Z.setupRenderTarget(w);
                let O = null,
                    q = !1,
                    Ae = !1;
                if (w) {
                    const Me = w.texture;
                    (Me.isDataTexture3D || Me.isDataTexture2DArray) && (Ae = !0);
                    const Ce = V.get(w).__webglFramebuffer;
                    w.isWebGLCubeRenderTarget ? (O = Ce[B], q = !0) : w.isWebGLMultisampleRenderTarget ? O = V.get(w).__webglMultisampledFramebuffer : O = Ce, T.copy(w.viewport), x.copy(w.scissor), R = w.scissorTest
                } else T.copy(F).multiplyScalar(L).floor(), x.copy(N).multiplyScalar(L).floor(), R = z;
                if (de.bindFramebuffer(36160, O) && le.drawBuffers) {
                    let Me = !1;
                    if (w)
                        if (w.isWebGLMultipleRenderTargets) {
                            const Ce = w.texture;
                            if (k.length !== Ce.length || k[0] !== 36064) {
                                for (let Oe = 0, De = Ce.length; Oe < De; Oe++) k[Oe] = 36064 + Oe;
                                k.length = Ce.length, Me = !0
                            }
                        } else(k.length !== 1 || k[0] !== 36064) && (k[0] = 36064, k.length = 1, Me = !0);
                    else(k.length !== 1 || k[0] !== 1029) && (k[0] = 1029, k.length = 1, Me = !0);
                    Me && (le.isWebGL2 ? G.drawBuffers(k) : Se.get("WEBGL_draw_buffers").drawBuffersWEBGL(k))
                }
                if (de.viewport(T), de.scissor(x), de.setScissorTest(R), q) {
                    const Me = V.get(w.texture);
                    G.framebufferTexture2D(36160, 36064, 34069 + B, Me.__webglTexture, U)
                } else if (Ae) {
                    const Me = V.get(w.texture),
                        Ce = B || 0;
                    G.framebufferTextureLayer(36160, 36064, Me.__webglTexture, U || 0, Ce)
                }
                y = -1
            }, this.readRenderTargetPixels = function(w, B, U, O, q, Ae, ye) {
                if (!(w && w.isWebGLRenderTarget)) {
                    console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                    return
                }
                let Me = V.get(w).__webglFramebuffer;
                if (w.isWebGLCubeRenderTarget && ye !== void 0 && (Me = Me[ye]), Me) {
                    de.bindFramebuffer(36160, Me);
                    try {
                        const Ce = w.texture,
                            Oe = Ce.format,
                            De = Ce.type;
                        if (Oe !== ct && j.convert(Oe) !== G.getParameter(35739)) {
                            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                            return
                        }
                        const ze = De === Xi && (Se.has("EXT_color_buffer_half_float") || le.isWebGL2 && Se.has("EXT_color_buffer_float"));
                        if (De !== Un && j.convert(De) !== G.getParameter(35738) && !(De === yn && (le.isWebGL2 || Se.has("OES_texture_float") || Se.has("WEBGL_color_buffer_float"))) && !ze) {
                            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                            return
                        }
                        G.checkFramebufferStatus(36160) === 36053 ? B >= 0 && B <= w.width - O && U >= 0 && U <= w.height - q && G.readPixels(B, U, O, q, j.convert(Oe), j.convert(De), Ae) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                    } finally {
                        const Ce = M !== null ? V.get(M).__webglFramebuffer : null;
                        de.bindFramebuffer(36160, Ce)
                    }
                }
            }, this.copyFramebufferToTexture = function(w, B, U = 0) {
                const O = Math.pow(2, -U),
                    q = Math.floor(B.image.width * O),
                    Ae = Math.floor(B.image.height * O);
                let ye = j.convert(B.format);
                le.isWebGL2 && (ye === 6407 && (ye = 32849), ye === 6408 && (ye = 32856)), Z.setTexture2D(B, 0), G.copyTexImage2D(3553, U, ye, w.x, w.y, q, Ae, 0), de.unbindTexture()
            }, this.copyTextureToTexture = function(w, B, U, O = 0) {
                const q = B.image.width,
                    Ae = B.image.height,
                    ye = j.convert(U.format),
                    Me = j.convert(U.type);
                Z.setTexture2D(U, 0), G.pixelStorei(37440, U.flipY), G.pixelStorei(37441, U.premultiplyAlpha), G.pixelStorei(3317, U.unpackAlignment), B.isDataTexture ? G.texSubImage2D(3553, O, w.x, w.y, q, Ae, ye, Me, B.image.data) : B.isCompressedTexture ? G.compressedTexSubImage2D(3553, O, w.x, w.y, B.mipmaps[0].width, B.mipmaps[0].height, ye, B.mipmaps[0].data) : G.texSubImage2D(3553, O, w.x, w.y, ye, Me, B.image), O === 0 && U.generateMipmaps && G.generateMipmap(3553), de.unbindTexture()
            }, this.copyTextureToTexture3D = function(w, B, U, O, q = 0) {
                if (g.isWebGL1Renderer) {
                    console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
                    return
                }
                const Ae = w.max.x - w.min.x + 1,
                    ye = w.max.y - w.min.y + 1,
                    Me = w.max.z - w.min.z + 1,
                    Ce = j.convert(O.format),
                    Oe = j.convert(O.type);
                let De;
                if (O.isDataTexture3D) Z.setTexture3D(O, 0), De = 32879;
                else if (O.isDataTexture2DArray) Z.setTexture2DArray(O, 0), De = 35866;
                else {
                    console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
                    return
                }
                G.pixelStorei(37440, O.flipY), G.pixelStorei(37441, O.premultiplyAlpha), G.pixelStorei(3317, O.unpackAlignment);
                const ze = G.getParameter(3314),
                    $e = G.getParameter(32878),
                    Ui = G.getParameter(3316),
                    Ne = G.getParameter(3315),
                    Vs = G.getParameter(32877),
                    Xe = U.isCompressedTexture ? U.mipmaps[0] : U.image;
                G.pixelStorei(3314, Xe.width), G.pixelStorei(32878, Xe.height), G.pixelStorei(3316, w.min.x), G.pixelStorei(3315, w.min.y), G.pixelStorei(32877, w.min.z), U.isDataTexture || U.isDataTexture3D ? G.texSubImage3D(De, q, B.x, B.y, B.z, Ae, ye, Me, Ce, Oe, Xe.data) : U.isCompressedTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), G.compressedTexSubImage3D(De, q, B.x, B.y, B.z, Ae, ye, Me, Ce, Xe.data)) : G.texSubImage3D(De, q, B.x, B.y, B.z, Ae, ye, Me, Ce, Oe, Xe), G.pixelStorei(3314, ze), G.pixelStorei(32878, $e), G.pixelStorei(3316, Ui), G.pixelStorei(3315, Ne), G.pixelStorei(32877, Vs), q === 0 && O.generateMipmaps && G.generateMipmap(De), de.unbindTexture()
            }, this.initTexture = function(w) {
                Z.setTexture2D(w, 0), de.unbindTexture()
            }, this.resetState = function() {
                p = 0, _ = 0, M = null, de.reset(), ue.reset()
            }, typeof __THREE_DEVTOOLS__ != "undefined" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                detail: this
            }))
        }
        class Qu extends He {}
        Qu.prototype.isWebGL1Renderer = !0;
        class wa extends Te {
            constructor() {
                super();
                this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0, typeof __THREE_DEVTOOLS__ != "undefined" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                    detail: this
                }))
            }
            copy(e, t) {
                return super.copy(e, t), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.autoUpdate = e.autoUpdate, this.matrixAutoUpdate = e.matrixAutoUpdate, this
            }
            toJSON(e) {
                const t = super.toJSON(e);
                return this.fog !== null && (t.object.fog = this.fog.toJSON()), t
            }
        }
        wa.prototype.isScene = !0;
        class xr {
            constructor(e, t) {
                this.array = e, this.stride = t, this.count = e !== void 0 ? e.length / t : 0, this.usage = Mi, this.updateRange = {
                    offset: 0,
                    count: -1
                }, this.version = 0, this.uuid = Xt()
            }
            onUploadCallback() {}
            set needsUpdate(e) {
                e === !0 && this.version++
            }
            setUsage(e) {
                return this.usage = e, this
            }
            copy(e) {
                return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this
            }
            copyAt(e, t, n) {
                e *= this.stride, n *= t.stride;
                for (let i = 0, r = this.stride; i < r; i++) this.array[e + i] = t.array[n + i];
                return this
            }
            set(e, t = 0) {
                return this.array.set(e, t), this
            }
            clone(e) {
                e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Xt()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
                const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),
                    n = new this.constructor(t, this.stride);
                return n.setUsage(this.usage), n
            }
            onUpload(e) {
                return this.onUploadCallback = e, this
            }
            toJSON(e) {
                return e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Xt()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), {
                    uuid: this.uuid,
                    buffer: this.array.buffer._uuid,
                    type: this.array.constructor.name,
                    stride: this.stride
                }
            }
        }
        xr.prototype.isInterleavedBuffer = !0;
        const et = new E;
        class yr {
            constructor(e, t, n, i = !1) {
                this.name = "", this.data = e, this.itemSize = t, this.offset = n, this.normalized = i === !0
            }
            get count() {
                return this.data.count
            }
            get array() {
                return this.data.array
            }
            set needsUpdate(e) {
                this.data.needsUpdate = e
            }
            applyMatrix4(e) {
                for (let t = 0, n = this.data.count; t < n; t++) et.x = this.getX(t), et.y = this.getY(t), et.z = this.getZ(t), et.applyMatrix4(e), this.setXYZ(t, et.x, et.y, et.z);
                return this
            }
            applyNormalMatrix(e) {
                for (let t = 0, n = this.count; t < n; t++) et.x = this.getX(t), et.y = this.getY(t), et.z = this.getZ(t), et.applyNormalMatrix(e), this.setXYZ(t, et.x, et.y, et.z);
                return this
            }
            transformDirection(e) {
                for (let t = 0, n = this.count; t < n; t++) et.x = this.getX(t), et.y = this.getY(t), et.z = this.getZ(t), et.transformDirection(e), this.setXYZ(t, et.x, et.y, et.z);
                return this
            }
            setX(e, t) {
                return this.data.array[e * this.data.stride + this.offset] = t, this
            }
            setY(e, t) {
                return this.data.array[e * this.data.stride + this.offset + 1] = t, this
            }
            setZ(e, t) {
                return this.data.array[e * this.data.stride + this.offset + 2] = t, this
            }
            setW(e, t) {
                return this.data.array[e * this.data.stride + this.offset + 3] = t, this
            }
            getX(e) {
                return this.data.array[e * this.data.stride + this.offset]
            }
            getY(e) {
                return this.data.array[e * this.data.stride + this.offset + 1]
            }
            getZ(e) {
                return this.data.array[e * this.data.stride + this.offset + 2]
            }
            getW(e) {
                return this.data.array[e * this.data.stride + this.offset + 3]
            }
            setXY(e, t, n) {
                return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this
            }
            setXYZ(e, t, n, i) {
                return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = i, this
            }
            setXYZW(e, t, n, i, r) {
                return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = i, this.data.array[e + 3] = r, this
            }
            clone(e) {
                if (e === void 0) {
                    console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
                    const t = [];
                    for (let n = 0; n < this.count; n++) {
                        const i = n * this.data.stride + this.offset;
                        for (let r = 0; r < this.itemSize; r++) t.push(this.data.array[i + r])
                    }
                    return new Qe(new this.array.constructor(t), this.itemSize, this.normalized)
                } else return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new yr(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
            }
            toJSON(e) {
                if (e === void 0) {
                    console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
                    const t = [];
                    for (let n = 0; n < this.count; n++) {
                        const i = n * this.data.stride + this.offset;
                        for (let r = 0; r < this.itemSize; r++) t.push(this.data.array[i + r])
                    }
                    return {
                        itemSize: this.itemSize,
                        type: this.array.constructor.name,
                        array: t,
                        normalized: this.normalized
                    }
                } else return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
                    isInterleavedBufferAttribute: !0,
                    itemSize: this.itemSize,
                    data: this.data.uuid,
                    offset: this.offset,
                    normalized: this.normalized
                }
            }
        }
        yr.prototype.isInterleavedBufferAttribute = !0;
        class eh extends ot {
            constructor(e) {
                super();
                this.type = "SpriteMaterial", this.color = new ne(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.setValues(e)
            }
            copy(e) {
                return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this
            }
        }
        eh.prototype.isSpriteMaterial = !0;
        let Mr;
        const hs = new E,
            br = new E,
            wr = new E,
            Sr = new X,
            fs = new X,
            th = new fe,
            Sa = new E,
            ds = new E,
            Ta = new E,
            nh = new X,
            Jo = new X,
            ih = new X;
        class Av extends Te {
            constructor(e) {
                super();
                if (this.type = "Sprite", Mr === void 0) {
                    Mr = new ke;
                    const t = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]),
                        n = new xr(t, 5);
                    Mr.setIndex([0, 1, 2, 0, 2, 3]), Mr.setAttribute("position", new yr(n, 3, 0, !1)), Mr.setAttribute("uv", new yr(n, 2, 3, !1))
                }
                this.geometry = Mr, this.material = e !== void 0 ? e : new eh, this.center = new X(.5, .5)
            }
            raycast(e, t) {
                e.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), br.setFromMatrixScale(this.matrixWorld), th.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), wr.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && br.multiplyScalar(-wr.z);
                const n = this.material.rotation;
                let i, r;
                n !== 0 && (r = Math.cos(n), i = Math.sin(n));
                const s = this.center;
                Ea(Sa.set(-.5, -.5, 0), wr, s, br, i, r), Ea(ds.set(.5, -.5, 0), wr, s, br, i, r), Ea(Ta.set(.5, .5, 0), wr, s, br, i, r), nh.set(0, 0), Jo.set(1, 0), ih.set(1, 1);
                let o = e.ray.intersectTriangle(Sa, ds, Ta, !1, hs);
                if (o === null && (Ea(ds.set(-.5, .5, 0), wr, s, br, i, r), Jo.set(0, 1), o = e.ray.intersectTriangle(Sa, Ta, ds, !1, hs), o === null)) return;
                const l = e.ray.origin.distanceTo(hs);
                l < e.near || l > e.far || t.push({
                    distance: l,
                    point: hs.clone(),
                    uv: it.getUV(hs, Sa, ds, Ta, nh, Jo, ih, new X),
                    face: null,
                    object: this
                })
            }
            copy(e) {
                return super.copy(e), e.center !== void 0 && this.center.copy(e.center), this.material = e.material, this
            }
        }
        Av.prototype.isSprite = !0;

        function Ea(a, e, t, n, i, r) {
            Sr.subVectors(a, t).addScalar(.5).multiply(n), i !== void 0 ? (fs.x = r * Sr.x - i * Sr.y, fs.y = i * Sr.x + r * Sr.y) : fs.copy(Sr), a.copy(e), a.x += fs.x, a.y += fs.y, a.applyMatrix4(th)
        }
        const rh = new E,
            sh = new Ue,
            ah = new Ue,
            Lv = new E,
            oh = new fe;
        class $o extends Ge {
            constructor(e, t) {
                super(e, t);
                this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new fe, this.bindMatrixInverse = new fe
            }
            copy(e) {
                return super.copy(e), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, this
            }
            bind(e, t) {
                this.skeleton = e, t === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert()
            }
            pose() {
                this.skeleton.pose()
            }
            normalizeSkinWeights() {
                const e = new Ue,
                    t = this.geometry.attributes.skinWeight;
                for (let n = 0, i = t.count; n < i; n++) {
                    e.x = t.getX(n), e.y = t.getY(n), e.z = t.getZ(n), e.w = t.getW(n);
                    const r = 1 / e.manhattanLength();
                    r !== 1 / 0 ? e.multiplyScalar(r) : e.set(1, 0, 0, 0), t.setXYZW(n, e.x, e.y, e.z, e.w)
                }
            }
            updateMatrixWorld(e) {
                super.updateMatrixWorld(e), this.bindMode === "attached" ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === "detached" ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
            }
            boneTransform(e, t) {
                const n = this.skeleton,
                    i = this.geometry;
                sh.fromBufferAttribute(i.attributes.skinIndex, e), ah.fromBufferAttribute(i.attributes.skinWeight, e), rh.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0);
                for (let r = 0; r < 4; r++) {
                    const s = ah.getComponent(r);
                    if (s !== 0) {
                        const o = sh.getComponent(r);
                        oh.multiplyMatrices(n.bones[o].matrixWorld, n.boneInverses[o]), t.addScaledVector(Lv.copy(rh).applyMatrix4(oh), s)
                    }
                }
                return t.applyMatrix4(this.bindMatrixInverse)
            }
        }
        $o.prototype.isSkinnedMesh = !0;
        class Ko extends Te {
            constructor() {
                super();
                this.type = "Bone"
            }
        }
        Ko.prototype.isBone = !0;
        class lh extends at {
            constructor(e = null, t = 1, n = 1, i, r, s, o, l, c = st, u = st, h, f) {
                super(null, s, o, l, c, u, i, r, h, f);
                this.image = {
                    data: e,
                    width: t,
                    height: n
                }, this.magFilter = c, this.minFilter = u, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0
            }
        }
        lh.prototype.isDataTexture = !0;
        const ch = new fe,
            Rv = new fe;
        class Qo {
            constructor(e = [], t = []) {
                this.uuid = Xt(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init()
            }
            init() {
                const e = this.bones,
                    t = this.boneInverses;
                if (this.boneMatrices = new Float32Array(e.length * 16), t.length === 0) this.calculateInverses();
                else if (e.length !== t.length) {
                    console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
                    for (let n = 0, i = this.bones.length; n < i; n++) this.boneInverses.push(new fe)
                }
            }
            calculateInverses() {
                this.boneInverses.length = 0;
                for (let e = 0, t = this.bones.length; e < t; e++) {
                    const n = new fe;
                    this.bones[e] && n.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(n)
                }
            }
            pose() {
                for (let e = 0, t = this.bones.length; e < t; e++) {
                    const n = this.bones[e];
                    n && n.matrixWorld.copy(this.boneInverses[e]).invert()
                }
                for (let e = 0, t = this.bones.length; e < t; e++) {
                    const n = this.bones[e];
                    n && (n.parent && n.parent.isBone ? (n.matrix.copy(n.parent.matrixWorld).invert(), n.matrix.multiply(n.matrixWorld)) : n.matrix.copy(n.matrixWorld), n.matrix.decompose(n.position, n.quaternion, n.scale))
                }
            }
            update() {
                const e = this.bones,
                    t = this.boneInverses,
                    n = this.boneMatrices,
                    i = this.boneTexture;
                for (let r = 0, s = e.length; r < s; r++) {
                    const o = e[r] ? e[r].matrixWorld : Rv;
                    ch.multiplyMatrices(o, t[r]), ch.toArray(n, r * 16)
                }
                i !== null && (i.needsUpdate = !0)
            }
            clone() {
                return new Qo(this.bones, this.boneInverses)
            }
            computeBoneTexture() {
                let e = Math.sqrt(this.bones.length * 4);
                e = Jc(e), e = Math.max(e, 4);
                const t = new Float32Array(e * e * 4);
                t.set(this.boneMatrices);
                const n = new lh(t, e, e, ct, yn);
                return this.boneMatrices = t, this.boneTexture = n, this.boneTextureSize = e, this
            }
            getBoneByName(e) {
                for (let t = 0, n = this.bones.length; t < n; t++) {
                    const i = this.bones[t];
                    if (i.name === e) return i
                }
            }
            dispose() {
                this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null)
            }
            fromJSON(e, t) {
                this.uuid = e.uuid;
                for (let n = 0, i = e.bones.length; n < i; n++) {
                    const r = e.bones[n];
                    let s = t[r];
                    s === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", r), s = new Ko), this.bones.push(s), this.boneInverses.push(new fe().fromArray(e.boneInverses[n]))
                }
                return this.init(), this
            }
            toJSON() {
                const e = {
                    metadata: {
                        version: 4.5,
                        type: "Skeleton",
                        generator: "Skeleton.toJSON"
                    },
                    bones: [],
                    boneInverses: []
                };
                e.uuid = this.uuid;
                const t = this.bones,
                    n = this.boneInverses;
                for (let i = 0, r = t.length; i < r; i++) {
                    const s = t[i];
                    e.bones.push(s.uuid);
                    const o = n[i];
                    e.boneInverses.push(o.toArray())
                }
                return e
            }
        }
        class Tr extends Qe {
            constructor(e, t, n, i = 1) {
                typeof n == "number" && (i = n, n = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument."));
                super(e, t, n);
                this.meshPerAttribute = i
            }
            copy(e) {
                return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this
            }
            toJSON() {
                const e = super.toJSON();
                return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e
            }
        }
        Tr.prototype.isInstancedBufferAttribute = !0;
        const uh = new fe,
            hh = new fe,
            Aa = [],
            ps = new Ge;
        class fh extends Ge {
            constructor(e, t, n) {
                super(e, t);
                this.instanceMatrix = new Tr(new Float32Array(n * 16), 16), this.instanceColor = null, this.count = n, this.frustumCulled = !1
            }
            copy(e) {
                return super.copy(e), this.instanceMatrix.copy(e.instanceMatrix), e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, this
            }
            getColorAt(e, t) {
                t.fromArray(this.instanceColor.array, e * 3)
            }
            getMatrixAt(e, t) {
                t.fromArray(this.instanceMatrix.array, e * 16)
            }
            raycast(e, t) {
                const n = this.matrixWorld,
                    i = this.count;
                if (ps.geometry = this.geometry, ps.material = this.material, ps.material !== void 0)
                    for (let r = 0; r < i; r++) {
                        this.getMatrixAt(r, uh), hh.multiplyMatrices(n, uh), ps.matrixWorld = hh, ps.raycast(e, Aa);
                        for (let s = 0, o = Aa.length; s < o; s++) {
                            const l = Aa[s];
                            l.instanceId = r, l.object = this, t.push(l)
                        }
                        Aa.length = 0
                    }
            }
            setColorAt(e, t) {
                this.instanceColor === null && (this.instanceColor = new Tr(new Float32Array(this.instanceMatrix.count * 3), 3)), t.toArray(this.instanceColor.array, e * 3)
            }
            setMatrixAt(e, t) {
                t.toArray(this.instanceMatrix.array, e * 16)
            }
            updateMorphTargets() {}
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }
        fh.prototype.isInstancedMesh = !0;
        class Er extends ot {
            constructor(e) {
                super();
                this.type = "LineBasicMaterial", this.color = new ne(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.setValues(e)
            }
            copy(e) {
                return super.copy(e), this.color.copy(e.color), this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this
            }
        }
        Er.prototype.isLineBasicMaterial = !0;
        const dh = new E,
            ph = new E,
            mh = new fe,
            el = new Ei,
            La = new Ti;
        class Ra extends Te {
            constructor(e = new ke, t = new Er) {
                super();
                this.type = "Line", this.geometry = e, this.material = t, this.updateMorphTargets()
            }
            copy(e) {
                return super.copy(e), this.material = e.material, this.geometry = e.geometry, this
            }
            computeLineDistances() {
                const e = this.geometry;
                if (e.isBufferGeometry)
                    if (e.index === null) {
                        const t = e.attributes.position,
                            n = [0];
                        for (let i = 1, r = t.count; i < r; i++) dh.fromBufferAttribute(t, i - 1), ph.fromBufferAttribute(t, i), n[i] = n[i - 1], n[i] += dh.distanceTo(ph);
                        e.setAttribute("lineDistance", new Je(n, 1))
                    } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                else e.isGeometry && console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
                return this
            }
            raycast(e, t) {
                const n = this.geometry,
                    i = this.matrixWorld,
                    r = e.params.Line.threshold,
                    s = n.drawRange;
                if (n.boundingSphere === null && n.computeBoundingSphere(), La.copy(n.boundingSphere), La.applyMatrix4(i), La.radius += r, e.ray.intersectsSphere(La) === !1) return;
                mh.copy(i).invert(), el.copy(e.ray).applyMatrix4(mh);
                const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                    l = o * o,
                    c = new E,
                    u = new E,
                    h = new E,
                    f = new E,
                    d = this.isLineSegments ? 2 : 1;
                if (n.isBufferGeometry) {
                    const m = n.index,
                        v = n.attributes.position;
                    if (m !== null) {
                        const p = Math.max(0, s.start),
                            _ = Math.min(m.count, s.start + s.count);
                        for (let M = p, y = _ - 1; M < y; M += d) {
                            const b = m.getX(M),
                                T = m.getX(M + 1);
                            if (c.fromBufferAttribute(v, b), u.fromBufferAttribute(v, T), el.distanceSqToSegment(c, u, f, h) > l) continue;
                            f.applyMatrix4(this.matrixWorld);
                            const R = e.ray.origin.distanceTo(f);
                            R < e.near || R > e.far || t.push({
                                distance: R,
                                point: h.clone().applyMatrix4(this.matrixWorld),
                                index: M,
                                face: null,
                                faceIndex: null,
                                object: this
                            })
                        }
                    } else {
                        const p = Math.max(0, s.start),
                            _ = Math.min(v.count, s.start + s.count);
                        for (let M = p, y = _ - 1; M < y; M += d) {
                            if (c.fromBufferAttribute(v, M), u.fromBufferAttribute(v, M + 1), el.distanceSqToSegment(c, u, f, h) > l) continue;
                            f.applyMatrix4(this.matrixWorld);
                            const T = e.ray.origin.distanceTo(f);
                            T < e.near || T > e.far || t.push({
                                distance: T,
                                point: h.clone().applyMatrix4(this.matrixWorld),
                                index: M,
                                face: null,
                                faceIndex: null,
                                object: this
                            })
                        }
                    }
                } else n.isGeometry && console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
            }
            updateMorphTargets() {
                const e = this.geometry;
                if (e.isBufferGeometry) {
                    const t = e.morphAttributes,
                        n = Object.keys(t);
                    if (n.length > 0) {
                        const i = t[n[0]];
                        if (i !== void 0) {
                            this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                            for (let r = 0, s = i.length; r < s; r++) {
                                const o = i[r].name || String(r);
                                this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = r
                            }
                        }
                    }
                } else {
                    const t = e.morphTargets;
                    t !== void 0 && t.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
                }
            }
        }
        Ra.prototype.isLine = !0;
        const gh = new E,
            _h = new E;
        class Ca extends Ra {
            constructor(e, t) {
                super(e, t);
                this.type = "LineSegments"
            }
            computeLineDistances() {
                const e = this.geometry;
                if (e.isBufferGeometry)
                    if (e.index === null) {
                        const t = e.attributes.position,
                            n = [];
                        for (let i = 0, r = t.count; i < r; i += 2) gh.fromBufferAttribute(t, i), _h.fromBufferAttribute(t, i + 1), n[i] = i === 0 ? 0 : n[i - 1], n[i + 1] = n[i] + gh.distanceTo(_h);
                        e.setAttribute("lineDistance", new Je(n, 1))
                    } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                else e.isGeometry && console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
                return this
            }
        }
        Ca.prototype.isLineSegments = !0;
        class vh extends Ra {
            constructor(e, t) {
                super(e, t);
                this.type = "LineLoop"
            }
        }
        vh.prototype.isLineLoop = !0;
        class tl extends ot {
            constructor(e) {
                super();
                this.type = "PointsMaterial", this.color = new ne(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.setValues(e)
            }
            copy(e) {
                return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this
            }
        }
        tl.prototype.isPointsMaterial = !0;
        const xh = new fe,
            nl = new Ei,
            Pa = new Ti,
            Da = new E;
        class yh extends Te {
            constructor(e = new ke, t = new tl) {
                super();
                this.type = "Points", this.geometry = e, this.material = t, this.updateMorphTargets()
            }
            copy(e) {
                return super.copy(e), this.material = e.material, this.geometry = e.geometry, this
            }
            raycast(e, t) {
                const n = this.geometry,
                    i = this.matrixWorld,
                    r = e.params.Points.threshold,
                    s = n.drawRange;
                if (n.boundingSphere === null && n.computeBoundingSphere(), Pa.copy(n.boundingSphere), Pa.applyMatrix4(i), Pa.radius += r, e.ray.intersectsSphere(Pa) === !1) return;
                xh.copy(i).invert(), nl.copy(e.ray).applyMatrix4(xh);
                const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                    l = o * o;
                if (n.isBufferGeometry) {
                    const c = n.index,
                        h = n.attributes.position;
                    if (c !== null) {
                        const f = Math.max(0, s.start),
                            d = Math.min(c.count, s.start + s.count);
                        for (let m = f, g = d; m < g; m++) {
                            const v = c.getX(m);
                            Da.fromBufferAttribute(h, v), Mh(Da, v, l, i, e, t, this)
                        }
                    } else {
                        const f = Math.max(0, s.start),
                            d = Math.min(h.count, s.start + s.count);
                        for (let m = f, g = d; m < g; m++) Da.fromBufferAttribute(h, m), Mh(Da, m, l, i, e, t, this)
                    }
                } else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
            }
            updateMorphTargets() {
                const e = this.geometry;
                if (e.isBufferGeometry) {
                    const t = e.morphAttributes,
                        n = Object.keys(t);
                    if (n.length > 0) {
                        const i = t[n[0]];
                        if (i !== void 0) {
                            this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                            for (let r = 0, s = i.length; r < s; r++) {
                                const o = i[r].name || String(r);
                                this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = r
                            }
                        }
                    }
                } else {
                    const t = e.morphTargets;
                    t !== void 0 && t.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
                }
            }
        }
        yh.prototype.isPoints = !0;

        function Mh(a, e, t, n, i, r, s) {
            const o = nl.distanceSqToPoint(a);
            if (o < t) {
                const l = new E;
                nl.closestPointToPoint(a, l), l.applyMatrix4(n);
                const c = i.ray.origin.distanceTo(l);
                if (c < i.near || c > i.far) return;
                r.push({
                    distance: c,
                    distanceToRay: Math.sqrt(o),
                    point: l,
                    index: e,
                    face: null,
                    object: s
                })
            }
        }
        class Cv extends at {
            constructor(e, t, n, i, r, s, o, l, c) {
                super(e, t, n, i, r, s, o, l, c);
                this.format = o !== void 0 ? o : yi, this.minFilter = s !== void 0 ? s : lt, this.magFilter = r !== void 0 ? r : lt, this.generateMipmaps = !1;
                const u = this;

                function h() {
                    u.needsUpdate = !0, e.requestVideoFrameCallback(h)
                }
                "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(h)
            }
            clone() {
                return new this.constructor(this.image).copy(this)
            }
            update() {
                const e = this.image;
                "requestVideoFrameCallback" in e === !1 && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
            }
        }
        Cv.prototype.isVideoTexture = !0;
        class Pv extends at {
            constructor(e, t, n, i, r, s, o, l, c, u, h, f) {
                super(null, s, o, l, c, u, i, r, h, f);
                this.image = {
                    width: t,
                    height: n
                }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1
            }
        }
        Pv.prototype.isCompressedTexture = !0;
        class Dv extends at {
            constructor(e, t, n, i, r, s, o, l, c) {
                super(e, t, n, i, r, s, o, l, c);
                this.needsUpdate = !0
            }
        }
        Dv.prototype.isCanvasTexture = !0;
        class Iv extends at {
            constructor(e, t, n, i, r, s, o, l, c, u) {
                if (u = u !== void 0 ? u : ji, u !== ji && u !== Kr) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                n === void 0 && u === ji && (n = Js), n === void 0 && u === Kr && (n = $r);
                super(null, i, r, s, o, l, u, n, c);
                this.image = {
                    width: e,
                    height: t
                }, this.magFilter = o !== void 0 ? o : st, this.minFilter = l !== void 0 ? l : st, this.flipY = !1, this.generateMipmaps = !1
            }
        }
        Iv.prototype.isDepthTexture = !0, new E, new E, new E, new it;
        class Zt {
            constructor() {
                this.type = "Curve", this.arcLengthDivisions = 200
            }
            getPoint() {
                return console.warn("THREE.Curve: .getPoint() not implemented."), null
            }
            getPointAt(e, t) {
                const n = this.getUtoTmapping(e);
                return this.getPoint(n, t)
            }
            getPoints(e = 5) {
                const t = [];
                for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
                return t
            }
            getSpacedPoints(e = 5) {
                const t = [];
                for (let n = 0; n <= e; n++) t.push(this.getPointAt(n / e));
                return t
            }
            getLength() {
                const e = this.getLengths();
                return e[e.length - 1]
            }
            getLengths(e = this.arcLengthDivisions) {
                if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths;
                this.needsUpdate = !1;
                const t = [];
                let n, i = this.getPoint(0),
                    r = 0;
                t.push(0);
                for (let s = 1; s <= e; s++) n = this.getPoint(s / e), r += n.distanceTo(i), t.push(r), i = n;
                return this.cacheArcLengths = t, t
            }
            updateArcLengths() {
                this.needsUpdate = !0, this.getLengths()
            }
            getUtoTmapping(e, t) {
                const n = this.getLengths();
                let i = 0;
                const r = n.length;
                let s;
                t ? s = t : s = e * n[r - 1];
                let o = 0,
                    l = r - 1,
                    c;
                for (; o <= l;)
                    if (i = Math.floor(o + (l - o) / 2), c = n[i] - s, c < 0) o = i + 1;
                    else if (c > 0) l = i - 1;
                else {
                    l = i;
                    break
                }
                if (i = l, n[i] === s) return i / (r - 1);
                const u = n[i],
                    f = n[i + 1] - u,
                    d = (s - u) / f;
                return (i + d) / (r - 1)
            }
            getTangent(e, t) {
                const n = 1e-4;
                let i = e - n,
                    r = e + n;
                i < 0 && (i = 0), r > 1 && (r = 1);
                const s = this.getPoint(i),
                    o = this.getPoint(r),
                    l = t || (s.isVector2 ? new X : new E);
                return l.copy(o).sub(s).normalize(), l
            }
            getTangentAt(e, t) {
                const n = this.getUtoTmapping(e);
                return this.getTangent(n, t)
            }
            computeFrenetFrames(e, t) {
                const n = new E,
                    i = [],
                    r = [],
                    s = [],
                    o = new E,
                    l = new fe;
                for (let d = 0; d <= e; d++) {
                    const m = d / e;
                    i[d] = this.getTangentAt(m, new E)
                }
                r[0] = new E, s[0] = new E;
                let c = Number.MAX_VALUE;
                const u = Math.abs(i[0].x),
                    h = Math.abs(i[0].y),
                    f = Math.abs(i[0].z);
                u <= c && (c = u, n.set(1, 0, 0)), h <= c && (c = h, n.set(0, 1, 0)), f <= c && n.set(0, 0, 1), o.crossVectors(i[0], n).normalize(), r[0].crossVectors(i[0], o), s[0].crossVectors(i[0], r[0]);
                for (let d = 1; d <= e; d++) {
                    if (r[d] = r[d - 1].clone(), s[d] = s[d - 1].clone(), o.crossVectors(i[d - 1], i[d]), o.length() > Number.EPSILON) {
                        o.normalize();
                        const m = Math.acos(Pt(i[d - 1].dot(i[d]), -1, 1));
                        r[d].applyMatrix4(l.makeRotationAxis(o, m))
                    }
                    s[d].crossVectors(i[d], r[d])
                }
                if (t === !0) {
                    let d = Math.acos(Pt(r[0].dot(r[e]), -1, 1));
                    d /= e, i[0].dot(o.crossVectors(r[0], r[e])) > 0 && (d = -d);
                    for (let m = 1; m <= e; m++) r[m].applyMatrix4(l.makeRotationAxis(i[m], d * m)), s[m].crossVectors(i[m], r[m])
                }
                return {
                    tangents: i,
                    normals: r,
                    binormals: s
                }
            }
            clone() {
                return new this.constructor().copy(this)
            }
            copy(e) {
                return this.arcLengthDivisions = e.arcLengthDivisions, this
            }
            toJSON() {
                const e = {
                    metadata: {
                        version: 4.5,
                        type: "Curve",
                        generator: "Curve.toJSON"
                    }
                };
                return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e
            }
            fromJSON(e) {
                return this.arcLengthDivisions = e.arcLengthDivisions, this
            }
        }
        class Ia extends Zt {
            constructor(e = 0, t = 0, n = 1, i = 1, r = 0, s = Math.PI * 2, o = !1, l = 0) {
                super();
                this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = n, this.yRadius = i, this.aStartAngle = r, this.aEndAngle = s, this.aClockwise = o, this.aRotation = l
            }
            getPoint(e, t) {
                const n = t || new X,
                    i = Math.PI * 2;
                let r = this.aEndAngle - this.aStartAngle;
                const s = Math.abs(r) < Number.EPSILON;
                for (; r < 0;) r += i;
                for (; r > i;) r -= i;
                r < Number.EPSILON && (s ? r = 0 : r = i), this.aClockwise === !0 && !s && (r === i ? r = -i : r = r - i);
                const o = this.aStartAngle + e * r;
                let l = this.aX + this.xRadius * Math.cos(o),
                    c = this.aY + this.yRadius * Math.sin(o);
                if (this.aRotation !== 0) {
                    const u = Math.cos(this.aRotation),
                        h = Math.sin(this.aRotation),
                        f = l - this.aX,
                        d = c - this.aY;
                    l = f * u - d * h + this.aX, c = f * h + d * u + this.aY
                }
                return n.set(l, c)
            }
            copy(e) {
                return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
            }
            toJSON() {
                const e = super.toJSON();
                return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e
            }
            fromJSON(e) {
                return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
            }
        }
        Ia.prototype.isEllipseCurve = !0;
        class bh extends Ia {
            constructor(e, t, n, i, r, s) {
                super(e, t, n, n, i, r, s);
                this.type = "ArcCurve"
            }
        }
        bh.prototype.isArcCurve = !0;

        function il() {
            let a = 0,
                e = 0,
                t = 0,
                n = 0;

            function i(r, s, o, l) {
                a = r, e = o, t = -3 * r + 3 * s - 2 * o - l, n = 2 * r - 2 * s + o + l
            }
            return {
                initCatmullRom: function(r, s, o, l, c) {
                    i(s, o, c * (o - r), c * (l - s))
                },
                initNonuniformCatmullRom: function(r, s, o, l, c, u, h) {
                    let f = (s - r) / c - (o - r) / (c + u) + (o - s) / u,
                        d = (o - s) / u - (l - s) / (u + h) + (l - o) / h;
                    f *= u, d *= u, i(s, o, f, d)
                },
                calc: function(r) {
                    const s = r * r,
                        o = s * r;
                    return a + e * r + t * s + n * o
                }
            }
        }
        const Fa = new E,
            rl = new il,
            sl = new il,
            al = new il;
        class wh extends Zt {
            constructor(e = [], t = !1, n = "centripetal", i = .5) {
                super();
                this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = n, this.tension = i
            }
            getPoint(e, t = new E) {
                const n = t,
                    i = this.points,
                    r = i.length,
                    s = (r - (this.closed ? 0 : 1)) * e;
                let o = Math.floor(s),
                    l = s - o;
                this.closed ? o += o > 0 ? 0 : (Math.floor(Math.abs(o) / r) + 1) * r : l === 0 && o === r - 1 && (o = r - 2, l = 1);
                let c, u;
                this.closed || o > 0 ? c = i[(o - 1) % r] : (Fa.subVectors(i[0], i[1]).add(i[0]), c = Fa);
                const h = i[o % r],
                    f = i[(o + 1) % r];
                if (this.closed || o + 2 < r ? u = i[(o + 2) % r] : (Fa.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]), u = Fa), this.curveType === "centripetal" || this.curveType === "chordal") {
                    const d = this.curveType === "chordal" ? .5 : .25;
                    let m = Math.pow(c.distanceToSquared(h), d),
                        g = Math.pow(h.distanceToSquared(f), d),
                        v = Math.pow(f.distanceToSquared(u), d);
                    g < 1e-4 && (g = 1), m < 1e-4 && (m = g), v < 1e-4 && (v = g), rl.initNonuniformCatmullRom(c.x, h.x, f.x, u.x, m, g, v), sl.initNonuniformCatmullRom(c.y, h.y, f.y, u.y, m, g, v), al.initNonuniformCatmullRom(c.z, h.z, f.z, u.z, m, g, v)
                } else this.curveType === "catmullrom" && (rl.initCatmullRom(c.x, h.x, f.x, u.x, this.tension), sl.initCatmullRom(c.y, h.y, f.y, u.y, this.tension), al.initCatmullRom(c.z, h.z, f.z, u.z, this.tension));
                return n.set(rl.calc(l), sl.calc(l), al.calc(l)), n
            }
            copy(e) {
                super.copy(e), this.points = [];
                for (let t = 0, n = e.points.length; t < n; t++) {
                    const i = e.points[t];
                    this.points.push(i.clone())
                }
                return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
            }
            toJSON() {
                const e = super.toJSON();
                e.points = [];
                for (let t = 0, n = this.points.length; t < n; t++) {
                    const i = this.points[t];
                    e.points.push(i.toArray())
                }
                return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e
            }
            fromJSON(e) {
                super.fromJSON(e), this.points = [];
                for (let t = 0, n = e.points.length; t < n; t++) {
                    const i = e.points[t];
                    this.points.push(new E().fromArray(i))
                }
                return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
            }
        }
        wh.prototype.isCatmullRomCurve3 = !0;

        function Sh(a, e, t, n, i) {
            const r = (n - e) * .5,
                s = (i - t) * .5,
                o = a * a,
                l = a * o;
            return (2 * t - 2 * n + r + s) * l + (-3 * t + 3 * n - 2 * r - s) * o + r * a + t
        }

        function Fv(a, e) {
            const t = 1 - a;
            return t * t * e
        }

        function zv(a, e) {
            return 2 * (1 - a) * a * e
        }

        function Nv(a, e) {
            return a * a * e
        }

        function ms(a, e, t, n) {
            return Fv(a, e) + zv(a, t) + Nv(a, n)
        }

        function Bv(a, e) {
            const t = 1 - a;
            return t * t * t * e
        }

        function Ov(a, e) {
            const t = 1 - a;
            return 3 * t * t * a * e
        }

        function Uv(a, e) {
            return 3 * (1 - a) * a * a * e
        }

        function kv(a, e) {
            return a * a * a * e
        }

        function gs(a, e, t, n, i) {
            return Bv(a, e) + Ov(a, t) + Uv(a, n) + kv(a, i)
        }
        class ol extends Zt {
            constructor(e = new X, t = new X, n = new X, i = new X) {
                super();
                this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = i
            }
            getPoint(e, t = new X) {
                const n = t,
                    i = this.v0,
                    r = this.v1,
                    s = this.v2,
                    o = this.v3;
                return n.set(gs(e, i.x, r.x, s.x, o.x), gs(e, i.y, r.y, s.y, o.y)), n
            }
            copy(e) {
                return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
            }
            toJSON() {
                const e = super.toJSON();
                return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
            }
            fromJSON(e) {
                return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
            }
        }
        ol.prototype.isCubicBezierCurve = !0;
        class Th extends Zt {
            constructor(e = new E, t = new E, n = new E, i = new E) {
                super();
                this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = i
            }
            getPoint(e, t = new E) {
                const n = t,
                    i = this.v0,
                    r = this.v1,
                    s = this.v2,
                    o = this.v3;
                return n.set(gs(e, i.x, r.x, s.x, o.x), gs(e, i.y, r.y, s.y, o.y), gs(e, i.z, r.z, s.z, o.z)), n
            }
            copy(e) {
                return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
            }
            toJSON() {
                const e = super.toJSON();
                return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
            }
            fromJSON(e) {
                return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
            }
        }
        Th.prototype.isCubicBezierCurve3 = !0;
        class za extends Zt {
            constructor(e = new X, t = new X) {
                super();
                this.type = "LineCurve", this.v1 = e, this.v2 = t
            }
            getPoint(e, t = new X) {
                const n = t;
                return e === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n
            }
            getPointAt(e, t) {
                return this.getPoint(e, t)
            }
            getTangent(e, t) {
                const n = t || new X;
                return n.copy(this.v2).sub(this.v1).normalize(), n
            }
            copy(e) {
                return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
            }
            toJSON() {
                const e = super.toJSON();
                return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
            }
            fromJSON(e) {
                return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
            }
        }
        za.prototype.isLineCurve = !0;
        class Gv extends Zt {
            constructor(e = new E, t = new E) {
                super();
                this.type = "LineCurve3", this.isLineCurve3 = !0, this.v1 = e, this.v2 = t
            }
            getPoint(e, t = new E) {
                const n = t;
                return e === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n
            }
            getPointAt(e, t) {
                return this.getPoint(e, t)
            }
            copy(e) {
                return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
            }
            toJSON() {
                const e = super.toJSON();
                return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
            }
            fromJSON(e) {
                return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
            }
        }
        class ll extends Zt {
            constructor(e = new X, t = new X, n = new X) {
                super();
                this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n
            }
            getPoint(e, t = new X) {
                const n = t,
                    i = this.v0,
                    r = this.v1,
                    s = this.v2;
                return n.set(ms(e, i.x, r.x, s.x), ms(e, i.y, r.y, s.y)), n
            }
            copy(e) {
                return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
            }
            toJSON() {
                const e = super.toJSON();
                return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
            }
            fromJSON(e) {
                return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
            }
        }
        ll.prototype.isQuadraticBezierCurve = !0;
        class Eh extends Zt {
            constructor(e = new E, t = new E, n = new E) {
                super();
                this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n
            }
            getPoint(e, t = new E) {
                const n = t,
                    i = this.v0,
                    r = this.v1,
                    s = this.v2;
                return n.set(ms(e, i.x, r.x, s.x), ms(e, i.y, r.y, s.y), ms(e, i.z, r.z, s.z)), n
            }
            copy(e) {
                return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
            }
            toJSON() {
                const e = super.toJSON();
                return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
            }
            fromJSON(e) {
                return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
            }
        }
        Eh.prototype.isQuadraticBezierCurve3 = !0;
        class cl extends Zt {
            constructor(e = []) {
                super();
                this.type = "SplineCurve", this.points = e
            }
            getPoint(e, t = new X) {
                const n = t,
                    i = this.points,
                    r = (i.length - 1) * e,
                    s = Math.floor(r),
                    o = r - s,
                    l = i[s === 0 ? s : s - 1],
                    c = i[s],
                    u = i[s > i.length - 2 ? i.length - 1 : s + 1],
                    h = i[s > i.length - 3 ? i.length - 1 : s + 2];
                return n.set(Sh(o, l.x, c.x, u.x, h.x), Sh(o, l.y, c.y, u.y, h.y)), n
            }
            copy(e) {
                super.copy(e), this.points = [];
                for (let t = 0, n = e.points.length; t < n; t++) {
                    const i = e.points[t];
                    this.points.push(i.clone())
                }
                return this
            }
            toJSON() {
                const e = super.toJSON();
                e.points = [];
                for (let t = 0, n = this.points.length; t < n; t++) {
                    const i = this.points[t];
                    e.points.push(i.toArray())
                }
                return e
            }
            fromJSON(e) {
                super.fromJSON(e), this.points = [];
                for (let t = 0, n = e.points.length; t < n; t++) {
                    const i = e.points[t];
                    this.points.push(new X().fromArray(i))
                }
                return this
            }
        }
        cl.prototype.isSplineCurve = !0;
        var Ah = Object.freeze({
            __proto__: null,
            ArcCurve: bh,
            CatmullRomCurve3: wh,
            CubicBezierCurve: ol,
            CubicBezierCurve3: Th,
            EllipseCurve: Ia,
            LineCurve: za,
            LineCurve3: Gv,
            QuadraticBezierCurve: ll,
            QuadraticBezierCurve3: Eh,
            SplineCurve: cl
        });
        class Hv extends Zt {
            constructor() {
                super();
                this.type = "CurvePath", this.curves = [], this.autoClose = !1
            }
            add(e) {
                this.curves.push(e)
            }
            closePath() {
                const e = this.curves[0].getPoint(0),
                    t = this.curves[this.curves.length - 1].getPoint(1);
                e.equals(t) || this.curves.push(new za(t, e))
            }
            getPoint(e, t) {
                const n = e * this.getLength(),
                    i = this.getCurveLengths();
                let r = 0;
                for (; r < i.length;) {
                    if (i[r] >= n) {
                        const s = i[r] - n,
                            o = this.curves[r],
                            l = o.getLength(),
                            c = l === 0 ? 0 : 1 - s / l;
                        return o.getPointAt(c, t)
                    }
                    r++
                }
                return null
            }
            getLength() {
                const e = this.getCurveLengths();
                return e[e.length - 1]
            }
            updateArcLengths() {
                this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
            }
            getCurveLengths() {
                if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
                const e = [];
                let t = 0;
                for (let n = 0, i = this.curves.length; n < i; n++) t += this.curves[n].getLength(), e.push(t);
                return this.cacheLengths = e, e
            }
            getSpacedPoints(e = 40) {
                const t = [];
                for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
                return this.autoClose && t.push(t[0]), t
            }
            getPoints(e = 12) {
                const t = [];
                let n;
                for (let i = 0, r = this.curves; i < r.length; i++) {
                    const s = r[i],
                        o = s && s.isEllipseCurve ? e * 2 : s && (s.isLineCurve || s.isLineCurve3) ? 1 : s && s.isSplineCurve ? e * s.points.length : e,
                        l = s.getPoints(o);
                    for (let c = 0; c < l.length; c++) {
                        const u = l[c];
                        n && n.equals(u) || (t.push(u), n = u)
                    }
                }
                return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t
            }
            copy(e) {
                super.copy(e), this.curves = [];
                for (let t = 0, n = e.curves.length; t < n; t++) {
                    const i = e.curves[t];
                    this.curves.push(i.clone())
                }
                return this.autoClose = e.autoClose, this
            }
            toJSON() {
                const e = super.toJSON();
                e.autoClose = this.autoClose, e.curves = [];
                for (let t = 0, n = this.curves.length; t < n; t++) {
                    const i = this.curves[t];
                    e.curves.push(i.toJSON())
                }
                return e
            }
            fromJSON(e) {
                super.fromJSON(e), this.autoClose = e.autoClose, this.curves = [];
                for (let t = 0, n = e.curves.length; t < n; t++) {
                    const i = e.curves[t];
                    this.curves.push(new Ah[i.type]().fromJSON(i))
                }
                return this
            }
        }
        class ul extends Hv {
            constructor(e) {
                super();
                this.type = "Path", this.currentPoint = new X, e && this.setFromPoints(e)
            }
            setFromPoints(e) {
                this.moveTo(e[0].x, e[0].y);
                for (let t = 1, n = e.length; t < n; t++) this.lineTo(e[t].x, e[t].y);
                return this
            }
            moveTo(e, t) {
                return this.currentPoint.set(e, t), this
            }
            lineTo(e, t) {
                const n = new za(this.currentPoint.clone(), new X(e, t));
                return this.curves.push(n), this.currentPoint.set(e, t), this
            }
            quadraticCurveTo(e, t, n, i) {
                const r = new ll(this.currentPoint.clone(), new X(e, t), new X(n, i));
                return this.curves.push(r), this.currentPoint.set(n, i), this
            }
            bezierCurveTo(e, t, n, i, r, s) {
                const o = new ol(this.currentPoint.clone(), new X(e, t), new X(n, i), new X(r, s));
                return this.curves.push(o), this.currentPoint.set(r, s), this
            }
            splineThru(e) {
                const t = [this.currentPoint.clone()].concat(e),
                    n = new cl(t);
                return this.curves.push(n), this.currentPoint.copy(e[e.length - 1]), this
            }
            arc(e, t, n, i, r, s) {
                const o = this.currentPoint.x,
                    l = this.currentPoint.y;
                return this.absarc(e + o, t + l, n, i, r, s), this
            }
            absarc(e, t, n, i, r, s) {
                return this.absellipse(e, t, n, n, i, r, s), this
            }
            ellipse(e, t, n, i, r, s, o, l) {
                const c = this.currentPoint.x,
                    u = this.currentPoint.y;
                return this.absellipse(e + c, t + u, n, i, r, s, o, l), this
            }
            absellipse(e, t, n, i, r, s, o, l) {
                const c = new Ia(e, t, n, i, r, s, o, l);
                if (this.curves.length > 0) {
                    const h = c.getPoint(0);
                    h.equals(this.currentPoint) || this.lineTo(h.x, h.y)
                }
                this.curves.push(c);
                const u = c.getPoint(1);
                return this.currentPoint.copy(u), this
            }
            copy(e) {
                return super.copy(e), this.currentPoint.copy(e.currentPoint), this
            }
            toJSON() {
                const e = super.toJSON();
                return e.currentPoint = this.currentPoint.toArray(), e
            }
            fromJSON(e) {
                return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this
            }
        }
        class _s extends ul {
            constructor(e) {
                super(e);
                this.uuid = Xt(), this.type = "Shape", this.holes = []
            }
            getPointsHoles(e) {
                const t = [];
                for (let n = 0, i = this.holes.length; n < i; n++) t[n] = this.holes[n].getPoints(e);
                return t
            }
            extractPoints(e) {
                return {
                    shape: this.getPoints(e),
                    holes: this.getPointsHoles(e)
                }
            }
            copy(e) {
                super.copy(e), this.holes = [];
                for (let t = 0, n = e.holes.length; t < n; t++) {
                    const i = e.holes[t];
                    this.holes.push(i.clone())
                }
                return this
            }
            toJSON() {
                const e = super.toJSON();
                e.uuid = this.uuid, e.holes = [];
                for (let t = 0, n = this.holes.length; t < n; t++) {
                    const i = this.holes[t];
                    e.holes.push(i.toJSON())
                }
                return e
            }
            fromJSON(e) {
                super.fromJSON(e), this.uuid = e.uuid, this.holes = [];
                for (let t = 0, n = e.holes.length; t < n; t++) {
                    const i = e.holes[t];
                    this.holes.push(new ul().fromJSON(i))
                }
                return this
            }
        }
        const Vv = {
            triangulate: function(a, e, t = 2) {
                const n = e && e.length,
                    i = n ? e[0] * t : a.length;
                let r = Lh(a, 0, i, t, !0);
                const s = [];
                if (!r || r.next === r.prev) return s;
                let o, l, c, u, h, f, d;
                if (n && (r = Yv(a, e, r, t)), a.length > 80 * t) {
                    o = c = a[0], l = u = a[1];
                    for (let m = t; m < i; m += t) h = a[m], f = a[m + 1], h < o && (o = h), f < l && (l = f), h > c && (c = h), f > u && (u = f);
                    d = Math.max(c - o, u - l), d = d !== 0 ? 1 / d : 0
                }
                return vs(r, s, t, o, l, d), s
            }
        };

        function Lh(a, e, t, n, i) {
            let r, s;
            if (i === sx(a, e, t, n) > 0)
                for (r = e; r < t; r += n) s = Ph(r, a[r], a[r + 1], s);
            else
                for (r = t - n; r >= e; r -= n) s = Ph(r, a[r], a[r + 1], s);
            return s && Na(s, s.next) && (ys(s), s = s.next), s
        }

        function ei(a, e) {
            if (!a) return a;
            e || (e = a);
            let t = a,
                n;
            do
                if (n = !1, !t.steiner && (Na(t, t.next) || Ye(t.prev, t, t.next) === 0)) {
                    if (ys(t), t = e = t.prev, t === t.next) break;
                    n = !0
                } else t = t.next; while (n || t !== e);
            return e
        }

        function vs(a, e, t, n, i, r, s) {
            if (!a) return;
            !s && r && Qv(a, n, i, r);
            let o = a,
                l, c;
            for (; a.prev !== a.next;) {
                if (l = a.prev, c = a.next, r ? qv(a, n, i, r) : Wv(a)) {
                    e.push(l.i / t), e.push(a.i / t), e.push(c.i / t), ys(a), a = c.next, o = c.next;
                    continue
                }
                if (a = c, a === o) {
                    s ? s === 1 ? (a = Xv(ei(a), e, t), vs(a, e, t, n, i, r, 2)) : s === 2 && jv(a, e, t, n, i, r) : vs(ei(a), e, t, n, i, r, 1);
                    break
                }
            }
        }

        function Wv(a) {
            const e = a.prev,
                t = a,
                n = a.next;
            if (Ye(e, t, n) >= 0) return !1;
            let i = a.next.next;
            for (; i !== a.prev;) {
                if (Ar(e.x, e.y, t.x, t.y, n.x, n.y, i.x, i.y) && Ye(i.prev, i, i.next) >= 0) return !1;
                i = i.next
            }
            return !0
        }

        function qv(a, e, t, n) {
            const i = a.prev,
                r = a,
                s = a.next;
            if (Ye(i, r, s) >= 0) return !1;
            const o = i.x < r.x ? i.x < s.x ? i.x : s.x : r.x < s.x ? r.x : s.x,
                l = i.y < r.y ? i.y < s.y ? i.y : s.y : r.y < s.y ? r.y : s.y,
                c = i.x > r.x ? i.x > s.x ? i.x : s.x : r.x > s.x ? r.x : s.x,
                u = i.y > r.y ? i.y > s.y ? i.y : s.y : r.y > s.y ? r.y : s.y,
                h = hl(o, l, e, t, n),
                f = hl(c, u, e, t, n);
            let d = a.prevZ,
                m = a.nextZ;
            for (; d && d.z >= h && m && m.z <= f;) {
                if (d !== a.prev && d !== a.next && Ar(i.x, i.y, r.x, r.y, s.x, s.y, d.x, d.y) && Ye(d.prev, d, d.next) >= 0 || (d = d.prevZ, m !== a.prev && m !== a.next && Ar(i.x, i.y, r.x, r.y, s.x, s.y, m.x, m.y) && Ye(m.prev, m, m.next) >= 0)) return !1;
                m = m.nextZ
            }
            for (; d && d.z >= h;) {
                if (d !== a.prev && d !== a.next && Ar(i.x, i.y, r.x, r.y, s.x, s.y, d.x, d.y) && Ye(d.prev, d, d.next) >= 0) return !1;
                d = d.prevZ
            }
            for (; m && m.z <= f;) {
                if (m !== a.prev && m !== a.next && Ar(i.x, i.y, r.x, r.y, s.x, s.y, m.x, m.y) && Ye(m.prev, m, m.next) >= 0) return !1;
                m = m.nextZ
            }
            return !0
        }

        function Xv(a, e, t) {
            let n = a;
            do {
                const i = n.prev,
                    r = n.next.next;
                !Na(i, r) && Rh(i, n, n.next, r) && xs(i, r) && xs(r, i) && (e.push(i.i / t), e.push(n.i / t), e.push(r.i / t), ys(n), ys(n.next), n = a = r), n = n.next
            } while (n !== a);
            return ei(n)
        }

        function jv(a, e, t, n, i, r) {
            let s = a;
            do {
                let o = s.next.next;
                for (; o !== s.prev;) {
                    if (s.i !== o.i && nx(s, o)) {
                        let l = Ch(s, o);
                        s = ei(s, s.next), l = ei(l, l.next), vs(s, e, t, n, i, r), vs(l, e, t, n, i, r);
                        return
                    }
                    o = o.next
                }
                s = s.next
            } while (s !== a)
        }

        function Yv(a, e, t, n) {
            const i = [];
            let r, s, o, l, c;
            for (r = 0, s = e.length; r < s; r++) o = e[r] * n, l = r < s - 1 ? e[r + 1] * n : a.length, c = Lh(a, o, l, n, !1), c === c.next && (c.steiner = !0), i.push(tx(c));
            for (i.sort(Zv), r = 0; r < i.length; r++) Jv(i[r], t), t = ei(t, t.next);
            return t
        }

        function Zv(a, e) {
            return a.x - e.x
        }

        function Jv(a, e) {
            if (e = $v(a, e), e) {
                const t = Ch(e, a);
                ei(e, e.next), ei(t, t.next)
            }
        }

        function $v(a, e) {
            let t = e;
            const n = a.x,
                i = a.y;
            let r = -1 / 0,
                s;
            do {
                if (i <= t.y && i >= t.next.y && t.next.y !== t.y) {
                    const f = t.x + (i - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
                    if (f <= n && f > r) {
                        if (r = f, f === n) {
                            if (i === t.y) return t;
                            if (i === t.next.y) return t.next
                        }
                        s = t.x < t.next.x ? t : t.next
                    }
                }
                t = t.next
            } while (t !== e);
            if (!s) return null;
            if (n === r) return s;
            const o = s,
                l = s.x,
                c = s.y;
            let u = 1 / 0,
                h;
            t = s;
            do n >= t.x && t.x >= l && n !== t.x && Ar(i < c ? n : r, i, l, c, i < c ? r : n, i, t.x, t.y) && (h = Math.abs(i - t.y) / (n - t.x), xs(t, a) && (h < u || h === u && (t.x > s.x || t.x === s.x && Kv(s, t))) && (s = t, u = h)), t = t.next; while (t !== o);
            return s
        }

        function Kv(a, e) {
            return Ye(a.prev, a, e.prev) < 0 && Ye(e.next, a, a.next) < 0
        }

        function Qv(a, e, t, n) {
            let i = a;
            do i.z === null && (i.z = hl(i.x, i.y, e, t, n)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next; while (i !== a);
            i.prevZ.nextZ = null, i.prevZ = null, ex(i)
        }

        function ex(a) {
            let e, t, n, i, r, s, o, l, c = 1;
            do {
                for (t = a, a = null, r = null, s = 0; t;) {
                    for (s++, n = t, o = 0, e = 0; e < c && (o++, n = n.nextZ, !!n); e++);
                    for (l = c; o > 0 || l > 0 && n;) o !== 0 && (l === 0 || !n || t.z <= n.z) ? (i = t, t = t.nextZ, o--) : (i = n, n = n.nextZ, l--), r ? r.nextZ = i : a = i, i.prevZ = r, r = i;
                    t = n
                }
                r.nextZ = null, c *= 2
            } while (s > 1);
            return a
        }

        function hl(a, e, t, n, i) {
            return a = 32767 * (a - t) * i, e = 32767 * (e - n) * i, a = (a | a << 8) & 16711935, a = (a | a << 4) & 252645135, a = (a | a << 2) & 858993459, a = (a | a << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, a | e << 1
        }

        function tx(a) {
            let e = a,
                t = a;
            do(e.x < t.x || e.x === t.x && e.y < t.y) && (t = e), e = e.next; while (e !== a);
            return t
        }

        function Ar(a, e, t, n, i, r, s, o) {
            return (i - s) * (e - o) - (a - s) * (r - o) >= 0 && (a - s) * (n - o) - (t - s) * (e - o) >= 0 && (t - s) * (r - o) - (i - s) * (n - o) >= 0
        }

        function nx(a, e) {
            return a.next.i !== e.i && a.prev.i !== e.i && !ix(a, e) && (xs(a, e) && xs(e, a) && rx(a, e) && (Ye(a.prev, a, e.prev) || Ye(a, e.prev, e)) || Na(a, e) && Ye(a.prev, a, a.next) > 0 && Ye(e.prev, e, e.next) > 0)
        }

        function Ye(a, e, t) {
            return (e.y - a.y) * (t.x - e.x) - (e.x - a.x) * (t.y - e.y)
        }

        function Na(a, e) {
            return a.x === e.x && a.y === e.y
        }

        function Rh(a, e, t, n) {
            const i = Oa(Ye(a, e, t)),
                r = Oa(Ye(a, e, n)),
                s = Oa(Ye(t, n, a)),
                o = Oa(Ye(t, n, e));
            return !!(i !== r && s !== o || i === 0 && Ba(a, t, e) || r === 0 && Ba(a, n, e) || s === 0 && Ba(t, a, n) || o === 0 && Ba(t, e, n))
        }

        function Ba(a, e, t) {
            return e.x <= Math.max(a.x, t.x) && e.x >= Math.min(a.x, t.x) && e.y <= Math.max(a.y, t.y) && e.y >= Math.min(a.y, t.y)
        }

        function Oa(a) {
            return a > 0 ? 1 : a < 0 ? -1 : 0
        }

        function ix(a, e) {
            let t = a;
            do {
                if (t.i !== a.i && t.next.i !== a.i && t.i !== e.i && t.next.i !== e.i && Rh(t, t.next, a, e)) return !0;
                t = t.next
            } while (t !== a);
            return !1
        }

        function xs(a, e) {
            return Ye(a.prev, a, a.next) < 0 ? Ye(a, e, a.next) >= 0 && Ye(a, a.prev, e) >= 0 : Ye(a, e, a.prev) < 0 || Ye(a, a.next, e) < 0
        }

        function rx(a, e) {
            let t = a,
                n = !1;
            const i = (a.x + e.x) / 2,
                r = (a.y + e.y) / 2;
            do t.y > r != t.next.y > r && t.next.y !== t.y && i < (t.next.x - t.x) * (r - t.y) / (t.next.y - t.y) + t.x && (n = !n), t = t.next; while (t !== a);
            return n
        }

        function Ch(a, e) {
            const t = new fl(a.i, a.x, a.y),
                n = new fl(e.i, e.x, e.y),
                i = a.next,
                r = e.prev;
            return a.next = e, e.prev = a, t.next = i, i.prev = t, n.next = t, t.prev = n, r.next = n, n.prev = r, n
        }

        function Ph(a, e, t, n) {
            const i = new fl(a, e, t);
            return n ? (i.next = n.next, i.prev = n, n.next.prev = i, n.next = i) : (i.prev = i, i.next = i), i
        }

        function ys(a) {
            a.next.prev = a.prev, a.prev.next = a.next, a.prevZ && (a.prevZ.nextZ = a.nextZ), a.nextZ && (a.nextZ.prevZ = a.prevZ)
        }

        function fl(a, e, t) {
            this.i = a, this.x = e, this.y = t, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
        }

        function sx(a, e, t, n) {
            let i = 0;
            for (let r = e, s = t - n; r < t; r += n) i += (a[s] - a[r]) * (a[r + 1] + a[s + 1]), s = r;
            return i
        }
        class ti {
            static area(e) {
                const t = e.length;
                let n = 0;
                for (let i = t - 1, r = 0; r < t; i = r++) n += e[i].x * e[r].y - e[r].x * e[i].y;
                return n * .5
            }
            static isClockWise(e) {
                return ti.area(e) < 0
            }
            static triangulateShape(e, t) {
                const n = [],
                    i = [],
                    r = [];
                Dh(e), Ih(n, e);
                let s = e.length;
                t.forEach(Dh);
                for (let l = 0; l < t.length; l++) i.push(s), s += t[l].length, Ih(n, t[l]);
                const o = Vv.triangulate(n, i);
                for (let l = 0; l < o.length; l += 3) r.push(o.slice(l, l + 3));
                return r
            }
        }

        function Dh(a) {
            const e = a.length;
            e > 2 && a[e - 1].equals(a[0]) && a.pop()
        }

        function Ih(a, e) {
            for (let t = 0; t < e.length; t++) a.push(e[t].x), a.push(e[t].y)
        }
        class Lr extends ke {
            constructor(e = new _s([new X(.5, .5), new X(-.5, .5), new X(-.5, -.5), new X(.5, -.5)]), t = {}) {
                super();
                this.type = "ExtrudeGeometry", this.parameters = {
                    shapes: e,
                    options: t
                }, e = Array.isArray(e) ? e : [e];
                const n = this,
                    i = [],
                    r = [];
                for (let o = 0, l = e.length; o < l; o++) {
                    const c = e[o];
                    s(c)
                }
                this.setAttribute("position", new Je(i, 3)), this.setAttribute("uv", new Je(r, 2)), this.computeVertexNormals();

                function s(o) {
                    const l = [],
                        c = t.curveSegments !== void 0 ? t.curveSegments : 12,
                        u = t.steps !== void 0 ? t.steps : 1;
                    let h = t.depth !== void 0 ? t.depth : 1,
                        f = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0,
                        d = t.bevelThickness !== void 0 ? t.bevelThickness : .2,
                        m = t.bevelSize !== void 0 ? t.bevelSize : d - .1,
                        g = t.bevelOffset !== void 0 ? t.bevelOffset : 0,
                        v = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
                    const p = t.extrudePath,
                        _ = t.UVGenerator !== void 0 ? t.UVGenerator : ax;
                    t.amount !== void 0 && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), h = t.amount);
                    let M, y = !1,
                        b, T, x, R;
                    p && (M = p.getSpacedPoints(u), y = !0, f = !1, b = p.computeFrenetFrames(u, !1), T = new E, x = new E, R = new E), f || (v = 0, d = 0, m = 0, g = 0);
                    const P = o.extractPoints(c);
                    let I = P.shape;
                    const L = P.holes;
                    if (!ti.isClockWise(I)) {
                        I = I.reverse();
                        for (let V = 0, Z = L.length; V < Z; V++) {
                            const te = L[V];
                            ti.isClockWise(te) && (L[V] = te.reverse())
                        }
                    }
                    const D = ti.triangulateShape(I, L),
                        F = I;
                    for (let V = 0, Z = L.length; V < Z; V++) {
                        const te = L[V];
                        I = I.concat(te)
                    }

                    function N(V, Z, te) {
                        return Z || console.error("THREE.ExtrudeGeometry: vec does not exist"), Z.clone().multiplyScalar(te).add(V)
                    }
                    const z = I.length,
                        k = D.length;

                    function J(V, Z, te) {
                        let ge, se, A;
                        const S = V.x - Z.x,
                            H = V.y - Z.y,
                            K = te.x - V.x,
                            Q = te.y - V.y,
                            ce = S * S + H * H,
                            we = S * Q - H * K;
                        if (Math.abs(we) > Number.EPSILON) {
                            const ve = Math.sqrt(ce),
                                Ee = Math.sqrt(K * K + Q * Q),
                                _e = Z.x - H / ve,
                                C = Z.y + S / ve,
                                ae = te.x - Q / Ee,
                                j = te.y + K / Ee,
                                ue = ((ae - _e) * Q - (j - C) * K) / (S * Q - H * K);
                            ge = _e + S * ue - V.x, se = C + H * ue - V.y;
                            const pe = ge * ge + se * se;
                            if (pe <= 2) return new X(ge, se);
                            A = Math.sqrt(pe / 2)
                        } else {
                            let ve = !1;
                            S > Number.EPSILON ? K > Number.EPSILON && (ve = !0) : S < -Number.EPSILON ? K < -Number.EPSILON && (ve = !0) : Math.sign(H) === Math.sign(Q) && (ve = !0), ve ? (ge = -H, se = S, A = Math.sqrt(ce)) : (ge = S, se = H, A = Math.sqrt(ce / 2))
                        }
                        return new X(ge / A, se / A)
                    }
                    const oe = [];
                    for (let V = 0, Z = F.length, te = Z - 1, ge = V + 1; V < Z; V++, te++, ge++) te === Z && (te = 0), ge === Z && (ge = 0), oe[V] = J(F[V], F[te], F[ge]);
                    const he = [];
                    let ie, be = oe.concat();
                    for (let V = 0, Z = L.length; V < Z; V++) {
                        const te = L[V];
                        ie = [];
                        for (let ge = 0, se = te.length, A = se - 1, S = ge + 1; ge < se; ge++, A++, S++) A === se && (A = 0), S === se && (S = 0), ie[ge] = J(te[ge], te[A], te[S]);
                        he.push(ie), be = be.concat(ie)
                    }
                    for (let V = 0; V < v; V++) {
                        const Z = V / v,
                            te = d * Math.cos(Z * Math.PI / 2),
                            ge = m * Math.sin(Z * Math.PI / 2) + g;
                        for (let se = 0, A = F.length; se < A; se++) {
                            const S = N(F[se], oe[se], ge);
                            xe(S.x, S.y, -te)
                        }
                        for (let se = 0, A = L.length; se < A; se++) {
                            const S = L[se];
                            ie = he[se];
                            for (let H = 0, K = S.length; H < K; H++) {
                                const Q = N(S[H], ie[H], ge);
                                xe(Q.x, Q.y, -te)
                            }
                        }
                    }
                    const W = m + g;
                    for (let V = 0; V < z; V++) {
                        const Z = f ? N(I[V], be[V], W) : I[V];
                        y ? (x.copy(b.normals[0]).multiplyScalar(Z.x), T.copy(b.binormals[0]).multiplyScalar(Z.y), R.copy(M[0]).add(x).add(T), xe(R.x, R.y, R.z)) : xe(Z.x, Z.y, 0)
                    }
                    for (let V = 1; V <= u; V++)
                        for (let Z = 0; Z < z; Z++) {
                            const te = f ? N(I[Z], be[Z], W) : I[Z];
                            y ? (x.copy(b.normals[V]).multiplyScalar(te.x), T.copy(b.binormals[V]).multiplyScalar(te.y), R.copy(M[V]).add(x).add(T), xe(R.x, R.y, R.z)) : xe(te.x, te.y, h / u * V)
                        }
                    for (let V = v - 1; V >= 0; V--) {
                        const Z = V / v,
                            te = d * Math.cos(Z * Math.PI / 2),
                            ge = m * Math.sin(Z * Math.PI / 2) + g;
                        for (let se = 0, A = F.length; se < A; se++) {
                            const S = N(F[se], oe[se], ge);
                            xe(S.x, S.y, h + te)
                        }
                        for (let se = 0, A = L.length; se < A; se++) {
                            const S = L[se];
                            ie = he[se];
                            for (let H = 0, K = S.length; H < K; H++) {
                                const Q = N(S[H], ie[H], ge);
                                y ? xe(Q.x, Q.y + M[u - 1].y, M[u - 1].x + te) : xe(Q.x, Q.y, h + te)
                            }
                        }
                    }
                    $(), me();

                    function $() {
                        const V = i.length / 3;
                        if (f) {
                            let Z = 0,
                                te = z * Z;
                            for (let ge = 0; ge < k; ge++) {
                                const se = D[ge];
                                Se(se[2] + te, se[1] + te, se[0] + te)
                            }
                            Z = u + v * 2, te = z * Z;
                            for (let ge = 0; ge < k; ge++) {
                                const se = D[ge];
                                Se(se[0] + te, se[1] + te, se[2] + te)
                            }
                        } else {
                            for (let Z = 0; Z < k; Z++) {
                                const te = D[Z];
                                Se(te[2], te[1], te[0])
                            }
                            for (let Z = 0; Z < k; Z++) {
                                const te = D[Z];
                                Se(te[0] + z * u, te[1] + z * u, te[2] + z * u)
                            }
                        }
                        n.addGroup(V, i.length / 3 - V, 0)
                    }

                    function me() {
                        const V = i.length / 3;
                        let Z = 0;
                        G(F, Z), Z += F.length;
                        for (let te = 0, ge = L.length; te < ge; te++) {
                            const se = L[te];
                            G(se, Z), Z += se.length
                        }
                        n.addGroup(V, i.length / 3 - V, 1)
                    }

                    function G(V, Z) {
                        let te = V.length;
                        for (; --te >= 0;) {
                            const ge = te;
                            let se = te - 1;
                            se < 0 && (se = V.length - 1);
                            for (let A = 0, S = u + v * 2; A < S; A++) {
                                const H = z * A,
                                    K = z * (A + 1),
                                    Q = Z + ge + H,
                                    ce = Z + se + H,
                                    we = Z + se + K,
                                    ve = Z + ge + K;
                                le(Q, ce, we, ve)
                            }
                        }
                    }

                    function xe(V, Z, te) {
                        l.push(V), l.push(Z), l.push(te)
                    }

                    function Se(V, Z, te) {
                        de(V), de(Z), de(te);
                        const ge = i.length / 3,
                            se = _.generateTopUV(n, i, ge - 3, ge - 2, ge - 1);
                        Le(se[0]), Le(se[1]), Le(se[2])
                    }

                    function le(V, Z, te, ge) {
                        de(V), de(Z), de(ge), de(Z), de(te), de(ge);
                        const se = i.length / 3,
                            A = _.generateSideWallUV(n, i, se - 6, se - 3, se - 2, se - 1);
                        Le(A[0]), Le(A[1]), Le(A[3]), Le(A[1]), Le(A[2]), Le(A[3])
                    }

                    function de(V) {
                        i.push(l[V * 3 + 0]), i.push(l[V * 3 + 1]), i.push(l[V * 3 + 2])
                    }

                    function Le(V) {
                        r.push(V.x), r.push(V.y)
                    }
                }
            }
            toJSON() {
                const e = super.toJSON(),
                    t = this.parameters.shapes,
                    n = this.parameters.options;
                return ox(t, n, e)
            }
            static fromJSON(e, t) {
                const n = [];
                for (let r = 0, s = e.shapes.length; r < s; r++) {
                    const o = t[e.shapes[r]];
                    n.push(o)
                }
                const i = e.options.extrudePath;
                return i !== void 0 && (e.options.extrudePath = new Ah[i.type]().fromJSON(i)), new Lr(n, e.options)
            }
        }
        const ax = {
            generateTopUV: function(a, e, t, n, i) {
                const r = e[t * 3],
                    s = e[t * 3 + 1],
                    o = e[n * 3],
                    l = e[n * 3 + 1],
                    c = e[i * 3],
                    u = e[i * 3 + 1];
                return [new X(r, s), new X(o, l), new X(c, u)]
            },
            generateSideWallUV: function(a, e, t, n, i, r) {
                const s = e[t * 3],
                    o = e[t * 3 + 1],
                    l = e[t * 3 + 2],
                    c = e[n * 3],
                    u = e[n * 3 + 1],
                    h = e[n * 3 + 2],
                    f = e[i * 3],
                    d = e[i * 3 + 1],
                    m = e[i * 3 + 2],
                    g = e[r * 3],
                    v = e[r * 3 + 1],
                    p = e[r * 3 + 2];
                return Math.abs(o - u) < Math.abs(s - c) ? [new X(s, 1 - l), new X(c, 1 - h), new X(f, 1 - m), new X(g, 1 - p)] : [new X(o, 1 - l), new X(u, 1 - h), new X(d, 1 - m), new X(v, 1 - p)]
            }
        };

        function ox(a, e, t) {
            if (t.shapes = [], Array.isArray(a))
                for (let n = 0, i = a.length; n < i; n++) {
                    const r = a[n];
                    t.shapes.push(r.uuid)
                } else t.shapes.push(a.uuid);
            return e.extrudePath !== void 0 && (t.options.extrudePath = e.extrudePath.toJSON()), t
        }
        class dl extends ke {
            constructor(e = new _s([new X(0, .5), new X(-.5, -.5), new X(.5, -.5)]), t = 12) {
                super();
                this.type = "ShapeGeometry", this.parameters = {
                    shapes: e,
                    curveSegments: t
                };
                const n = [],
                    i = [],
                    r = [],
                    s = [];
                let o = 0,
                    l = 0;
                if (Array.isArray(e) === !1) c(e);
                else
                    for (let u = 0; u < e.length; u++) c(e[u]), this.addGroup(o, l, u), o += l, l = 0;
                this.setIndex(n), this.setAttribute("position", new Je(i, 3)), this.setAttribute("normal", new Je(r, 3)), this.setAttribute("uv", new Je(s, 2));

                function c(u) {
                    const h = i.length / 3,
                        f = u.extractPoints(t);
                    let d = f.shape;
                    const m = f.holes;
                    ti.isClockWise(d) === !1 && (d = d.reverse());
                    for (let v = 0, p = m.length; v < p; v++) {
                        const _ = m[v];
                        ti.isClockWise(_) === !0 && (m[v] = _.reverse())
                    }
                    const g = ti.triangulateShape(d, m);
                    for (let v = 0, p = m.length; v < p; v++) {
                        const _ = m[v];
                        d = d.concat(_)
                    }
                    for (let v = 0, p = d.length; v < p; v++) {
                        const _ = d[v];
                        i.push(_.x, _.y, 0), r.push(0, 0, 1), s.push(_.x, _.y)
                    }
                    for (let v = 0, p = g.length; v < p; v++) {
                        const _ = g[v],
                            M = _[0] + h,
                            y = _[1] + h,
                            b = _[2] + h;
                        n.push(M, y, b), l += 3
                    }
                }
            }
            toJSON() {
                const e = super.toJSON(),
                    t = this.parameters.shapes;
                return lx(t, e)
            }
            static fromJSON(e, t) {
                const n = [];
                for (let i = 0, r = e.shapes.length; i < r; i++) {
                    const s = t[e.shapes[i]];
                    n.push(s)
                }
                return new dl(n, e.curveSegments)
            }
        }

        function lx(a, e) {
            if (e.shapes = [], Array.isArray(a))
                for (let t = 0, n = a.length; t < n; t++) {
                    const i = a[t];
                    e.shapes.push(i.uuid)
                } else e.shapes.push(a.uuid);
            return e
        }
        class cx extends ot {
            constructor(e) {
                super();
                this.type = "ShadowMaterial", this.color = new ne(0), this.transparent = !0, this.setValues(e)
            }
            copy(e) {
                return super.copy(e), this.color.copy(e.color), this
            }
        }
        cx.prototype.isShadowMaterial = !0;
        class ni extends ot {
            constructor(e) {
                super();
                this.defines = {
                    STANDARD: ""
                }, this.type = "MeshStandardMaterial", this.color = new ne(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new ne(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = kn, this.normalScale = new X(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.setValues(e)
            }
            copy(e) {
                return super.copy(e), this.defines = {
                    STANDARD: ""
                }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this
            }
        }
        ni.prototype.isMeshStandardMaterial = !0;
        class Rr extends ni {
            constructor(e) {
                super();
                this.defines = {
                    STANDARD: "",
                    PHYSICAL: ""
                }, this.type = "MeshPhysicalMaterial", this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new X(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
                    get: function() {
                        return Pt(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
                    },
                    set: function(t) {
                        this.ior = (1 + .4 * t) / (1 - .4 * t)
                    }
                }), this.sheenTint = new ne(0), this.sheenRoughness = 1, this.transmissionMap = null, this.thickness = .01, this.thicknessMap = null, this.attenuationDistance = 0, this.attenuationTint = new ne(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularTint = new ne(1, 1, 1), this.specularTintMap = null, this._sheen = 0, this._clearcoat = 0, this._transmission = 0, this.setValues(e)
            }
            get sheen() {
                return this._sheen
            }
            set sheen(e) {
                this._sheen > 0 != e > 0 && this.version++, this._sheen = e
            }
            get clearcoat() {
                return this._clearcoat
            }
            set clearcoat(e) {
                this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e
            }
            get transmission() {
                return this._transmission
            }
            set transmission(e) {
                this._transmission > 0 != e > 0 && this.version++, this._transmission = e
            }
            copy(e) {
                return super.copy(e), this.defines = {
                    STANDARD: "",
                    PHYSICAL: ""
                }, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.ior = e.ior, this.sheen = e.sheen, this.sheenTint.copy(e.sheenTint), this.sheenRoughness = e.sheenRoughness, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationTint.copy(e.attenuationTint), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularTint.copy(e.specularTint), this.specularTintMap = e.specularTintMap, this
            }
        }
        Rr.prototype.isMeshPhysicalMaterial = !0;
        class ux extends ot {
            constructor(e) {
                super();
                this.type = "MeshPhongMaterial", this.color = new ne(16777215), this.specular = new ne(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new ne(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = kn, this.normalScale = new X(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = qs, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.setValues(e)
            }
            copy(e) {
                return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this
            }
        }
        ux.prototype.isMeshPhongMaterial = !0;
        class hx extends ot {
            constructor(e) {
                super();
                this.defines = {
                    TOON: ""
                }, this.type = "MeshToonMaterial", this.color = new ne(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new ne(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = kn, this.normalScale = new X(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(e)
            }
            copy(e) {
                return super.copy(e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this
            }
        }
        hx.prototype.isMeshToonMaterial = !0;
        class fx extends ot {
            constructor(e) {
                super();
                this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = kn, this.normalScale = new X(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.flatShading = !1, this.setValues(e)
            }
            copy(e) {
                return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this
            }
        }
        fx.prototype.isMeshNormalMaterial = !0;
        class dx extends ot {
            constructor(e) {
                super();
                this.type = "MeshLambertMaterial", this.color = new ne(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new ne(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = qs, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(e)
            }
            copy(e) {
                return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this
            }
        }
        dx.prototype.isMeshLambertMaterial = !0;
        class px extends ot {
            constructor(e) {
                super();
                this.defines = {
                    MATCAP: ""
                }, this.type = "MeshMatcapMaterial", this.color = new ne(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = kn, this.normalScale = new X(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.setValues(e)
            }
            copy(e) {
                return super.copy(e), this.defines = {
                    MATCAP: ""
                }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.flatShading = e.flatShading, this
            }
        }
        px.prototype.isMeshMatcapMaterial = !0;
        class mx extends Er {
            constructor(e) {
                super();
                this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e)
            }
            copy(e) {
                return super.copy(e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this
            }
        }
        mx.prototype.isLineDashedMaterial = !0;
        const je = {
            arraySlice: function(a, e, t) {
                return je.isTypedArray(a) ? new a.constructor(a.subarray(e, t !== void 0 ? t : a.length)) : a.slice(e, t)
            },
            convertArray: function(a, e, t) {
                return !a || !t && a.constructor === e ? a : typeof e.BYTES_PER_ELEMENT == "number" ? new e(a) : Array.prototype.slice.call(a)
            },
            isTypedArray: function(a) {
                return ArrayBuffer.isView(a) && !(a instanceof DataView)
            },
            getKeyframeOrder: function(a) {
                function e(i, r) {
                    return a[i] - a[r]
                }
                const t = a.length,
                    n = new Array(t);
                for (let i = 0; i !== t; ++i) n[i] = i;
                return n.sort(e), n
            },
            sortedArray: function(a, e, t) {
                const n = a.length,
                    i = new a.constructor(n);
                for (let r = 0, s = 0; s !== n; ++r) {
                    const o = t[r] * e;
                    for (let l = 0; l !== e; ++l) i[s++] = a[o + l]
                }
                return i
            },
            flattenJSON: function(a, e, t, n) {
                let i = 1,
                    r = a[0];
                for (; r !== void 0 && r[n] === void 0;) r = a[i++];
                if (r === void 0) return;
                let s = r[n];
                if (s !== void 0)
                    if (Array.isArray(s))
                        do s = r[n], s !== void 0 && (e.push(r.time), t.push.apply(t, s)), r = a[i++]; while (r !== void 0);
                    else if (s.toArray !== void 0)
                    do s = r[n], s !== void 0 && (e.push(r.time), s.toArray(t, t.length)), r = a[i++]; while (r !== void 0);
                else
                    do s = r[n], s !== void 0 && (e.push(r.time), t.push(s)), r = a[i++]; while (r !== void 0)
            },
            subclip: function(a, e, t, n, i = 30) {
                const r = a.clone();
                r.name = e;
                const s = [];
                for (let l = 0; l < r.tracks.length; ++l) {
                    const c = r.tracks[l],
                        u = c.getValueSize(),
                        h = [],
                        f = [];
                    for (let d = 0; d < c.times.length; ++d) {
                        const m = c.times[d] * i;
                        if (!(m < t || m >= n)) {
                            h.push(c.times[d]);
                            for (let g = 0; g < u; ++g) f.push(c.values[d * u + g])
                        }
                    }
                    h.length !== 0 && (c.times = je.convertArray(h, c.times.constructor), c.values = je.convertArray(f, c.values.constructor), s.push(c))
                }
                r.tracks = s;
                let o = 1 / 0;
                for (let l = 0; l < r.tracks.length; ++l) o > r.tracks[l].times[0] && (o = r.tracks[l].times[0]);
                for (let l = 0; l < r.tracks.length; ++l) r.tracks[l].shift(-1 * o);
                return r.resetDuration(), r
            },
            makeClipAdditive: function(a, e = 0, t = a, n = 30) {
                n <= 0 && (n = 30);
                const i = t.tracks.length,
                    r = e / n;
                for (let s = 0; s < i; ++s) {
                    const o = t.tracks[s],
                        l = o.ValueTypeName;
                    if (l === "bool" || l === "string") continue;
                    const c = a.tracks.find(function(p) {
                        return p.name === o.name && p.ValueTypeName === l
                    });
                    if (c === void 0) continue;
                    let u = 0;
                    const h = o.getValueSize();
                    o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (u = h / 3);
                    let f = 0;
                    const d = c.getValueSize();
                    c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (f = d / 3);
                    const m = o.times.length - 1;
                    let g;
                    if (r <= o.times[0]) {
                        const p = u,
                            _ = h - u;
                        g = je.arraySlice(o.values, p, _)
                    } else if (r >= o.times[m]) {
                        const p = m * h + u,
                            _ = p + h - u;
                        g = je.arraySlice(o.values, p, _)
                    } else {
                        const p = o.createInterpolant(),
                            _ = u,
                            M = h - u;
                        p.evaluate(r), g = je.arraySlice(p.resultBuffer, _, M)
                    }
                    l === "quaternion" && new At().fromArray(g).normalize().conjugate().toArray(g);
                    const v = c.times.length;
                    for (let p = 0; p < v; ++p) {
                        const _ = p * d + f;
                        if (l === "quaternion") At.multiplyQuaternionsFlat(c.values, _, g, 0, c.values, _);
                        else {
                            const M = d - f * 2;
                            for (let y = 0; y < M; ++y) c.values[_ + y] -= g[y]
                        }
                    }
                }
                return a.blendMode = Wc, a
            }
        };
        class Ln {
            constructor(e, t, n, i) {
                this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = i !== void 0 ? i : new t.constructor(n), this.sampleValues = t, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {}
            }
            evaluate(e) {
                const t = this.parameterPositions;
                let n = this._cachedIndex,
                    i = t[n],
                    r = t[n - 1];
                e: {
                    t: {
                        let s;n: {
                            i: if (!(e < i)) {
                                for (let o = n + 2;;) {
                                    if (i === void 0) {
                                        if (e < r) break i;
                                        return n = t.length, this._cachedIndex = n, this.afterEnd_(n - 1, e, r)
                                    }
                                    if (n === o) break;
                                    if (r = i, i = t[++n], e < i) break t
                                }
                                s = t.length;
                                break n
                            }if (!(e >= r)) {
                                const o = t[1];
                                e < o && (n = 2, r = o);
                                for (let l = n - 2;;) {
                                    if (r === void 0) return this._cachedIndex = 0, this.beforeStart_(0, e, i);
                                    if (n === l) break;
                                    if (i = r, r = t[--n - 1], e >= r) break t
                                }
                                s = n, n = 0;
                                break n
                            }
                            break e
                        }
                        for (; n < s;) {
                            const o = n + s >>> 1;
                            e < t[o] ? s = o : n = o + 1
                        }
                        if (i = t[n], r = t[n - 1], r === void 0) return this._cachedIndex = 0, this.beforeStart_(0, e, i);
                        if (i === void 0) return n = t.length, this._cachedIndex = n, this.afterEnd_(n - 1, r, e)
                    }
                    this._cachedIndex = n,
                    this.intervalChanged_(n, r, i)
                }
                return this.interpolate_(n, r, e, i)
            }
            getSettings_() {
                return this.settings || this.DefaultSettings_
            }
            copySampleValue_(e) {
                const t = this.resultBuffer,
                    n = this.sampleValues,
                    i = this.valueSize,
                    r = e * i;
                for (let s = 0; s !== i; ++s) t[s] = n[r + s];
                return t
            }
            interpolate_() {
                throw new Error("call to abstract method")
            }
            intervalChanged_() {}
        }
        Ln.prototype.beforeStart_ = Ln.prototype.copySampleValue_, Ln.prototype.afterEnd_ = Ln.prototype.copySampleValue_;
        class gx extends Ln {
            constructor(e, t, n, i) {
                super(e, t, n, i);
                this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
                    endingStart: Zi,
                    endingEnd: Zi
                }
            }
            intervalChanged_(e, t, n) {
                const i = this.parameterPositions;
                let r = e - 2,
                    s = e + 1,
                    o = i[r],
                    l = i[s];
                if (o === void 0) switch (this.getSettings_().endingStart) {
                    case Ji:
                        r = e, o = 2 * t - n;
                        break;
                    case Ks:
                        r = i.length - 2, o = t + i[r] - i[r + 1];
                        break;
                    default:
                        r = e, o = n
                }
                if (l === void 0) switch (this.getSettings_().endingEnd) {
                    case Ji:
                        s = e, l = 2 * n - t;
                        break;
                    case Ks:
                        s = 1, l = n + i[1] - i[0];
                        break;
                    default:
                        s = e - 1, l = t
                }
                const c = (n - t) * .5,
                    u = this.valueSize;
                this._weightPrev = c / (t - o), this._weightNext = c / (l - n), this._offsetPrev = r * u, this._offsetNext = s * u
            }
            interpolate_(e, t, n, i) {
                const r = this.resultBuffer,
                    s = this.sampleValues,
                    o = this.valueSize,
                    l = e * o,
                    c = l - o,
                    u = this._offsetPrev,
                    h = this._offsetNext,
                    f = this._weightPrev,
                    d = this._weightNext,
                    m = (n - t) / (i - t),
                    g = m * m,
                    v = g * m,
                    p = -f * v + 2 * f * g - f * m,
                    _ = (1 + f) * v + (-1.5 - 2 * f) * g + (-.5 + f) * m + 1,
                    M = (-1 - d) * v + (1.5 + d) * g + .5 * m,
                    y = d * v - d * g;
                for (let b = 0; b !== o; ++b) r[b] = p * s[u + b] + _ * s[c + b] + M * s[l + b] + y * s[h + b];
                return r
            }
        }
        class Fh extends Ln {
            constructor(e, t, n, i) {
                super(e, t, n, i)
            }
            interpolate_(e, t, n, i) {
                const r = this.resultBuffer,
                    s = this.sampleValues,
                    o = this.valueSize,
                    l = e * o,
                    c = l - o,
                    u = (n - t) / (i - t),
                    h = 1 - u;
                for (let f = 0; f !== o; ++f) r[f] = s[c + f] * h + s[l + f] * u;
                return r
            }
        }
        class _x extends Ln {
            constructor(e, t, n, i) {
                super(e, t, n, i)
            }
            interpolate_(e) {
                return this.copySampleValue_(e - 1)
            }
        }
        class dn {
            constructor(e, t, n, i) {
                if (e === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined");
                if (t === void 0 || t.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
                this.name = e, this.times = je.convertArray(t, this.TimeBufferType), this.values = je.convertArray(n, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation)
            }
            static toJSON(e) {
                const t = e.constructor;
                let n;
                if (t.toJSON !== this.toJSON) n = t.toJSON(e);
                else {
                    n = {
                        name: e.name,
                        times: je.convertArray(e.times, Array),
                        values: je.convertArray(e.values, Array)
                    };
                    const i = e.getInterpolation();
                    i !== e.DefaultInterpolation && (n.interpolation = i)
                }
                return n.type = e.ValueTypeName, n
            }
            InterpolantFactoryMethodDiscrete(e) {
                return new _x(this.times, this.values, this.getValueSize(), e)
            }
            InterpolantFactoryMethodLinear(e) {
                return new Fh(this.times, this.values, this.getValueSize(), e)
            }
            InterpolantFactoryMethodSmooth(e) {
                return new gx(this.times, this.values, this.getValueSize(), e)
            }
            setInterpolation(e) {
                let t;
                switch (e) {
                    case Qr:
                        t = this.InterpolantFactoryMethodDiscrete;
                        break;
                    case Yi:
                        t = this.InterpolantFactoryMethodLinear;
                        break;
                    case lo:
                        t = this.InterpolantFactoryMethodSmooth;
                        break
                }
                if (t === void 0) {
                    const n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                    if (this.createInterpolant === void 0)
                        if (e !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation);
                        else throw new Error(n);
                    return console.warn("THREE.KeyframeTrack:", n), this
                }
                return this.createInterpolant = t, this
            }
            getInterpolation() {
                switch (this.createInterpolant) {
                    case this.InterpolantFactoryMethodDiscrete:
                        return Qr;
                    case this.InterpolantFactoryMethodLinear:
                        return Yi;
                    case this.InterpolantFactoryMethodSmooth:
                        return lo
                }
            }
            getValueSize() {
                return this.values.length / this.times.length
            }
            shift(e) {
                if (e !== 0) {
                    const t = this.times;
                    for (let n = 0, i = t.length; n !== i; ++n) t[n] += e
                }
                return this
            }
            scale(e) {
                if (e !== 1) {
                    const t = this.times;
                    for (let n = 0, i = t.length; n !== i; ++n) t[n] *= e
                }
                return this
            }
            trim(e, t) {
                const n = this.times,
                    i = n.length;
                let r = 0,
                    s = i - 1;
                for (; r !== i && n[r] < e;) ++r;
                for (; s !== -1 && n[s] > t;) --s;
                if (++s, r !== 0 || s !== i) {
                    r >= s && (s = Math.max(s, 1), r = s - 1);
                    const o = this.getValueSize();
                    this.times = je.arraySlice(n, r, s), this.values = je.arraySlice(this.values, r * o, s * o)
                }
                return this
            }
            validate() {
                let e = !0;
                const t = this.getValueSize();
                t - Math.floor(t) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
                const n = this.times,
                    i = this.values,
                    r = n.length;
                r === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
                let s = null;
                for (let o = 0; o !== r; o++) {
                    const l = n[o];
                    if (typeof l == "number" && isNaN(l)) {
                        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, o, l), e = !1;
                        break
                    }
                    if (s !== null && s > l) {
                        console.error("THREE.KeyframeTrack: Out of order keys.", this, o, l, s), e = !1;
                        break
                    }
                    s = l
                }
                if (i !== void 0 && je.isTypedArray(i))
                    for (let o = 0, l = i.length; o !== l; ++o) {
                        const c = i[o];
                        if (isNaN(c)) {
                            console.error("THREE.KeyframeTrack: Value is not a valid number.", this, o, c), e = !1;
                            break
                        }
                    }
                return e
            }
            optimize() {
                const e = je.arraySlice(this.times),
                    t = je.arraySlice(this.values),
                    n = this.getValueSize(),
                    i = this.getInterpolation() === lo,
                    r = e.length - 1;
                let s = 1;
                for (let o = 1; o < r; ++o) {
                    let l = !1;
                    const c = e[o],
                        u = e[o + 1];
                    if (c !== u && (o !== 1 || c !== e[0]))
                        if (i) l = !0;
                        else {
                            const h = o * n,
                                f = h - n,
                                d = h + n;
                            for (let m = 0; m !== n; ++m) {
                                const g = t[h + m];
                                if (g !== t[f + m] || g !== t[d + m]) {
                                    l = !0;
                                    break
                                }
                            }
                        }
                    if (l) {
                        if (o !== s) {
                            e[s] = e[o];
                            const h = o * n,
                                f = s * n;
                            for (let d = 0; d !== n; ++d) t[f + d] = t[h + d]
                        }++s
                    }
                }
                if (r > 0) {
                    e[s] = e[r];
                    for (let o = r * n, l = s * n, c = 0; c !== n; ++c) t[l + c] = t[o + c];
                    ++s
                }
                return s !== e.length ? (this.times = je.arraySlice(e, 0, s), this.values = je.arraySlice(t, 0, s * n)) : (this.times = e, this.values = t), this
            }
            clone() {
                const e = je.arraySlice(this.times, 0),
                    t = je.arraySlice(this.values, 0),
                    n = this.constructor,
                    i = new n(this.name, e, t);
                return i.createInterpolant = this.createInterpolant, i
            }
        }
        dn.prototype.TimeBufferType = Float32Array, dn.prototype.ValueBufferType = Float32Array, dn.prototype.DefaultInterpolation = Yi;
        class Cr extends dn {}
        Cr.prototype.ValueTypeName = "bool", Cr.prototype.ValueBufferType = Array, Cr.prototype.DefaultInterpolation = Qr, Cr.prototype.InterpolantFactoryMethodLinear = void 0, Cr.prototype.InterpolantFactoryMethodSmooth = void 0;
        class zh extends dn {}
        zh.prototype.ValueTypeName = "color";
        class Ms extends dn {}
        Ms.prototype.ValueTypeName = "number";
        class vx extends Ln {
            constructor(e, t, n, i) {
                super(e, t, n, i)
            }
            interpolate_(e, t, n, i) {
                const r = this.resultBuffer,
                    s = this.sampleValues,
                    o = this.valueSize,
                    l = (n - t) / (i - t);
                let c = e * o;
                for (let u = c + o; c !== u; c += 4) At.slerpFlat(r, 0, s, c - o, s, c, l);
                return r
            }
        }
        class Li extends dn {
            InterpolantFactoryMethodLinear(e) {
                return new vx(this.times, this.values, this.getValueSize(), e)
            }
        }
        Li.prototype.ValueTypeName = "quaternion", Li.prototype.DefaultInterpolation = Yi, Li.prototype.InterpolantFactoryMethodSmooth = void 0;
        class Pr extends dn {}
        Pr.prototype.ValueTypeName = "string", Pr.prototype.ValueBufferType = Array, Pr.prototype.DefaultInterpolation = Qr, Pr.prototype.InterpolantFactoryMethodLinear = void 0, Pr.prototype.InterpolantFactoryMethodSmooth = void 0;
        class bs extends dn {}
        bs.prototype.ValueTypeName = "vector";
        class pl {
            constructor(e, t = -1, n, i = co) {
                this.name = e, this.tracks = n, this.duration = t, this.blendMode = i, this.uuid = Xt(), this.duration < 0 && this.resetDuration()
            }
            static parse(e) {
                const t = [],
                    n = e.tracks,
                    i = 1 / (e.fps || 1);
                for (let s = 0, o = n.length; s !== o; ++s) t.push(yx(n[s]).scale(i));
                const r = new this(e.name, e.duration, t, e.blendMode);
                return r.uuid = e.uuid, r
            }
            static toJSON(e) {
                const t = [],
                    n = e.tracks,
                    i = {
                        name: e.name,
                        duration: e.duration,
                        tracks: t,
                        uuid: e.uuid,
                        blendMode: e.blendMode
                    };
                for (let r = 0, s = n.length; r !== s; ++r) t.push(dn.toJSON(n[r]));
                return i
            }
            static CreateFromMorphTargetSequence(e, t, n, i) {
                const r = t.length,
                    s = [];
                for (let o = 0; o < r; o++) {
                    let l = [],
                        c = [];
                    l.push((o + r - 1) % r, o, (o + 1) % r), c.push(0, 1, 0);
                    const u = je.getKeyframeOrder(l);
                    l = je.sortedArray(l, 1, u), c = je.sortedArray(c, 1, u), !i && l[0] === 0 && (l.push(r), c.push(c[0])), s.push(new Ms(".morphTargetInfluences[" + t[o].name + "]", l, c).scale(1 / n))
                }
                return new this(e, -1, s)
            }
            static findByName(e, t) {
                let n = e;
                if (!Array.isArray(e)) {
                    const i = e;
                    n = i.geometry && i.geometry.animations || i.animations
                }
                for (let i = 0; i < n.length; i++)
                    if (n[i].name === t) return n[i];
                return null
            }
            static CreateClipsFromMorphTargetSequences(e, t, n) {
                const i = {},
                    r = /^([\w-]*?)([\d]+)$/;
                for (let o = 0, l = e.length; o < l; o++) {
                    const c = e[o],
                        u = c.name.match(r);
                    if (u && u.length > 1) {
                        const h = u[1];
                        let f = i[h];
                        f || (i[h] = f = []), f.push(c)
                    }
                }
                const s = [];
                for (const o in i) s.push(this.CreateFromMorphTargetSequence(o, i[o], t, n));
                return s
            }
            static parseAnimation(e, t) {
                if (!e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
                const n = function(h, f, d, m, g) {
                        if (d.length !== 0) {
                            const v = [],
                                p = [];
                            je.flattenJSON(d, v, p, m), v.length !== 0 && g.push(new h(f, v, p))
                        }
                    },
                    i = [],
                    r = e.name || "default",
                    s = e.fps || 30,
                    o = e.blendMode;
                let l = e.length || -1;
                const c = e.hierarchy || [];
                for (let h = 0; h < c.length; h++) {
                    const f = c[h].keys;
                    if (!(!f || f.length === 0))
                        if (f[0].morphTargets) {
                            const d = {};
                            let m;
                            for (m = 0; m < f.length; m++)
                                if (f[m].morphTargets)
                                    for (let g = 0; g < f[m].morphTargets.length; g++) d[f[m].morphTargets[g]] = -1;
                            for (const g in d) {
                                const v = [],
                                    p = [];
                                for (let _ = 0; _ !== f[m].morphTargets.length; ++_) {
                                    const M = f[m];
                                    v.push(M.time), p.push(M.morphTarget === g ? 1 : 0)
                                }
                                i.push(new Ms(".morphTargetInfluence[" + g + "]", v, p))
                            }
                            l = d.length * (s || 1)
                        } else {
                            const d = ".bones[" + t[h].name + "]";
                            n(bs, d + ".position", f, "pos", i), n(Li, d + ".quaternion", f, "rot", i), n(bs, d + ".scale", f, "scl", i)
                        }
                }
                return i.length === 0 ? null : new this(r, l, i, o)
            }
            resetDuration() {
                const e = this.tracks;
                let t = 0;
                for (let n = 0, i = e.length; n !== i; ++n) {
                    const r = this.tracks[n];
                    t = Math.max(t, r.times[r.times.length - 1])
                }
                return this.duration = t, this
            }
            trim() {
                for (let e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration);
                return this
            }
            validate() {
                let e = !0;
                for (let t = 0; t < this.tracks.length; t++) e = e && this.tracks[t].validate();
                return e
            }
            optimize() {
                for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
                return this
            }
            clone() {
                const e = [];
                for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
                return new this.constructor(this.name, this.duration, e, this.blendMode)
            }
            toJSON() {
                return this.constructor.toJSON(this)
            }
        }

        function xx(a) {
            switch (a.toLowerCase()) {
                case "scalar":
                case "double":
                case "float":
                case "number":
                case "integer":
                    return Ms;
                case "vector":
                case "vector2":
                case "vector3":
                case "vector4":
                    return bs;
                case "color":
                    return zh;
                case "quaternion":
                    return Li;
                case "bool":
                case "boolean":
                    return Cr;
                case "string":
                    return Pr
            }
            throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + a)
        }

        function yx(a) {
            if (a.type === void 0) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
            const e = xx(a.type);
            if (a.times === void 0) {
                const t = [],
                    n = [];
                je.flattenJSON(a.keys, t, n, "value"), a.times = t, a.values = n
            }
            return e.parse !== void 0 ? e.parse(a) : new e(a.name, a.times, a.values, a.interpolation)
        }
        const Dr = {
            enabled: !1,
            files: {},
            add: function(a, e) {
                this.enabled !== !1 && (this.files[a] = e)
            },
            get: function(a) {
                if (this.enabled !== !1) return this.files[a]
            },
            remove: function(a) {
                delete this.files[a]
            },
            clear: function() {
                this.files = {}
            }
        };
        class Mx {
            constructor(e, t, n) {
                const i = this;
                let r = !1,
                    s = 0,
                    o = 0,
                    l;
                const c = [];
                this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = n, this.itemStart = function(u) {
                    o++, r === !1 && i.onStart !== void 0 && i.onStart(u, s, o), r = !0
                }, this.itemEnd = function(u) {
                    s++, i.onProgress !== void 0 && i.onProgress(u, s, o), s === o && (r = !1, i.onLoad !== void 0 && i.onLoad())
                }, this.itemError = function(u) {
                    i.onError !== void 0 && i.onError(u)
                }, this.resolveURL = function(u) {
                    return l ? l(u) : u
                }, this.setURLModifier = function(u) {
                    return l = u, this
                }, this.addHandler = function(u, h) {
                    return c.push(u, h), this
                }, this.removeHandler = function(u) {
                    const h = c.indexOf(u);
                    return h !== -1 && c.splice(h, 2), this
                }, this.getHandler = function(u) {
                    for (let h = 0, f = c.length; h < f; h += 2) {
                        const d = c[h],
                            m = c[h + 1];
                        if (d.global && (d.lastIndex = 0), d.test(u)) return m
                    }
                    return null
                }
            }
        }
        const bx = new Mx;
        class Rn {
            constructor(e) {
                this.manager = e !== void 0 ? e : bx, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {}
            }
            load() {}
            loadAsync(e, t) {
                const n = this;
                return new Promise(function(i, r) {
                    n.load(e, i, t, r)
                })
            }
            parse() {}
            setCrossOrigin(e) {
                return this.crossOrigin = e, this
            }
            setWithCredentials(e) {
                return this.withCredentials = e, this
            }
            setPath(e) {
                return this.path = e, this
            }
            setResourcePath(e) {
                return this.resourcePath = e, this
            }
            setRequestHeader(e) {
                return this.requestHeader = e, this
            }
        }
        const on = {};
        class ml extends Rn {
            constructor(e) {
                super(e)
            }
            load(e, t, n, i) {
                e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
                const r = this,
                    s = Dr.get(e);
                if (s !== void 0) return r.manager.itemStart(e), setTimeout(function() {
                    t && t(s), r.manager.itemEnd(e)
                }, 0), s;
                if (on[e] !== void 0) {
                    on[e].push({
                        onLoad: t,
                        onProgress: n,
                        onError: i
                    });
                    return
                }
                const o = /^data:(.*?)(;base64)?,(.*)$/,
                    l = e.match(o);
                let c;
                if (l) {
                    const u = l[1],
                        h = !!l[2];
                    let f = l[3];
                    f = decodeURIComponent(f), h && (f = atob(f));
                    try {
                        let d;
                        const m = (this.responseType || "").toLowerCase();
                        switch (m) {
                            case "arraybuffer":
                            case "blob":
                                const g = new Uint8Array(f.length);
                                for (let p = 0; p < f.length; p++) g[p] = f.charCodeAt(p);
                                m === "blob" ? d = new Blob([g.buffer], {
                                    type: u
                                }) : d = g.buffer;
                                break;
                            case "document":
                                d = new DOMParser().parseFromString(f, u);
                                break;
                            case "json":
                                d = JSON.parse(f);
                                break;
                            default:
                                d = f;
                                break
                        }
                        setTimeout(function() {
                            t && t(d), r.manager.itemEnd(e)
                        }, 0)
                    } catch (d) {
                        setTimeout(function() {
                            i && i(d), r.manager.itemError(e), r.manager.itemEnd(e)
                        }, 0)
                    }
                } else {
                    on[e] = [], on[e].push({
                        onLoad: t,
                        onProgress: n,
                        onError: i
                    }), c = new XMLHttpRequest, c.open("GET", e, !0), c.addEventListener("load", function(u) {
                        const h = this.response,
                            f = on[e];
                        if (delete on[e], this.status === 200 || this.status === 0) {
                            this.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), Dr.add(e, h);
                            for (let d = 0, m = f.length; d < m; d++) {
                                const g = f[d];
                                g.onLoad && g.onLoad(h)
                            }
                            r.manager.itemEnd(e)
                        } else {
                            for (let d = 0, m = f.length; d < m; d++) {
                                const g = f[d];
                                g.onError && g.onError(u)
                            }
                            r.manager.itemError(e), r.manager.itemEnd(e)
                        }
                    }, !1), c.addEventListener("progress", function(u) {
                        const h = on[e];
                        for (let f = 0, d = h.length; f < d; f++) {
                            const m = h[f];
                            m.onProgress && m.onProgress(u)
                        }
                    }, !1), c.addEventListener("error", function(u) {
                        const h = on[e];
                        delete on[e];
                        for (let f = 0, d = h.length; f < d; f++) {
                            const m = h[f];
                            m.onError && m.onError(u)
                        }
                        r.manager.itemError(e), r.manager.itemEnd(e)
                    }, !1), c.addEventListener("abort", function(u) {
                        const h = on[e];
                        delete on[e];
                        for (let f = 0, d = h.length; f < d; f++) {
                            const m = h[f];
                            m.onError && m.onError(u)
                        }
                        r.manager.itemError(e), r.manager.itemEnd(e)
                    }, !1), this.responseType !== void 0 && (c.responseType = this.responseType), this.withCredentials !== void 0 && (c.withCredentials = this.withCredentials), c.overrideMimeType && c.overrideMimeType(this.mimeType !== void 0 ? this.mimeType : "text/plain");
                    for (const u in this.requestHeader) c.setRequestHeader(u, this.requestHeader[u]);
                    c.send(null)
                }
                return r.manager.itemStart(e), c
            }
            setResponseType(e) {
                return this.responseType = e, this
            }
            setMimeType(e) {
                return this.mimeType = e, this
            }
        }
        class Nh extends Rn {
            constructor(e) {
                super(e)
            }
            load(e, t, n, i) {
                this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
                const r = this,
                    s = Dr.get(e);
                if (s !== void 0) return r.manager.itemStart(e), setTimeout(function() {
                    t && t(s), r.manager.itemEnd(e)
                }, 0), s;
                const o = ea("img");

                function l() {
                    o.removeEventListener("load", l, !1), o.removeEventListener("error", c, !1), Dr.add(e, this), t && t(this), r.manager.itemEnd(e)
                }

                function c(u) {
                    o.removeEventListener("load", l, !1), o.removeEventListener("error", c, !1), i && i(u), r.manager.itemError(e), r.manager.itemEnd(e)
                }
                return o.addEventListener("load", l, !1), o.addEventListener("error", c, !1), e.substr(0, 5) !== "data:" && this.crossOrigin !== void 0 && (o.crossOrigin = this.crossOrigin), r.manager.itemStart(e), o.src = e, o
            }
        }
        class wx extends Rn {
            constructor(e) {
                super(e)
            }
            load(e, t, n, i) {
                const r = new va,
                    s = new Nh(this.manager);
                s.setCrossOrigin(this.crossOrigin), s.setPath(this.path);
                let o = 0;

                function l(c) {
                    s.load(e[c], function(u) {
                        r.images[c] = u, o++, o === 6 && (r.needsUpdate = !0, t && t(r))
                    }, void 0, i)
                }
                for (let c = 0; c < e.length; ++c) l(c);
                return r
            }
        }
        class gl extends Rn {
            constructor(e) {
                super(e)
            }
            load(e, t, n, i) {
                const r = new at,
                    s = new Nh(this.manager);
                return s.setCrossOrigin(this.crossOrigin), s.setPath(this.path), s.load(e, function(o) {
                    r.image = o, r.needsUpdate = !0, t !== void 0 && t(r)
                }, n, i), r
            }
        }
        class pn extends Te {
            constructor(e, t = 1) {
                super();
                this.type = "Light", this.color = new ne(e), this.intensity = t
            }
            dispose() {}
            copy(e) {
                return super.copy(e), this.color.copy(e.color), this.intensity = e.intensity, this
            }
            toJSON(e) {
                const t = super.toJSON(e);
                return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (t.object.distance = this.distance), this.angle !== void 0 && (t.object.angle = this.angle), this.decay !== void 0 && (t.object.decay = this.decay), this.penumbra !== void 0 && (t.object.penumbra = this.penumbra), this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()), t
            }
        }
        pn.prototype.isLight = !0;
        class Sx extends pn {
            constructor(e, t, n) {
                super(e, n);
                this.type = "HemisphereLight", this.position.copy(Te.DefaultUp), this.updateMatrix(), this.groundColor = new ne(t)
            }
            copy(e) {
                return pn.prototype.copy.call(this, e), this.groundColor.copy(e.groundColor), this
            }
        }
        Sx.prototype.isHemisphereLight = !0;
        const Bh = new fe,
            Oh = new E,
            Uh = new E;
        class _l {
            constructor(e) {
                this.camera = e, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new X(512, 512), this.map = null, this.mapPass = null, this.matrix = new fe, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new ya, this._frameExtents = new X(1, 1), this._viewportCount = 1, this._viewports = [new Ue(0, 0, 1, 1)]
            }
            getViewportCount() {
                return this._viewportCount
            }
            getFrustum() {
                return this._frustum
            }
            updateMatrices(e) {
                const t = this.camera,
                    n = this.matrix;
                Oh.setFromMatrixPosition(e.matrixWorld), t.position.copy(Oh), Uh.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(Uh), t.updateMatrixWorld(), Bh.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Bh), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(t.projectionMatrix), n.multiply(t.matrixWorldInverse)
            }
            getViewport(e) {
                return this._viewports[e]
            }
            getFrameExtents() {
                return this._frameExtents
            }
            dispose() {
                this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose()
            }
            copy(e) {
                return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this
            }
            clone() {
                return new this.constructor().copy(this)
            }
            toJSON() {
                const e = {};
                return this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e
            }
        }
        class kh extends _l {
            constructor() {
                super(new yt(50, 1, .5, 500));
                this.focus = 1
            }
            updateMatrices(e) {
                const t = this.camera,
                    n = ns * 2 * e.angle * this.focus,
                    i = this.mapSize.width / this.mapSize.height,
                    r = e.distance || t.far;
                (n !== t.fov || i !== t.aspect || r !== t.far) && (t.fov = n, t.aspect = i, t.far = r, t.updateProjectionMatrix()), super.updateMatrices(e)
            }
            copy(e) {
                return super.copy(e), this.focus = e.focus, this
            }
        }
        kh.prototype.isSpotLightShadow = !0;
        class Gh extends pn {
            constructor(e, t, n = 0, i = Math.PI / 3, r = 0, s = 1) {
                super(e, t);
                this.type = "SpotLight", this.position.copy(Te.DefaultUp), this.updateMatrix(), this.target = new Te, this.distance = n, this.angle = i, this.penumbra = r, this.decay = s, this.shadow = new kh
            }
            get power() {
                return this.intensity * Math.PI
            }
            set power(e) {
                this.intensity = e / Math.PI
            }
            dispose() {
                this.shadow.dispose()
            }
            copy(e) {
                return super.copy(e), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
            }
        }
        Gh.prototype.isSpotLight = !0;
        const Hh = new fe,
            ws = new E,
            vl = new E;
        class Vh extends _l {
            constructor() {
                super(new yt(90, 1, .5, 500));
                this._frameExtents = new X(4, 2), this._viewportCount = 6, this._viewports = [new Ue(2, 1, 1, 1), new Ue(0, 1, 1, 1), new Ue(3, 1, 1, 1), new Ue(1, 1, 1, 1), new Ue(3, 0, 1, 1), new Ue(1, 0, 1, 1)], this._cubeDirections = [new E(1, 0, 0), new E(-1, 0, 0), new E(0, 0, 1), new E(0, 0, -1), new E(0, 1, 0), new E(0, -1, 0)], this._cubeUps = [new E(0, 1, 0), new E(0, 1, 0), new E(0, 1, 0), new E(0, 1, 0), new E(0, 0, 1), new E(0, 0, -1)]
            }
            updateMatrices(e, t = 0) {
                const n = this.camera,
                    i = this.matrix,
                    r = e.distance || n.far;
                r !== n.far && (n.far = r, n.updateProjectionMatrix()), ws.setFromMatrixPosition(e.matrixWorld), n.position.copy(ws), vl.copy(n.position), vl.add(this._cubeDirections[t]), n.up.copy(this._cubeUps[t]), n.lookAt(vl), n.updateMatrixWorld(), i.makeTranslation(-ws.x, -ws.y, -ws.z), Hh.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Hh)
            }
        }
        Vh.prototype.isPointLightShadow = !0;
        class Ss extends pn {
            constructor(e, t, n = 0, i = 1) {
                super(e, t);
                this.type = "PointLight", this.distance = n, this.decay = i, this.shadow = new Vh
            }
            get power() {
                return this.intensity * 4 * Math.PI
            }
            set power(e) {
                this.intensity = e / (4 * Math.PI)
            }
            dispose() {
                this.shadow.dispose()
            }
            copy(e) {
                return super.copy(e), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this
            }
        }
        Ss.prototype.isPointLight = !0;
        class Wh extends _l {
            constructor() {
                super(new dr(-5, 5, 5, -5, .5, 500))
            }
        }
        Wh.prototype.isDirectionalLightShadow = !0;
        class xl extends pn {
            constructor(e, t) {
                super(e, t);
                this.type = "DirectionalLight", this.position.copy(Te.DefaultUp), this.updateMatrix(), this.target = new Te, this.shadow = new Wh
            }
            dispose() {
                this.shadow.dispose()
            }
            copy(e) {
                return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
            }
        }
        xl.prototype.isDirectionalLight = !0;
        class Tx extends pn {
            constructor(e, t) {
                super(e, t);
                this.type = "AmbientLight"
            }
        }
        Tx.prototype.isAmbientLight = !0;
        class Ex extends pn {
            constructor(e, t, n = 10, i = 10) {
                super(e, t);
                this.type = "RectAreaLight", this.width = n, this.height = i
            }
            get power() {
                return this.intensity * this.width * this.height * Math.PI
            }
            set power(e) {
                this.intensity = e / (this.width * this.height * Math.PI)
            }
            copy(e) {
                return super.copy(e), this.width = e.width, this.height = e.height, this
            }
            toJSON(e) {
                const t = super.toJSON(e);
                return t.object.width = this.width, t.object.height = this.height, t
            }
        }
        Ex.prototype.isRectAreaLight = !0;
        class qh {
            constructor() {
                this.coefficients = [];
                for (let e = 0; e < 9; e++) this.coefficients.push(new E)
            }
            set(e) {
                for (let t = 0; t < 9; t++) this.coefficients[t].copy(e[t]);
                return this
            }
            zero() {
                for (let e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
                return this
            }
            getAt(e, t) {
                const n = e.x,
                    i = e.y,
                    r = e.z,
                    s = this.coefficients;
                return t.copy(s[0]).multiplyScalar(.282095), t.addScaledVector(s[1], .488603 * i), t.addScaledVector(s[2], .488603 * r), t.addScaledVector(s[3], .488603 * n), t.addScaledVector(s[4], 1.092548 * (n * i)), t.addScaledVector(s[5], 1.092548 * (i * r)), t.addScaledVector(s[6], .315392 * (3 * r * r - 1)), t.addScaledVector(s[7], 1.092548 * (n * r)), t.addScaledVector(s[8], .546274 * (n * n - i * i)), t
            }
            getIrradianceAt(e, t) {
                const n = e.x,
                    i = e.y,
                    r = e.z,
                    s = this.coefficients;
                return t.copy(s[0]).multiplyScalar(.886227), t.addScaledVector(s[1], 2 * .511664 * i), t.addScaledVector(s[2], 2 * .511664 * r), t.addScaledVector(s[3], 2 * .511664 * n), t.addScaledVector(s[4], 2 * .429043 * n * i), t.addScaledVector(s[5], 2 * .429043 * i * r), t.addScaledVector(s[6], .743125 * r * r - .247708), t.addScaledVector(s[7], 2 * .429043 * n * r), t.addScaledVector(s[8], .429043 * (n * n - i * i)), t
            }
            add(e) {
                for (let t = 0; t < 9; t++) this.coefficients[t].add(e.coefficients[t]);
                return this
            }
            addScaledSH(e, t) {
                for (let n = 0; n < 9; n++) this.coefficients[n].addScaledVector(e.coefficients[n], t);
                return this
            }
            scale(e) {
                for (let t = 0; t < 9; t++) this.coefficients[t].multiplyScalar(e);
                return this
            }
            lerp(e, t) {
                for (let n = 0; n < 9; n++) this.coefficients[n].lerp(e.coefficients[n], t);
                return this
            }
            equals(e) {
                for (let t = 0; t < 9; t++)
                    if (!this.coefficients[t].equals(e.coefficients[t])) return !1;
                return !0
            }
            copy(e) {
                return this.set(e.coefficients)
            }
            clone() {
                return new this.constructor().copy(this)
            }
            fromArray(e, t = 0) {
                const n = this.coefficients;
                for (let i = 0; i < 9; i++) n[i].fromArray(e, t + i * 3);
                return this
            }
            toArray(e = [], t = 0) {
                const n = this.coefficients;
                for (let i = 0; i < 9; i++) n[i].toArray(e, t + i * 3);
                return e
            }
            static getBasisAt(e, t) {
                const n = e.x,
                    i = e.y,
                    r = e.z;
                t[0] = .282095, t[1] = .488603 * i, t[2] = .488603 * r, t[3] = .488603 * n, t[4] = 1.092548 * n * i, t[5] = 1.092548 * i * r, t[6] = .315392 * (3 * r * r - 1), t[7] = 1.092548 * n * r, t[8] = .546274 * (n * n - i * i)
            }
        }
        qh.prototype.isSphericalHarmonics3 = !0;
        class yl extends pn {
            constructor(e = new qh, t = 1) {
                super(void 0, t);
                this.sh = e
            }
            copy(e) {
                return super.copy(e), this.sh.copy(e.sh), this
            }
            fromJSON(e) {
                return this.intensity = e.intensity, this.sh.fromArray(e.sh), this
            }
            toJSON(e) {
                const t = super.toJSON(e);
                return t.object.sh = this.sh.toArray(), t
            }
        }
        yl.prototype.isLightProbe = !0;
        class Ir {
            static decodeText(e) {
                if (typeof TextDecoder != "undefined") return new TextDecoder().decode(e);
                let t = "";
                for (let n = 0, i = e.length; n < i; n++) t += String.fromCharCode(e[n]);
                try {
                    return decodeURIComponent(escape(t))
                } catch {
                    return t
                }
            }
            static extractUrlBase(e) {
                const t = e.lastIndexOf("/");
                return t === -1 ? "./" : e.substr(0, t + 1)
            }
        }
        class Ax extends ke {
            constructor() {
                super();
                this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0
            }
            copy(e) {
                return super.copy(e), this.instanceCount = e.instanceCount, this
            }
            clone() {
                return new this.constructor().copy(this)
            }
            toJSON() {
                const e = super.toJSON(this);
                return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e
            }
        }
        Ax.prototype.isInstancedBufferGeometry = !0;
        class Xh extends Rn {
            constructor(e) {
                super(e);
                typeof createImageBitmap == "undefined" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch == "undefined" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = {
                    premultiplyAlpha: "none"
                }
            }
            setOptions(e) {
                return this.options = e, this
            }
            load(e, t, n, i) {
                e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
                const r = this,
                    s = Dr.get(e);
                if (s !== void 0) return r.manager.itemStart(e), setTimeout(function() {
                    t && t(s), r.manager.itemEnd(e)
                }, 0), s;
                const o = {};
                o.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", o.headers = this.requestHeader, fetch(e, o).then(function(l) {
                    return l.blob()
                }).then(function(l) {
                    return createImageBitmap(l, Object.assign(r.options, {
                        colorSpaceConversion: "none"
                    }))
                }).then(function(l) {
                    Dr.add(e, l), t && t(l), r.manager.itemEnd(e)
                }).catch(function(l) {
                    i && i(l), r.manager.itemError(e), r.manager.itemEnd(e)
                }), r.manager.itemStart(e)
            }
        }
        Xh.prototype.isImageBitmapLoader = !0;
        let Ua;
        const Lx = {
            getContext: function() {
                return Ua === void 0 && (Ua = new(window.AudioContext || window.webkitAudioContext)), Ua
            },
            setContext: function(a) {
                Ua = a
            }
        };
        class Rx extends Rn {
            constructor(e) {
                super(e)
            }
            load(e, t, n, i) {
                const r = this,
                    s = new ml(this.manager);
                s.setResponseType("arraybuffer"), s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(e, function(o) {
                    try {
                        const l = o.slice(0);
                        Lx.getContext().decodeAudioData(l, function(u) {
                            t(u)
                        })
                    } catch (l) {
                        i ? i(l) : console.error(l), r.manager.itemError(e)
                    }
                }, n, i)
            }
        }
        class Cx extends yl {
            constructor(e, t, n = 1) {
                super(void 0, n);
                const i = new ne().set(e),
                    r = new ne().set(t),
                    s = new E(i.r, i.g, i.b),
                    o = new E(r.r, r.g, r.b),
                    l = Math.sqrt(Math.PI),
                    c = l * Math.sqrt(.75);
                this.sh.coefficients[0].copy(s).add(o).multiplyScalar(l), this.sh.coefficients[1].copy(s).sub(o).multiplyScalar(c)
            }
        }
        Cx.prototype.isHemisphereLightProbe = !0;
        class Px extends yl {
            constructor(e, t = 1) {
                super(void 0, t);
                const n = new ne().set(e);
                this.sh.coefficients[0].set(n.r, n.g, n.b).multiplyScalar(2 * Math.sqrt(Math.PI))
            }
        }
        Px.prototype.isAmbientLightProbe = !0;
        class jh {
            constructor(e = !0) {
                this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
            }
            start() {
                this.startTime = Yh(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
            }
            stop() {
                this.getElapsedTime(), this.running = !1, this.autoStart = !1
            }
            getElapsedTime() {
                return this.getDelta(), this.elapsedTime
            }
            getDelta() {
                let e = 0;
                if (this.autoStart && !this.running) return this.start(), 0;
                if (this.running) {
                    const t = Yh();
                    e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e
                }
                return e
            }
        }

        function Yh() {
            return (typeof performance == "undefined" ? Date : performance).now()
        }
        class Dx extends Te {
            constructor(e) {
                super();
                this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = []
            }
            getOutput() {
                return this.gain
            }
            setNodeSource(e) {
                return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this
            }
            setMediaElementSource(e) {
                return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this
            }
            setMediaStreamSource(e) {
                return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this
            }
            setBuffer(e) {
                return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this
            }
            play(e = 0) {
                if (this.isPlaying === !0) {
                    console.warn("THREE.Audio: Audio is already playing.");
                    return
                }
                if (this.hasPlaybackControl === !1) {
                    console.warn("THREE.Audio: this Audio has no playback control.");
                    return
                }
                this._startedAt = this.context.currentTime + e;
                const t = this.context.createBufferSource();
                return t.buffer = this.buffer, t.loop = this.loop, t.loopStart = this.loopStart, t.loopEnd = this.loopEnd, t.onended = this.onEnded.bind(this), t.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect()
            }
            pause() {
                if (this.hasPlaybackControl === !1) {
                    console.warn("THREE.Audio: this Audio has no playback control.");
                    return
                }
                return this.isPlaying === !0 && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, this.loop === !0 && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this
            }
            stop() {
                if (this.hasPlaybackControl === !1) {
                    console.warn("THREE.Audio: this Audio has no playback control.");
                    return
                }
                return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = !1, this
            }
            connect() {
                if (this.filters.length > 0) {
                    this.source.connect(this.filters[0]);
                    for (let e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].connect(this.filters[e]);
                    this.filters[this.filters.length - 1].connect(this.getOutput())
                } else this.source.connect(this.getOutput());
                return this._connected = !0, this
            }
            disconnect() {
                if (this.filters.length > 0) {
                    this.source.disconnect(this.filters[0]);
                    for (let e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].disconnect(this.filters[e]);
                    this.filters[this.filters.length - 1].disconnect(this.getOutput())
                } else this.source.disconnect(this.getOutput());
                return this._connected = !1, this
            }
            getFilters() {
                return this.filters
            }
            setFilters(e) {
                return e || (e = []), this._connected === !0 ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this
            }
            setDetune(e) {
                if (this.detune = e, this.source.detune !== void 0) return this.isPlaying === !0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this
            }
            getDetune() {
                return this.detune
            }
            getFilter() {
                return this.getFilters()[0]
            }
            setFilter(e) {
                return this.setFilters(e ? [e] : [])
            }
            setPlaybackRate(e) {
                if (this.hasPlaybackControl === !1) {
                    console.warn("THREE.Audio: this Audio has no playback control.");
                    return
                }
                return this.playbackRate = e, this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this
            }
            getPlaybackRate() {
                return this.playbackRate
            }
            onEnded() {
                this.isPlaying = !1
            }
            getLoop() {
                return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
            }
            setLoop(e) {
                if (this.hasPlaybackControl === !1) {
                    console.warn("THREE.Audio: this Audio has no playback control.");
                    return
                }
                return this.loop = e, this.isPlaying === !0 && (this.source.loop = this.loop), this
            }
            setLoopStart(e) {
                return this.loopStart = e, this
            }
            setLoopEnd(e) {
                return this.loopEnd = e, this
            }
            getVolume() {
                return this.gain.gain.value
            }
            setVolume(e) {
                return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this
            }
        }
        class Ix {
            constructor(e, t, n) {
                this.binding = e, this.valueSize = n;
                let i, r, s;
                switch (t) {
                    case "quaternion":
                        i = this._slerp, r = this._slerpAdditive, s = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(n * 6), this._workIndex = 5;
                        break;
                    case "string":
                    case "bool":
                        i = this._select, r = this._select, s = this._setAdditiveIdentityOther, this.buffer = new Array(n * 5);
                        break;
                    default:
                        i = this._lerp, r = this._lerpAdditive, s = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(n * 5)
                }
                this._mixBufferRegion = i, this._mixBufferRegionAdditive = r, this._setIdentity = s, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0
            }
            accumulate(e, t) {
                const n = this.buffer,
                    i = this.valueSize,
                    r = e * i + i;
                let s = this.cumulativeWeight;
                if (s === 0) {
                    for (let o = 0; o !== i; ++o) n[r + o] = n[o];
                    s = t
                } else {
                    s += t;
                    const o = t / s;
                    this._mixBufferRegion(n, r, 0, o, i)
                }
                this.cumulativeWeight = s
            }
            accumulateAdditive(e) {
                const t = this.buffer,
                    n = this.valueSize,
                    i = n * this._addIndex;
                this.cumulativeWeightAdditive === 0 && this._setIdentity(), this._mixBufferRegionAdditive(t, i, 0, e, n), this.cumulativeWeightAdditive += e
            }
            apply(e) {
                const t = this.valueSize,
                    n = this.buffer,
                    i = e * t + t,
                    r = this.cumulativeWeight,
                    s = this.cumulativeWeightAdditive,
                    o = this.binding;
                if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, r < 1) {
                    const l = t * this._origIndex;
                    this._mixBufferRegion(n, i, l, 1 - r, t)
                }
                s > 0 && this._mixBufferRegionAdditive(n, i, this._addIndex * t, 1, t);
                for (let l = t, c = t + t; l !== c; ++l)
                    if (n[l] !== n[l + t]) {
                        o.setValue(n, i);
                        break
                    }
            }
            saveOriginalState() {
                const e = this.binding,
                    t = this.buffer,
                    n = this.valueSize,
                    i = n * this._origIndex;
                e.getValue(t, i);
                for (let r = n, s = i; r !== s; ++r) t[r] = t[i + r % n];
                this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0
            }
            restoreOriginalState() {
                const e = this.valueSize * 3;
                this.binding.setValue(this.buffer, e)
            }
            _setAdditiveIdentityNumeric() {
                const e = this._addIndex * this.valueSize,
                    t = e + this.valueSize;
                for (let n = e; n < t; n++) this.buffer[n] = 0
            }
            _setAdditiveIdentityQuaternion() {
                this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1
            }
            _setAdditiveIdentityOther() {
                const e = this._origIndex * this.valueSize,
                    t = this._addIndex * this.valueSize;
                for (let n = 0; n < this.valueSize; n++) this.buffer[t + n] = this.buffer[e + n]
            }
            _select(e, t, n, i, r) {
                if (i >= .5)
                    for (let s = 0; s !== r; ++s) e[t + s] = e[n + s]
            }
            _slerp(e, t, n, i) {
                At.slerpFlat(e, t, e, t, e, n, i)
            }
            _slerpAdditive(e, t, n, i, r) {
                const s = this._workIndex * r;
                At.multiplyQuaternionsFlat(e, s, e, t, e, n), At.slerpFlat(e, t, e, t, e, s, i)
            }
            _lerp(e, t, n, i, r) {
                const s = 1 - i;
                for (let o = 0; o !== r; ++o) {
                    const l = t + o;
                    e[l] = e[l] * s + e[n + o] * i
                }
            }
            _lerpAdditive(e, t, n, i, r) {
                for (let s = 0; s !== r; ++s) {
                    const o = t + s;
                    e[o] = e[o] + e[n + s] * i
                }
            }
        }
        const Ml = "\\[\\]\\.:\\/",
            Fx = new RegExp("[" + Ml + "]", "g"),
            bl = "[^" + Ml + "]",
            zx = "[^" + Ml.replace("\\.", "") + "]",
            Nx = /((?:WC+[\/:])*)/.source.replace("WC", bl),
            Bx = /(WCOD+)?/.source.replace("WCOD", zx),
            Ox = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", bl),
            Ux = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", bl),
            kx = new RegExp("^" + Nx + Bx + Ox + Ux + "$"),
            Gx = ["material", "materials", "bones"];
        class Hx {
            constructor(e, t, n) {
                const i = n || Be.parseTrackName(t);
                this._targetGroup = e, this._bindings = e.subscribe_(t, i)
            }
            getValue(e, t) {
                this.bind();
                const n = this._targetGroup.nCachedObjects_,
                    i = this._bindings[n];
                i !== void 0 && i.getValue(e, t)
            }
            setValue(e, t) {
                const n = this._bindings;
                for (let i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i) n[i].setValue(e, t)
            }
            bind() {
                const e = this._bindings;
                for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].bind()
            }
            unbind() {
                const e = this._bindings;
                for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].unbind()
            }
        }
        class Be {
            constructor(e, t, n) {
                this.path = t, this.parsedPath = n || Be.parseTrackName(t), this.node = Be.findNode(e, this.parsedPath.nodeName) || e, this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
            }
            static create(e, t, n) {
                return e && e.isAnimationObjectGroup ? new Be.Composite(e, t, n) : new Be(e, t, n)
            }
            static sanitizeNodeName(e) {
                return e.replace(/\s/g, "_").replace(Fx, "")
            }
            static parseTrackName(e) {
                const t = kx.exec(e);
                if (!t) throw new Error("PropertyBinding: Cannot parse trackName: " + e);
                const n = {
                        nodeName: t[2],
                        objectName: t[3],
                        objectIndex: t[4],
                        propertyName: t[5],
                        propertyIndex: t[6]
                    },
                    i = n.nodeName && n.nodeName.lastIndexOf(".");
                if (i !== void 0 && i !== -1) {
                    const r = n.nodeName.substring(i + 1);
                    Gx.indexOf(r) !== -1 && (n.nodeName = n.nodeName.substring(0, i), n.objectName = r)
                }
                if (n.propertyName === null || n.propertyName.length === 0) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
                return n
            }
            static findNode(e, t) {
                if (!t || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid) return e;
                if (e.skeleton) {
                    const n = e.skeleton.getBoneByName(t);
                    if (n !== void 0) return n
                }
                if (e.children) {
                    const n = function(r) {
                            for (let s = 0; s < r.length; s++) {
                                const o = r[s];
                                if (o.name === t || o.uuid === t) return o;
                                const l = n(o.children);
                                if (l) return l
                            }
                            return null
                        },
                        i = n(e.children);
                    if (i) return i
                }
                return null
            }
            _getValue_unavailable() {}
            _setValue_unavailable() {}
            _getValue_direct(e, t) {
                e[t] = this.targetObject[this.propertyName]
            }
            _getValue_array(e, t) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i) e[t++] = n[i]
            }
            _getValue_arrayElement(e, t) {
                e[t] = this.resolvedProperty[this.propertyIndex]
            }
            _getValue_toArray(e, t) {
                this.resolvedProperty.toArray(e, t)
            }
            _setValue_direct(e, t) {
                this.targetObject[this.propertyName] = e[t]
            }
            _setValue_direct_setNeedsUpdate(e, t) {
                this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0
            }
            _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
                this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _setValue_array(e, t) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++]
            }
            _setValue_array_setNeedsUpdate(e, t) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
                this.targetObject.needsUpdate = !0
            }
            _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
                this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _setValue_arrayElement(e, t) {
                this.resolvedProperty[this.propertyIndex] = e[t]
            }
            _setValue_arrayElement_setNeedsUpdate(e, t) {
                this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0
            }
            _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
                this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _setValue_fromArray(e, t) {
                this.resolvedProperty.fromArray(e, t)
            }
            _setValue_fromArray_setNeedsUpdate(e, t) {
                this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0
            }
            _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
                this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _getValue_unbound(e, t) {
                this.bind(), this.getValue(e, t)
            }
            _setValue_unbound(e, t) {
                this.bind(), this.setValue(e, t)
            }
            bind() {
                let e = this.node;
                const t = this.parsedPath,
                    n = t.objectName,
                    i = t.propertyName;
                let r = t.propertyIndex;
                if (e || (e = Be.findNode(this.rootNode, t.nodeName) || this.rootNode, this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) {
                    console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
                    return
                }
                if (n) {
                    let c = t.objectIndex;
                    switch (n) {
                        case "materials":
                            if (!e.material) {
                                console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                                return
                            }
                            if (!e.material.materials) {
                                console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                                return
                            }
                            e = e.material.materials;
                            break;
                        case "bones":
                            if (!e.skeleton) {
                                console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                                return
                            }
                            e = e.skeleton.bones;
                            for (let u = 0; u < e.length; u++)
                                if (e[u].name === c) {
                                    c = u;
                                    break
                                }
                            break;
                        default:
                            if (e[n] === void 0) {
                                console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                                return
                            }
                            e = e[n]
                    }
                    if (c !== void 0) {
                        if (e[c] === void 0) {
                            console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                            return
                        }
                        e = e[c]
                    }
                }
                const s = e[i];
                if (s === void 0) {
                    const c = t.nodeName;
                    console.error("THREE.PropertyBinding: Trying to update property for track: " + c + "." + i + " but it wasn't found.", e);
                    return
                }
                let o = this.Versioning.None;
                this.targetObject = e, e.needsUpdate !== void 0 ? o = this.Versioning.NeedsUpdate : e.matrixWorldNeedsUpdate !== void 0 && (o = this.Versioning.MatrixWorldNeedsUpdate);
                let l = this.BindingType.Direct;
                if (r !== void 0) {
                    if (i === "morphTargetInfluences") {
                        if (!e.geometry) {
                            console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                            return
                        }
                        if (e.geometry.isBufferGeometry) {
                            if (!e.geometry.morphAttributes) {
                                console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                                return
                            }
                            e.morphTargetDictionary[r] !== void 0 && (r = e.morphTargetDictionary[r])
                        } else {
                            console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
                            return
                        }
                    }
                    l = this.BindingType.ArrayElement, this.resolvedProperty = s, this.propertyIndex = r
                } else s.fromArray !== void 0 && s.toArray !== void 0 ? (l = this.BindingType.HasFromToArray, this.resolvedProperty = s) : Array.isArray(s) ? (l = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = i;
                this.getValue = this.GetterByBindingType[l], this.setValue = this.SetterByBindingTypeAndVersioning[l][o]
            }
            unbind() {
                this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
            }
        }
        Be.Composite = Hx, Be.prototype.BindingType = {
            Direct: 0,
            EntireArray: 1,
            ArrayElement: 2,
            HasFromToArray: 3
        }, Be.prototype.Versioning = {
            None: 0,
            NeedsUpdate: 1,
            MatrixWorldNeedsUpdate: 2
        }, Be.prototype.GetterByBindingType = [Be.prototype._getValue_direct, Be.prototype._getValue_array, Be.prototype._getValue_arrayElement, Be.prototype._getValue_toArray], Be.prototype.SetterByBindingTypeAndVersioning = [
            [Be.prototype._setValue_direct, Be.prototype._setValue_direct_setNeedsUpdate, Be.prototype._setValue_direct_setMatrixWorldNeedsUpdate],
            [Be.prototype._setValue_array, Be.prototype._setValue_array_setNeedsUpdate, Be.prototype._setValue_array_setMatrixWorldNeedsUpdate],
            [Be.prototype._setValue_arrayElement, Be.prototype._setValue_arrayElement_setNeedsUpdate, Be.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],
            [Be.prototype._setValue_fromArray, Be.prototype._setValue_fromArray_setNeedsUpdate, Be.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]
        ];
        class Vx {
            constructor(e, t, n = null, i = t.blendMode) {
                this._mixer = e, this._clip = t, this._localRoot = n, this.blendMode = i;
                const r = t.tracks,
                    s = r.length,
                    o = new Array(s),
                    l = {
                        endingStart: Zi,
                        endingEnd: Zi
                    };
                for (let c = 0; c !== s; ++c) {
                    const u = r[c].createInterpolant(null);
                    o[c] = u, u.settings = l
                }
                this._interpolantSettings = l, this._interpolants = o, this._propertyBindings = new Array(s), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = rm, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
            }
            play() {
                return this._mixer._activateAction(this), this
            }
            stop() {
                return this._mixer._deactivateAction(this), this.reset()
            }
            reset() {
                return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
            }
            isRunning() {
                return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this)
            }
            isScheduled() {
                return this._mixer._isActiveAction(this)
            }
            startAt(e) {
                return this._startTime = e, this
            }
            setLoop(e, t) {
                return this.loop = e, this.repetitions = t, this
            }
            setEffectiveWeight(e) {
                return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading()
            }
            getEffectiveWeight() {
                return this._effectiveWeight
            }
            fadeIn(e) {
                return this._scheduleFading(e, 0, 1)
            }
            fadeOut(e) {
                return this._scheduleFading(e, 1, 0)
            }
            crossFadeFrom(e, t, n) {
                if (e.fadeOut(t), this.fadeIn(t), n) {
                    const i = this._clip.duration,
                        r = e._clip.duration,
                        s = r / i,
                        o = i / r;
                    e.warp(1, s, t), this.warp(o, 1, t)
                }
                return this
            }
            crossFadeTo(e, t, n) {
                return e.crossFadeFrom(this, t, n)
            }
            stopFading() {
                const e = this._weightInterpolant;
                return e !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
            }
            setEffectiveTimeScale(e) {
                return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping()
            }
            getEffectiveTimeScale() {
                return this._effectiveTimeScale
            }
            setDuration(e) {
                return this.timeScale = this._clip.duration / e, this.stopWarping()
            }
            syncWith(e) {
                return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping()
            }
            halt(e) {
                return this.warp(this._effectiveTimeScale, 0, e)
            }
            warp(e, t, n) {
                const i = this._mixer,
                    r = i.time,
                    s = this.timeScale;
                let o = this._timeScaleInterpolant;
                o === null && (o = i._lendControlInterpolant(), this._timeScaleInterpolant = o);
                const l = o.parameterPositions,
                    c = o.sampleValues;
                return l[0] = r, l[1] = r + n, c[0] = e / s, c[1] = t / s, this
            }
            stopWarping() {
                const e = this._timeScaleInterpolant;
                return e !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
            }
            getMixer() {
                return this._mixer
            }
            getClip() {
                return this._clip
            }
            getRoot() {
                return this._localRoot || this._mixer._root
            }
            _update(e, t, n, i) {
                if (!this.enabled) {
                    this._updateWeight(e);
                    return
                }
                const r = this._startTime;
                if (r !== null) {
                    const l = (e - r) * n;
                    if (l < 0 || n === 0) return;
                    this._startTime = null, t = n * l
                }
                t *= this._updateTimeScale(e);
                const s = this._updateTime(t),
                    o = this._updateWeight(e);
                if (o > 0) {
                    const l = this._interpolants,
                        c = this._propertyBindings;
                    switch (this.blendMode) {
                        case Wc:
                            for (let u = 0, h = l.length; u !== h; ++u) l[u].evaluate(s), c[u].accumulateAdditive(o);
                            break;
                        case co:
                        default:
                            for (let u = 0, h = l.length; u !== h; ++u) l[u].evaluate(s), c[u].accumulate(i, o)
                    }
                }
            }
            _updateWeight(e) {
                let t = 0;
                if (this.enabled) {
                    t = this.weight;
                    const n = this._weightInterpolant;
                    if (n !== null) {
                        const i = n.evaluate(e)[0];
                        t *= i, e > n.parameterPositions[1] && (this.stopFading(), i === 0 && (this.enabled = !1))
                    }
                }
                return this._effectiveWeight = t, t
            }
            _updateTimeScale(e) {
                let t = 0;
                if (!this.paused) {
                    t = this.timeScale;
                    const n = this._timeScaleInterpolant;
                    n !== null && (t *= n.evaluate(e)[0], e > n.parameterPositions[1] && (this.stopWarping(), t === 0 ? this.paused = !0 : this.timeScale = t))
                }
                return this._effectiveTimeScale = t, t
            }
            _updateTime(e) {
                const t = this._clip.duration,
                    n = this.loop;
                let i = this.time + e,
                    r = this._loopCount;
                const s = n === sm;
                if (e === 0) return r === -1 ? i : s && (r & 1) == 1 ? t - i : i;
                if (n === im) {
                    r === -1 && (this._loopCount = 0, this._setEndings(!0, !0, !1));
                    e: {
                        if (i >= t) i = t;
                        else if (i < 0) i = 0;
                        else {
                            this.time = i;
                            break e
                        }
                        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                        this.time = i,
                        this._mixer.dispatchEvent({
                            type: "finished",
                            action: this,
                            direction: e < 0 ? -1 : 1
                        })
                    }
                } else {
                    if (r === -1 && (e >= 0 ? (r = 0, this._setEndings(!0, this.repetitions === 0, s)) : this._setEndings(this.repetitions === 0, !0, s)), i >= t || i < 0) {
                        const o = Math.floor(i / t);
                        i -= t * o, r += Math.abs(o);
                        const l = this.repetitions - r;
                        if (l <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, i = e > 0 ? t : 0, this.time = i, this._mixer.dispatchEvent({
                            type: "finished",
                            action: this,
                            direction: e > 0 ? 1 : -1
                        });
                        else {
                            if (l === 1) {
                                const c = e < 0;
                                this._setEndings(c, !c, s)
                            } else this._setEndings(!1, !1, s);
                            this._loopCount = r, this.time = i, this._mixer.dispatchEvent({
                                type: "loop",
                                action: this,
                                loopDelta: o
                            })
                        }
                    } else this.time = i;
                    if (s && (r & 1) == 1) return t - i
                }
                return i
            }
            _setEndings(e, t, n) {
                const i = this._interpolantSettings;
                n ? (i.endingStart = Ji, i.endingEnd = Ji) : (e ? i.endingStart = this.zeroSlopeAtStart ? Ji : Zi : i.endingStart = Ks, t ? i.endingEnd = this.zeroSlopeAtEnd ? Ji : Zi : i.endingEnd = Ks)
            }
            _scheduleFading(e, t, n) {
                const i = this._mixer,
                    r = i.time;
                let s = this._weightInterpolant;
                s === null && (s = i._lendControlInterpolant(), this._weightInterpolant = s);
                const o = s.parameterPositions,
                    l = s.sampleValues;
                return o[0] = r, l[0] = t, o[1] = r + e, l[1] = n, this
            }
        }
        class Wx extends bi {
            constructor(e) {
                super();
                this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
            }
            _bindAction(e, t) {
                const n = e._localRoot || this._root,
                    i = e._clip.tracks,
                    r = i.length,
                    s = e._propertyBindings,
                    o = e._interpolants,
                    l = n.uuid,
                    c = this._bindingsByRootAndName;
                let u = c[l];
                u === void 0 && (u = {}, c[l] = u);
                for (let h = 0; h !== r; ++h) {
                    const f = i[h],
                        d = f.name;
                    let m = u[d];
                    if (m !== void 0) s[h] = m;
                    else {
                        if (m = s[h], m !== void 0) {
                            m._cacheIndex === null && (++m.referenceCount, this._addInactiveBinding(m, l, d));
                            continue
                        }
                        const g = t && t._propertyBindings[h].binding.parsedPath;
                        m = new Ix(Be.create(n, d, g), f.ValueTypeName, f.getValueSize()), ++m.referenceCount, this._addInactiveBinding(m, l, d), s[h] = m
                    }
                    o[h].resultBuffer = m.buffer
                }
            }
            _activateAction(e) {
                if (!this._isActiveAction(e)) {
                    if (e._cacheIndex === null) {
                        const n = (e._localRoot || this._root).uuid,
                            i = e._clip.uuid,
                            r = this._actionsByClip[i];
                        this._bindAction(e, r && r.knownActions[0]), this._addInactiveAction(e, i, n)
                    }
                    const t = e._propertyBindings;
                    for (let n = 0, i = t.length; n !== i; ++n) {
                        const r = t[n];
                        r.useCount++ == 0 && (this._lendBinding(r), r.saveOriginalState())
                    }
                    this._lendAction(e)
                }
            }
            _deactivateAction(e) {
                if (this._isActiveAction(e)) {
                    const t = e._propertyBindings;
                    for (let n = 0, i = t.length; n !== i; ++n) {
                        const r = t[n];
                        --r.useCount == 0 && (r.restoreOriginalState(), this._takeBackBinding(r))
                    }
                    this._takeBackAction(e)
                }
            }
            _initMemoryManager() {
                this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
                const e = this;
                this.stats = {
                    actions: {
                        get total() {
                            return e._actions.length
                        },
                        get inUse() {
                            return e._nActiveActions
                        }
                    },
                    bindings: {
                        get total() {
                            return e._bindings.length
                        },
                        get inUse() {
                            return e._nActiveBindings
                        }
                    },
                    controlInterpolants: {
                        get total() {
                            return e._controlInterpolants.length
                        },
                        get inUse() {
                            return e._nActiveControlInterpolants
                        }
                    }
                }
            }
            _isActiveAction(e) {
                const t = e._cacheIndex;
                return t !== null && t < this._nActiveActions
            }
            _addInactiveAction(e, t, n) {
                const i = this._actions,
                    r = this._actionsByClip;
                let s = r[t];
                if (s === void 0) s = {
                    knownActions: [e],
                    actionByRoot: {}
                }, e._byClipCacheIndex = 0, r[t] = s;
                else {
                    const o = s.knownActions;
                    e._byClipCacheIndex = o.length, o.push(e)
                }
                e._cacheIndex = i.length, i.push(e), s.actionByRoot[n] = e
            }
            _removeInactiveAction(e) {
                const t = this._actions,
                    n = t[t.length - 1],
                    i = e._cacheIndex;
                n._cacheIndex = i, t[i] = n, t.pop(), e._cacheIndex = null;
                const r = e._clip.uuid,
                    s = this._actionsByClip,
                    o = s[r],
                    l = o.knownActions,
                    c = l[l.length - 1],
                    u = e._byClipCacheIndex;
                c._byClipCacheIndex = u, l[u] = c, l.pop(), e._byClipCacheIndex = null;
                const h = o.actionByRoot,
                    f = (e._localRoot || this._root).uuid;
                delete h[f], l.length === 0 && delete s[r], this._removeInactiveBindingsForAction(e)
            }
            _removeInactiveBindingsForAction(e) {
                const t = e._propertyBindings;
                for (let n = 0, i = t.length; n !== i; ++n) {
                    const r = t[n];
                    --r.referenceCount == 0 && this._removeInactiveBinding(r)
                }
            }
            _lendAction(e) {
                const t = this._actions,
                    n = e._cacheIndex,
                    i = this._nActiveActions++,
                    r = t[i];
                e._cacheIndex = i, t[i] = e, r._cacheIndex = n, t[n] = r
            }
            _takeBackAction(e) {
                const t = this._actions,
                    n = e._cacheIndex,
                    i = --this._nActiveActions,
                    r = t[i];
                e._cacheIndex = i, t[i] = e, r._cacheIndex = n, t[n] = r
            }
            _addInactiveBinding(e, t, n) {
                const i = this._bindingsByRootAndName,
                    r = this._bindings;
                let s = i[t];
                s === void 0 && (s = {}, i[t] = s), s[n] = e, e._cacheIndex = r.length, r.push(e)
            }
            _removeInactiveBinding(e) {
                const t = this._bindings,
                    n = e.binding,
                    i = n.rootNode.uuid,
                    r = n.path,
                    s = this._bindingsByRootAndName,
                    o = s[i],
                    l = t[t.length - 1],
                    c = e._cacheIndex;
                l._cacheIndex = c, t[c] = l, t.pop(), delete o[r], Object.keys(o).length === 0 && delete s[i]
            }
            _lendBinding(e) {
                const t = this._bindings,
                    n = e._cacheIndex,
                    i = this._nActiveBindings++,
                    r = t[i];
                e._cacheIndex = i, t[i] = e, r._cacheIndex = n, t[n] = r
            }
            _takeBackBinding(e) {
                const t = this._bindings,
                    n = e._cacheIndex,
                    i = --this._nActiveBindings,
                    r = t[i];
                e._cacheIndex = i, t[i] = e, r._cacheIndex = n, t[n] = r
            }
            _lendControlInterpolant() {
                const e = this._controlInterpolants,
                    t = this._nActiveControlInterpolants++;
                let n = e[t];
                return n === void 0 && (n = new Fh(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), n.__cacheIndex = t, e[t] = n), n
            }
            _takeBackControlInterpolant(e) {
                const t = this._controlInterpolants,
                    n = e.__cacheIndex,
                    i = --this._nActiveControlInterpolants,
                    r = t[i];
                e.__cacheIndex = i, t[i] = e, r.__cacheIndex = n, t[n] = r
            }
            clipAction(e, t, n) {
                const i = t || this._root,
                    r = i.uuid;
                let s = typeof e == "string" ? pl.findByName(i, e) : e;
                const o = s !== null ? s.uuid : e,
                    l = this._actionsByClip[o];
                let c = null;
                if (n === void 0 && (s !== null ? n = s.blendMode : n = co), l !== void 0) {
                    const h = l.actionByRoot[r];
                    if (h !== void 0 && h.blendMode === n) return h;
                    c = l.knownActions[0], s === null && (s = c._clip)
                }
                if (s === null) return null;
                const u = new Vx(this, s, t, n);
                return this._bindAction(u, c), this._addInactiveAction(u, o, r), u
            }
            existingAction(e, t) {
                const n = t || this._root,
                    i = n.uuid,
                    r = typeof e == "string" ? pl.findByName(n, e) : e,
                    s = r ? r.uuid : e,
                    o = this._actionsByClip[s];
                return o !== void 0 && o.actionByRoot[i] || null
            }
            stopAllAction() {
                const e = this._actions,
                    t = this._nActiveActions;
                for (let n = t - 1; n >= 0; --n) e[n].stop();
                return this
            }
            update(e) {
                e *= this.timeScale;
                const t = this._actions,
                    n = this._nActiveActions,
                    i = this.time += e,
                    r = Math.sign(e),
                    s = this._accuIndex ^= 1;
                for (let c = 0; c !== n; ++c) t[c]._update(i, e, r, s);
                const o = this._bindings,
                    l = this._nActiveBindings;
                for (let c = 0; c !== l; ++c) o[c].apply(s);
                return this
            }
            setTime(e) {
                this.time = 0;
                for (let t = 0; t < this._actions.length; t++) this._actions[t].time = 0;
                return this.update(e)
            }
            getRoot() {
                return this._root
            }
            uncacheClip(e) {
                const t = this._actions,
                    n = e.uuid,
                    i = this._actionsByClip,
                    r = i[n];
                if (r !== void 0) {
                    const s = r.knownActions;
                    for (let o = 0, l = s.length; o !== l; ++o) {
                        const c = s[o];
                        this._deactivateAction(c);
                        const u = c._cacheIndex,
                            h = t[t.length - 1];
                        c._cacheIndex = null, c._byClipCacheIndex = null, h._cacheIndex = u, t[u] = h, t.pop(), this._removeInactiveBindingsForAction(c)
                    }
                    delete i[n]
                }
            }
            uncacheRoot(e) {
                const t = e.uuid,
                    n = this._actionsByClip;
                for (const s in n) {
                    const o = n[s].actionByRoot,
                        l = o[t];
                    l !== void 0 && (this._deactivateAction(l), this._removeInactiveAction(l))
                }
                const i = this._bindingsByRootAndName,
                    r = i[t];
                if (r !== void 0)
                    for (const s in r) {
                        const o = r[s];
                        o.restoreOriginalState(), this._removeInactiveBinding(o)
                    }
            }
            uncacheAction(e, t) {
                const n = this.existingAction(e, t);
                n !== null && (this._deactivateAction(n), this._removeInactiveAction(n))
            }
        }
        Wx.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
        class qx extends xr {
            constructor(e, t, n = 1) {
                super(e, t);
                this.meshPerAttribute = n
            }
            copy(e) {
                return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this
            }
            clone(e) {
                const t = super.clone(e);
                return t.meshPerAttribute = this.meshPerAttribute, t
            }
            toJSON(e) {
                const t = super.toJSON(e);
                return t.isInstancedInterleavedBuffer = !0, t.meshPerAttribute = this.meshPerAttribute, t
            }
        }
        qx.prototype.isInstancedInterleavedBuffer = !0;
        class Xx {
            constructor(e, t, n = 0, i = 1 / 0) {
                this.ray = new Ei(e, t), this.near = n, this.far = i, this.camera = null, this.layers = new aa, this.params = {
                    Mesh: {},
                    Line: {
                        threshold: 1
                    },
                    LOD: {},
                    Points: {
                        threshold: 1
                    },
                    Sprite: {}
                }
            }
            set(e, t) {
                this.ray.set(e, t)
            }
            setFromCamera(e, t) {
                t && t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t && t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type)
            }
            intersectObject(e, t = !0, n = []) {
                return wl(e, this, n, t), n.sort(Zh), n
            }
            intersectObjects(e, t = !0, n = []) {
                for (let i = 0, r = e.length; i < r; i++) wl(e[i], this, n, t);
                return n.sort(Zh), n
            }
        }

        function Zh(a, e) {
            return a.distance - e.distance
        }

        function wl(a, e, t, n) {
            if (a.layers.test(e.layers) && a.raycast(e, t), n === !0) {
                const i = a.children;
                for (let r = 0, s = i.length; r < s; r++) wl(i[r], e, t, !0)
            }
        }
        class jx extends Te {
            constructor(e) {
                super();
                this.material = e, this.render = function() {}, this.hasPositions = !1, this.hasNormals = !1, this.hasColors = !1, this.hasUvs = !1, this.positionArray = null, this.normalArray = null, this.colorArray = null, this.uvArray = null, this.count = 0
            }
        }
        jx.prototype.isImmediateRenderObject = !0;
        const ii = new E,
            ka = new fe,
            Sl = new fe;
        class Yx extends Ca {
            constructor(e) {
                const t = Jh(e),
                    n = new ke,
                    i = [],
                    r = [],
                    s = new ne(0, 0, 1),
                    o = new ne(0, 1, 0);
                for (let c = 0; c < t.length; c++) {
                    const u = t[c];
                    u.parent && u.parent.isBone && (i.push(0, 0, 0), i.push(0, 0, 0), r.push(s.r, s.g, s.b), r.push(o.r, o.g, o.b))
                }
                n.setAttribute("position", new Je(i, 3)), n.setAttribute("color", new Je(r, 3));
                const l = new Er({
                    vertexColors: !0,
                    depthTest: !1,
                    depthWrite: !1,
                    toneMapped: !1,
                    transparent: !0
                });
                super(n, l);
                this.type = "SkeletonHelper", this.isSkeletonHelper = !0, this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1
            }
            updateMatrixWorld(e) {
                const t = this.bones,
                    n = this.geometry,
                    i = n.getAttribute("position");
                Sl.copy(this.root.matrixWorld).invert();
                for (let r = 0, s = 0; r < t.length; r++) {
                    const o = t[r];
                    o.parent && o.parent.isBone && (ka.multiplyMatrices(Sl, o.matrixWorld), ii.setFromMatrixPosition(ka), i.setXYZ(s, ii.x, ii.y, ii.z), ka.multiplyMatrices(Sl, o.parent.matrixWorld), ii.setFromMatrixPosition(ka), i.setXYZ(s + 1, ii.x, ii.y, ii.z), s += 2)
                }
                n.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(e)
            }
        }

        function Jh(a) {
            const e = [];
            a && a.isBone && e.push(a);
            for (let t = 0; t < a.children.length; t++) e.push.apply(e, Jh(a.children[t]));
            return e
        }
        class Zx extends Ca {
            constructor(e = 10, t = 10, n = 4473924, i = 8947848) {
                n = new ne(n), i = new ne(i);
                const r = t / 2,
                    s = e / t,
                    o = e / 2,
                    l = [],
                    c = [];
                for (let f = 0, d = 0, m = -o; f <= t; f++, m += s) {
                    l.push(-o, 0, m, o, 0, m), l.push(m, 0, -o, m, 0, o);
                    const g = f === r ? n : i;
                    g.toArray(c, d), d += 3, g.toArray(c, d), d += 3, g.toArray(c, d), d += 3, g.toArray(c, d), d += 3
                }
                const u = new ke;
                u.setAttribute("position", new Je(l, 3)), u.setAttribute("color", new Je(c, 3));
                const h = new Er({
                    vertexColors: !0,
                    toneMapped: !1
                });
                super(u, h);
                this.type = "GridHelper"
            }
        }
        const Jx = new Float32Array(1);
        new Int32Array(Jx.buffer), Zt.create = function(a, e) {
            return console.log("THREE.Curve.create() has been deprecated"), a.prototype = Object.create(Zt.prototype), a.prototype.constructor = a, a.prototype.getPoint = e, a
        }, ul.prototype.fromPoints = function(a) {
            return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(a)
        }, Zx.prototype.setColors = function() {
            console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
        }, Yx.prototype.update = function() {
            console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
        }, Rn.prototype.extractUrlBase = function(a) {
            return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), Ir.extractUrlBase(a)
        }, Rn.Handlers = {
            add: function() {
                console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")
            },
            get: function() {
                console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")
            }
        }, jt.prototype.center = function(a) {
            return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(a)
        }, jt.prototype.empty = function() {
            return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty()
        }, jt.prototype.isIntersectionBox = function(a) {
            return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(a)
        }, jt.prototype.isIntersectionSphere = function(a) {
            return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(a)
        }, jt.prototype.size = function(a) {
            return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(a)
        }, Ti.prototype.empty = function() {
            return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."), this.isEmpty()
        }, ya.prototype.setFromMatrix = function(a) {
            return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."), this.setFromProjectionMatrix(a)
        }, mt.prototype.flattenToArrayOffset = function(a, e) {
            return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(a, e)
        }, mt.prototype.multiplyVector3 = function(a) {
            return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), a.applyMatrix3(this)
        }, mt.prototype.multiplyVector3Array = function() {
            console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
        }, mt.prototype.applyToBufferAttribute = function(a) {
            return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."), a.applyMatrix3(this)
        }, mt.prototype.applyToVector3Array = function() {
            console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
        }, mt.prototype.getInverse = function(a) {
            return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(a).invert()
        }, fe.prototype.extractPosition = function(a) {
            return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(a)
        }, fe.prototype.flattenToArrayOffset = function(a, e) {
            return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(a, e)
        }, fe.prototype.getPosition = function() {
            return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), new E().setFromMatrixColumn(this, 3)
        }, fe.prototype.setRotationFromQuaternion = function(a) {
            return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(a)
        }, fe.prototype.multiplyToArray = function() {
            console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
        }, fe.prototype.multiplyVector3 = function(a) {
            return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), a.applyMatrix4(this)
        }, fe.prototype.multiplyVector4 = function(a) {
            return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), a.applyMatrix4(this)
        }, fe.prototype.multiplyVector3Array = function() {
            console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
        }, fe.prototype.rotateAxis = function(a) {
            console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), a.transformDirection(this)
        }, fe.prototype.crossVector = function(a) {
            return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), a.applyMatrix4(this)
        }, fe.prototype.translate = function() {
            console.error("THREE.Matrix4: .translate() has been removed.")
        }, fe.prototype.rotateX = function() {
            console.error("THREE.Matrix4: .rotateX() has been removed.")
        }, fe.prototype.rotateY = function() {
            console.error("THREE.Matrix4: .rotateY() has been removed.")
        }, fe.prototype.rotateZ = function() {
            console.error("THREE.Matrix4: .rotateZ() has been removed.")
        }, fe.prototype.rotateByAxis = function() {
            console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
        }, fe.prototype.applyToBufferAttribute = function(a) {
            return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."), a.applyMatrix4(this)
        }, fe.prototype.applyToVector3Array = function() {
            console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
        }, fe.prototype.makeFrustum = function(a, e, t, n, i, r) {
            return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(a, e, n, t, i, r)
        }, fe.prototype.getInverse = function(a) {
            return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(a).invert()
        }, En.prototype.isIntersectionLine = function(a) {
            return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(a)
        }, At.prototype.multiplyVector3 = function(a) {
            return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), a.applyQuaternion(this)
        }, At.prototype.inverse = function() {
            return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."), this.invert()
        }, Ei.prototype.isIntersectionBox = function(a) {
            return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(a)
        }, Ei.prototype.isIntersectionPlane = function(a) {
            return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(a)
        }, Ei.prototype.isIntersectionSphere = function(a) {
            return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(a)
        }, it.prototype.area = function() {
            return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea()
        }, it.prototype.barycoordFromPoint = function(a, e) {
            return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(a, e)
        }, it.prototype.midpoint = function(a) {
            return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(a)
        }, it.prototypenormal = function(a) {
            return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(a)
        }, it.prototype.plane = function(a) {
            return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(a)
        }, it.barycoordFromPoint = function(a, e, t, n, i) {
            return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), it.getBarycoord(a, e, t, n, i)
        }, it.normal = function(a, e, t, n) {
            return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), it.getNormal(a, e, t, n)
        }, _s.prototype.extractAllPoints = function(a) {
            return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(a)
        }, _s.prototype.extrude = function(a) {
            return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new Lr(this, a)
        }, _s.prototype.makeGeometry = function(a) {
            return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new dl(this, a)
        }, X.prototype.fromAttribute = function(a, e, t) {
            return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(a, e, t)
        }, X.prototype.distanceToManhattan = function(a) {
            return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(a)
        }, X.prototype.lengthManhattan = function() {
            return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
        }, E.prototype.setEulerFromRotationMatrix = function() {
            console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
        }, E.prototype.setEulerFromQuaternion = function() {
            console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
        }, E.prototype.getPositionFromMatrix = function(a) {
            return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(a)
        }, E.prototype.getScaleFromMatrix = function(a) {
            return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(a)
        }, E.prototype.getColumnFromMatrix = function(a, e) {
            return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e, a)
        }, E.prototype.applyProjection = function(a) {
            return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(a)
        }, E.prototype.fromAttribute = function(a, e, t) {
            return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(a, e, t)
        }, E.prototype.distanceToManhattan = function(a) {
            return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(a)
        }, E.prototype.lengthManhattan = function() {
            return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
        }, Ue.prototype.fromAttribute = function(a, e, t) {
            return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(a, e, t)
        }, Ue.prototype.lengthManhattan = function() {
            return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
        }, Te.prototype.getChildByName = function(a) {
            return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(a)
        }, Te.prototype.renderDepth = function() {
            console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
        }, Te.prototype.translate = function(a, e) {
            return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e, a)
        }, Te.prototype.getWorldRotation = function() {
            console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
        }, Te.prototype.applyMatrix = function(a) {
            return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(a)
        }, Object.defineProperties(Te.prototype, {
            eulerOrder: {
                get: function() {
                    return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order
                },
                set: function(a) {
                    console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = a
                }
            },
            useQuaternion: {
                get: function() {
                    console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                },
                set: function() {
                    console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                }
            }
        }), Ge.prototype.setDrawMode = function() {
            console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
        }, Object.defineProperties(Ge.prototype, {
            drawMode: {
                get: function() {
                    return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."), am
                },
                set: function() {
                    console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
                }
            }
        }), $o.prototype.initBones = function() {
            console.error("THREE.SkinnedMesh: initBones() has been removed.")
        }, yt.prototype.setLens = function(a, e) {
            console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), e !== void 0 && (this.filmGauge = e), this.setFocalLength(a)
        }, Object.defineProperties(pn.prototype, {
            onlyShadow: {
                set: function() {
                    console.warn("THREE.Light: .onlyShadow has been removed.")
                }
            },
            shadowCameraFov: {
                set: function(a) {
                    console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = a
                }
            },
            shadowCameraLeft: {
                set: function(a) {
                    console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = a
                }
            },
            shadowCameraRight: {
                set: function(a) {
                    console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = a
                }
            },
            shadowCameraTop: {
                set: function(a) {
                    console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = a
                }
            },
            shadowCameraBottom: {
                set: function(a) {
                    console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = a
                }
            },
            shadowCameraNear: {
                set: function(a) {
                    console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = a
                }
            },
            shadowCameraFar: {
                set: function(a) {
                    console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = a
                }
            },
            shadowCameraVisible: {
                set: function() {
                    console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
                }
            },
            shadowBias: {
                set: function(a) {
                    console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = a
                }
            },
            shadowDarkness: {
                set: function() {
                    console.warn("THREE.Light: .shadowDarkness has been removed.")
                }
            },
            shadowMapWidth: {
                set: function(a) {
                    console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = a
                }
            },
            shadowMapHeight: {
                set: function(a) {
                    console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = a
                }
            }
        }), Object.defineProperties(Qe.prototype, {
            length: {
                get: function() {
                    return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length
                }
            },
            dynamic: {
                get: function() {
                    return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.usage === es
                },
                set: function() {
                    console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(es)
                }
            }
        }), Qe.prototype.setDynamic = function(a) {
            return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(a === !0 ? es : Mi), this
        }, Qe.prototype.copyIndicesArray = function() {
            console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
        }, Qe.prototype.setArray = function() {
            console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
        }, ke.prototype.addIndex = function(a) {
            console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(a)
        }, ke.prototype.addAttribute = function(a, e) {
            return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), !(e && e.isBufferAttribute) && !(e && e.isInterleavedBufferAttribute) ? (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(a, new Qe(arguments[1], arguments[2]))) : a === "index" ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(e), this) : this.setAttribute(a, e)
        }, ke.prototype.addDrawCall = function(a, e, t) {
            t !== void 0 && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(a, e)
        }, ke.prototype.clearDrawCalls = function() {
            console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups()
        }, ke.prototype.computeOffsets = function() {
            console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
        }, ke.prototype.removeAttribute = function(a) {
            return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(a)
        }, ke.prototype.applyMatrix = function(a) {
            return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(a)
        }, Object.defineProperties(ke.prototype, {
            drawcalls: {
                get: function() {
                    return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups
                }
            },
            offsets: {
                get: function() {
                    return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups
                }
            }
        }), xr.prototype.setDynamic = function(a) {
            return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(a === !0 ? es : Mi), this
        }, xr.prototype.setArray = function() {
            console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
        }, Lr.prototype.getArrays = function() {
            console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")
        }, Lr.prototype.addShapeList = function() {
            console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")
        }, Lr.prototype.addShape = function() {
            console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")
        }, wa.prototype.dispose = function() {
            console.error("THREE.Scene: .dispose() has been removed.")
        }, Object.defineProperties(ot.prototype, {
            wrapAround: {
                get: function() {
                    console.warn("THREE.Material: .wrapAround has been removed.")
                },
                set: function() {
                    console.warn("THREE.Material: .wrapAround has been removed.")
                }
            },
            overdraw: {
                get: function() {
                    console.warn("THREE.Material: .overdraw has been removed.")
                },
                set: function() {
                    console.warn("THREE.Material: .overdraw has been removed.")
                }
            },
            wrapRGB: {
                get: function() {
                    return console.warn("THREE.Material: .wrapRGB has been removed."), new ne
                }
            },
            shading: {
                get: function() {
                    console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
                },
                set: function(a) {
                    console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = a === Sc
                }
            },
            stencilMask: {
                get: function() {
                    return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask
                },
                set: function(a) {
                    console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask = a
                }
            },
            vertexTangents: {
                get: function() {
                    console.warn("THREE." + this.type + ": .vertexTangents has been removed.")
                },
                set: function() {
                    console.warn("THREE." + this.type + ": .vertexTangents has been removed.")
                }
            }
        }), Object.defineProperties(It.prototype, {
            derivatives: {
                get: function() {
                    return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives
                },
                set: function(a) {
                    console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = a
                }
            }
        }), He.prototype.clearTarget = function(a, e, t, n) {
            console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(a), this.clear(e, t, n)
        }, He.prototype.animate = function(a) {
            console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(a)
        }, He.prototype.getCurrentRenderTarget = function() {
            return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget()
        }, He.prototype.getMaxAnisotropy = function() {
            return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy()
        }, He.prototype.getPrecision = function() {
            return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision
        }, He.prototype.resetGLState = function() {
            return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset()
        }, He.prototype.supportsFloatTextures = function() {
            return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float")
        }, He.prototype.supportsHalfFloatTextures = function() {
            return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float")
        }, He.prototype.supportsStandardDerivatives = function() {
            return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives")
        }, He.prototype.supportsCompressedTextureS3TC = function() {
            return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc")
        }, He.prototype.supportsCompressedTexturePVRTC = function() {
            return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc")
        }, He.prototype.supportsBlendMinMax = function() {
            return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax")
        }, He.prototype.supportsVertexTextures = function() {
            return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures
        }, He.prototype.supportsInstancedArrays = function() {
            return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays")
        }, He.prototype.enableScissorTest = function(a) {
            console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(a)
        }, He.prototype.initMaterial = function() {
            console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
        }, He.prototype.addPrePlugin = function() {
            console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
        }, He.prototype.addPostPlugin = function() {
            console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
        }, He.prototype.updateShadowMap = function() {
            console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
        }, He.prototype.setFaceCulling = function() {
            console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
        }, He.prototype.allocTextureUnit = function() {
            console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")
        }, He.prototype.setTexture = function() {
            console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")
        }, He.prototype.setTexture2D = function() {
            console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")
        }, He.prototype.setTextureCube = function() {
            console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")
        }, He.prototype.getActiveMipMapLevel = function() {
            return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel()
        }, Object.defineProperties(He.prototype, {
            shadowMapEnabled: {
                get: function() {
                    return this.shadowMap.enabled
                },
                set: function(a) {
                    console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = a
                }
            },
            shadowMapType: {
                get: function() {
                    return this.shadowMap.type
                },
                set: function(a) {
                    console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = a
                }
            },
            shadowMapCullFace: {
                get: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
                },
                set: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
                }
            },
            context: {
                get: function() {
                    return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext()
                }
            },
            vr: {
                get: function() {
                    return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"), this.xr
                }
            },
            gammaInput: {
                get: function() {
                    return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."), !1
                },
                set: function() {
                    console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")
                }
            },
            gammaOutput: {
                get: function() {
                    return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), !1
                },
                set: function(a) {
                    console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = a === !0 ? Ot : vt
                }
            },
            toneMappingWhitePoint: {
                get: function() {
                    return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."), 1
                },
                set: function() {
                    console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")
                }
            }
        }), Object.defineProperties($u.prototype, {
            cullFace: {
                get: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                },
                set: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                }
            },
            renderReverseSided: {
                get: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
                },
                set: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
                }
            },
            renderSingleSided: {
                get: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                },
                set: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                }
            }
        }), Object.defineProperties(Dt.prototype, {
            wrapS: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS
                },
                set: function(a) {
                    console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = a
                }
            },
            wrapT: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT
                },
                set: function(a) {
                    console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = a
                }
            },
            magFilter: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter
                },
                set: function(a) {
                    console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = a
                }
            },
            minFilter: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter
                },
                set: function(a) {
                    console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = a
                }
            },
            anisotropy: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy
                },
                set: function(a) {
                    console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = a
                }
            },
            offset: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset
                },
                set: function(a) {
                    console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = a
                }
            },
            repeat: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat
                },
                set: function(a) {
                    console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = a
                }
            },
            format: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format
                },
                set: function(a) {
                    console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = a
                }
            },
            type: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type
                },
                set: function(a) {
                    console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = a
                }
            },
            generateMipmaps: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps
                },
                set: function(a) {
                    console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = a
                }
            }
        }), Dx.prototype.load = function(a) {
            console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
            const e = this;
            return new Rx().load(a, function(n) {
                e.setBuffer(n)
            }), this
        }, ko.prototype.updateCubeMap = function(a, e) {
            return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(a, e)
        }, ko.prototype.clear = function(a, e, t, n) {
            return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."), this.renderTarget.clear(a, e, t, n)
        }, Ki.crossOrigin = void 0, Ki.loadTexture = function(a, e, t, n) {
            console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
            const i = new gl;
            i.setCrossOrigin(this.crossOrigin);
            const r = i.load(a, t, void 0, n);
            return e && (r.mapping = e), r
        }, Ki.loadTextureCube = function(a, e, t, n) {
            console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
            const i = new wx;
            i.setCrossOrigin(this.crossOrigin);
            const r = i.load(a, t, void 0, n);
            return e && (r.mapping = e), r
        }, Ki.loadCompressedTexture = function() {
            console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
        }, Ki.loadCompressedTextureCube = function() {
            console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
        }, typeof __THREE_DEVTOOLS__ != "undefined" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
            detail: {
                revision: dt
            }
        })), typeof window != "undefined" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = dt);
        class Ts {
            constructor() {
                this.enabled = !0, this.needsSwap = !0, this.clear = !1, this.renderToScreen = !1
            }
            setSize() {}
            render() {
                console.error("THREE.Pass: .render() must be implemented in derived pass.")
            }
        }
        const $x = new dr(-1, 1, 1, -1, 0, 1),
            Tl = new ke;
        Tl.setAttribute("position", new Je([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), Tl.setAttribute("uv", new Je([0, 2, 0, 0, 2, 0], 2));
        class $h {
            constructor(e) {
                this._mesh = new Ge(Tl, e)
            }
            dispose() {
                this._mesh.geometry.dispose()
            }
            render(e) {
                e.render(this._mesh, $x)
            }
            get material() {
                return this._mesh.material
            }
            set material(e) {
                this._mesh.material = e
            }
        }
        class Kx extends Ts {
            constructor(e, t, n, i, r) {
                super();
                this.scene = e, this.camera = t, this.overrideMaterial = n, this.clearColor = i, this.clearAlpha = r !== void 0 ? r : 0, this.clear = !0, this.clearDepth = !1, this.needsSwap = !1, this._oldClearColor = new ne
            }
            render(e, t, n) {
                const i = e.autoClear;
                e.autoClear = !1;
                let r, s;
                this.overrideMaterial !== void 0 && (s = this.scene.overrideMaterial, this.scene.overrideMaterial = this.overrideMaterial), this.clearColor && (e.getClearColor(this._oldClearColor), r = e.getClearAlpha(), e.setClearColor(this.clearColor, this.clearAlpha)), this.clearDepth && e.clearDepth(), e.setRenderTarget(this.renderToScreen ? null : n), this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), e.render(this.scene, this.camera), this.clearColor && e.setClearColor(this._oldClearColor, r), this.overrideMaterial !== void 0 && (this.scene.overrideMaterial = s), e.autoClear = i
            }
        }
        class El extends Ts {
            constructor(e, t) {
                super();
                this.textureID = t !== void 0 ? t : "tDiffuse", e instanceof It ? (this.uniforms = e.uniforms, this.material = e) : e && (this.uniforms = ls.clone(e.uniforms), this.material = new It({
                    defines: Object.assign({}, e.defines),
                    uniforms: this.uniforms,
                    vertexShader: e.vertexShader,
                    fragmentShader: e.fragmentShader
                })), this.fsQuad = new $h(this.material)
            }
            render(e, t, n) {
                this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = n.texture), this.fsQuad.material = this.material, this.renderToScreen ? (e.setRenderTarget(null), this.fsQuad.render(e)) : (e.setRenderTarget(t), this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), this.fsQuad.render(e))
            }
        }
        var Ga = {
            uniforms: {
                tDiffuse: {
                    value: null
                },
                opacity: {
                    value: 1
                }
            },
            vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
            fragmentShader: `

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );
			gl_FragColor = opacity * texel;

		}`
        };
        class Kh extends Ts {
            constructor(e, t) {
                super();
                this.scene = e, this.camera = t, this.clear = !0, this.needsSwap = !1, this.inverse = !1
            }
            render(e, t, n) {
                const i = e.getContext(),
                    r = e.state;
                r.buffers.color.setMask(!1), r.buffers.depth.setMask(!1), r.buffers.color.setLocked(!0), r.buffers.depth.setLocked(!0);
                let s, o;
                this.inverse ? (s = 0, o = 1) : (s = 1, o = 0), r.buffers.stencil.setTest(!0), r.buffers.stencil.setOp(i.REPLACE, i.REPLACE, i.REPLACE), r.buffers.stencil.setFunc(i.ALWAYS, s, 4294967295), r.buffers.stencil.setClear(o), r.buffers.stencil.setLocked(!0), e.setRenderTarget(n), this.clear && e.clear(), e.render(this.scene, this.camera), e.setRenderTarget(t), this.clear && e.clear(), e.render(this.scene, this.camera), r.buffers.color.setLocked(!1), r.buffers.depth.setLocked(!1), r.buffers.stencil.setLocked(!1), r.buffers.stencil.setFunc(i.EQUAL, 1, 4294967295), r.buffers.stencil.setOp(i.KEEP, i.KEEP, i.KEEP), r.buffers.stencil.setLocked(!0)
            }
        }
        class Qx extends Ts {
            constructor() {
                super();
                this.needsSwap = !1
            }
            render(e) {
                e.state.buffers.stencil.setLocked(!1), e.state.buffers.stencil.setTest(!1)
            }
        }
        class Qh {
            constructor(e, t) {
                if (this.renderer = e, t === void 0) {
                    const n = {
                            minFilter: lt,
                            magFilter: lt,
                            format: ct
                        },
                        i = e.getSize(new X);
                    this._pixelRatio = e.getPixelRatio(), this._width = i.width, this._height = i.height, t = new Dt(this._width * this._pixelRatio, this._height * this._pixelRatio, n), t.texture.name = "EffectComposer.rt1"
                } else this._pixelRatio = 1, this._width = t.width, this._height = t.height;
                this.renderTarget1 = t, this.renderTarget2 = t.clone(), this.renderTarget2.texture.name = "EffectComposer.rt2", this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2, this.renderToScreen = !0, this.passes = [], Ga === void 0 && console.error("THREE.EffectComposer relies on CopyShader"), El === void 0 && console.error("THREE.EffectComposer relies on ShaderPass"), this.copyPass = new El(Ga), this.clock = new jh
            }
            swapBuffers() {
                const e = this.readBuffer;
                this.readBuffer = this.writeBuffer, this.writeBuffer = e
            }
            addPass(e) {
                this.passes.push(e), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
            }
            insertPass(e, t) {
                this.passes.splice(t, 0, e), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
            }
            removePass(e) {
                const t = this.passes.indexOf(e);
                t !== -1 && this.passes.splice(t, 1)
            }
            isLastEnabledPass(e) {
                for (let t = e + 1; t < this.passes.length; t++)
                    if (this.passes[t].enabled) return !1;
                return !0
            }
            render(e) {
                e === void 0 && (e = this.clock.getDelta());
                const t = this.renderer.getRenderTarget();
                let n = !1;
                for (let i = 0, r = this.passes.length; i < r; i++) {
                    const s = this.passes[i];
                    if (s.enabled !== !1) {
                        if (s.renderToScreen = this.renderToScreen && this.isLastEnabledPass(i), s.render(this.renderer, this.writeBuffer, this.readBuffer, e, n), s.needsSwap) {
                            if (n) {
                                const o = this.renderer.getContext(),
                                    l = this.renderer.state.buffers.stencil;
                                l.setFunc(o.NOTEQUAL, 1, 4294967295), this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, e), l.setFunc(o.EQUAL, 1, 4294967295)
                            }
                            this.swapBuffers()
                        }
                        Kh !== void 0 && (s instanceof Kh ? n = !0 : s instanceof Qx && (n = !1))
                    }
                }
                this.renderer.setRenderTarget(t)
            }
            reset(e) {
                if (e === void 0) {
                    const t = this.renderer.getSize(new X);
                    this._pixelRatio = this.renderer.getPixelRatio(), this._width = t.width, this._height = t.height, e = this.renderTarget1.clone(), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
                }
                this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.renderTarget1 = e, this.renderTarget2 = e.clone(), this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2
            }
            setSize(e, t) {
                this._width = e, this._height = t;
                const n = this._width * this._pixelRatio,
                    i = this._height * this._pixelRatio;
                this.renderTarget1.setSize(n, i), this.renderTarget2.setSize(n, i);
                for (let r = 0; r < this.passes.length; r++) this.passes[r].setSize(n, i)
            }
            setPixelRatio(e) {
                this._pixelRatio = e, this.setSize(this._width, this._height)
            }
        }
        new dr(-1, 1, 1, -1, 0, 1);
        const ef = new ke;
        ef.setAttribute("position", new Je([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), ef.setAttribute("uv", new Je([0, 2, 0, 0, 2, 0], 2));
        const tf = {
            shaderID: "luminosityHighPass",
            uniforms: {
                tDiffuse: {
                    value: null
                },
                luminosityThreshold: {
                    value: 1
                },
                smoothWidth: {
                    value: 1
                },
                defaultColor: {
                    value: new ne(0)
                },
                defaultOpacity: {
                    value: 0
                }
            },
            vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
            fragmentShader: `

		uniform sampler2D tDiffuse;
		uniform vec3 defaultColor;
		uniform float defaultOpacity;
		uniform float luminosityThreshold;
		uniform float smoothWidth;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );

			vec3 luma = vec3( 0.299, 0.587, 0.114 );

			float v = dot( texel.xyz, luma );

			vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );

			float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );

			gl_FragColor = mix( outputColor, texel, alpha );

		}`
        };
        class Fr extends Ts {
            constructor(e, t, n, i) {
                super();
                this.strength = t !== void 0 ? t : 1, this.radius = n, this.threshold = i, this.resolution = e !== void 0 ? new X(e.x, e.y) : new X(256, 256), this.clearColor = new ne(0, 0, 0);
                const r = {
                    minFilter: lt,
                    magFilter: lt,
                    format: ct
                };
                this.renderTargetsHorizontal = [], this.renderTargetsVertical = [], this.nMips = 5;
                let s = Math.round(this.resolution.x / 2),
                    o = Math.round(this.resolution.y / 2);
                this.renderTargetBright = new Dt(s, o, r), this.renderTargetBright.texture.name = "UnrealBloomPass.bright", this.renderTargetBright.texture.generateMipmaps = !1;
                for (let f = 0; f < this.nMips; f++) {
                    const d = new Dt(s, o, r);
                    d.texture.name = "UnrealBloomPass.h" + f, d.texture.generateMipmaps = !1, this.renderTargetsHorizontal.push(d);
                    const m = new Dt(s, o, r);
                    m.texture.name = "UnrealBloomPass.v" + f, m.texture.generateMipmaps = !1, this.renderTargetsVertical.push(m), s = Math.round(s / 2), o = Math.round(o / 2)
                }
                tf === void 0 && console.error("THREE.UnrealBloomPass relies on LuminosityHighPassShader");
                const l = tf;
                this.highPassUniforms = ls.clone(l.uniforms), this.highPassUniforms.luminosityThreshold.value = i, this.highPassUniforms.smoothWidth.value = .01, this.materialHighPassFilter = new It({
                    uniforms: this.highPassUniforms,
                    vertexShader: l.vertexShader,
                    fragmentShader: l.fragmentShader,
                    defines: {}
                }), this.separableBlurMaterials = [];
                const c = [3, 5, 7, 9, 11];
                s = Math.round(this.resolution.x / 2), o = Math.round(this.resolution.y / 2);
                for (let f = 0; f < this.nMips; f++) this.separableBlurMaterials.push(this.getSeperableBlurMaterial(c[f])), this.separableBlurMaterials[f].uniforms.texSize.value = new X(s, o), s = Math.round(s / 2), o = Math.round(o / 2);
                this.compositeMaterial = this.getCompositeMaterial(this.nMips), this.compositeMaterial.uniforms.blurTexture1.value = this.renderTargetsVertical[0].texture, this.compositeMaterial.uniforms.blurTexture2.value = this.renderTargetsVertical[1].texture, this.compositeMaterial.uniforms.blurTexture3.value = this.renderTargetsVertical[2].texture, this.compositeMaterial.uniforms.blurTexture4.value = this.renderTargetsVertical[3].texture, this.compositeMaterial.uniforms.blurTexture5.value = this.renderTargetsVertical[4].texture, this.compositeMaterial.uniforms.bloomStrength.value = t, this.compositeMaterial.uniforms.bloomRadius.value = .1, this.compositeMaterial.needsUpdate = !0;
                const u = [1, .8, .6, .4, .2];
                this.compositeMaterial.uniforms.bloomFactors.value = u, this.bloomTintColors = [new E(1, 1, 1), new E(1, 1, 1), new E(1, 1, 1), new E(1, 1, 1), new E(1, 1, 1)], this.compositeMaterial.uniforms.bloomTintColors.value = this.bloomTintColors, Ga === void 0 && console.error("THREE.UnrealBloomPass relies on CopyShader");
                const h = Ga;
                this.copyUniforms = ls.clone(h.uniforms), this.copyUniforms.opacity.value = 1, this.materialCopy = new It({
                    uniforms: this.copyUniforms,
                    vertexShader: h.vertexShader,
                    fragmentShader: h.fragmentShader,
                    blending: to,
                    depthTest: !1,
                    depthWrite: !1,
                    transparent: !0
                }), this.enabled = !0, this.needsSwap = !1, this._oldClearColor = new ne, this.oldClearAlpha = 1, this.basic = new un, this.fsQuad = new $h(null)
            }
            dispose() {
                for (let e = 0; e < this.renderTargetsHorizontal.length; e++) this.renderTargetsHorizontal[e].dispose();
                for (let e = 0; e < this.renderTargetsVertical.length; e++) this.renderTargetsVertical[e].dispose();
                this.renderTargetBright.dispose()
            }
            setSize(e, t) {
                let n = Math.round(e / 2),
                    i = Math.round(t / 2);
                this.renderTargetBright.setSize(n, i);
                for (let r = 0; r < this.nMips; r++) this.renderTargetsHorizontal[r].setSize(n, i), this.renderTargetsVertical[r].setSize(n, i), this.separableBlurMaterials[r].uniforms.texSize.value = new X(n, i), n = Math.round(n / 2), i = Math.round(i / 2)
            }
            render(e, t, n, i, r) {
                e.getClearColor(this._oldClearColor), this.oldClearAlpha = e.getClearAlpha();
                const s = e.autoClear;
                e.autoClear = !1, e.setClearColor(this.clearColor, 0), r && e.state.buffers.stencil.setTest(!1), this.renderToScreen && (this.fsQuad.material = this.basic, this.basic.map = n.texture, e.setRenderTarget(null), e.clear(), this.fsQuad.render(e)), this.highPassUniforms.tDiffuse.value = n.texture, this.highPassUniforms.luminosityThreshold.value = this.threshold, this.fsQuad.material = this.materialHighPassFilter, e.setRenderTarget(this.renderTargetBright), e.clear(), this.fsQuad.render(e);
                let o = this.renderTargetBright;
                for (let l = 0; l < this.nMips; l++) this.fsQuad.material = this.separableBlurMaterials[l], this.separableBlurMaterials[l].uniforms.colorTexture.value = o.texture, this.separableBlurMaterials[l].uniforms.direction.value = Fr.BlurDirectionX, e.setRenderTarget(this.renderTargetsHorizontal[l]), e.clear(), this.fsQuad.render(e), this.separableBlurMaterials[l].uniforms.colorTexture.value = this.renderTargetsHorizontal[l].texture, this.separableBlurMaterials[l].uniforms.direction.value = Fr.BlurDirectionY, e.setRenderTarget(this.renderTargetsVertical[l]), e.clear(), this.fsQuad.render(e), o = this.renderTargetsVertical[l];
                this.fsQuad.material = this.compositeMaterial, this.compositeMaterial.uniforms.bloomStrength.value = this.strength, this.compositeMaterial.uniforms.bloomRadius.value = this.radius, this.compositeMaterial.uniforms.bloomTintColors.value = this.bloomTintColors, e.setRenderTarget(this.renderTargetsHorizontal[0]), e.clear(), this.fsQuad.render(e), this.fsQuad.material = this.materialCopy, this.copyUniforms.tDiffuse.value = this.renderTargetsHorizontal[0].texture, r && e.state.buffers.stencil.setTest(!0), this.renderToScreen ? (e.setRenderTarget(null), this.fsQuad.render(e)) : (e.setRenderTarget(n), this.fsQuad.render(e)), e.setClearColor(this._oldClearColor, this.oldClearAlpha), e.autoClear = s
            }
            getSeperableBlurMaterial(e) {
                return new It({
                    defines: {
                        KERNEL_RADIUS: e,
                        SIGMA: e
                    },
                    uniforms: {
                        colorTexture: {
                            value: null
                        },
                        texSize: {
                            value: new X(.5, .5)
                        },
                        direction: {
                            value: new X(.5, .5)
                        }
                    },
                    vertexShader: `varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,
                    fragmentShader: `#include <common>
				varying vec2 vUv;
				uniform sampler2D colorTexture;
				uniform vec2 texSize;
				uniform vec2 direction;

				float gaussianPdf(in float x, in float sigma) {
					return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;
				}
				void main() {
					vec2 invSize = 1.0 / texSize;
					float fSigma = float(SIGMA);
					float weightSum = gaussianPdf(0.0, fSigma);
					vec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;
					for( int i = 1; i < KERNEL_RADIUS; i ++ ) {
						float x = float(i);
						float w = gaussianPdf(x, fSigma);
						vec2 uvOffset = direction * invSize * x;
						vec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;
						vec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;
						diffuseSum += (sample1 + sample2) * w;
						weightSum += 2.0 * w;
					}
					gl_FragColor = vec4(diffuseSum/weightSum, 1.0);
				}`
                })
            }
            getCompositeMaterial(e) {
                return new It({
                    defines: {
                        NUM_MIPS: e
                    },
                    uniforms: {
                        blurTexture1: {
                            value: null
                        },
                        blurTexture2: {
                            value: null
                        },
                        blurTexture3: {
                            value: null
                        },
                        blurTexture4: {
                            value: null
                        },
                        blurTexture5: {
                            value: null
                        },
                        dirtTexture: {
                            value: null
                        },
                        bloomStrength: {
                            value: 1
                        },
                        bloomFactors: {
                            value: null
                        },
                        bloomTintColors: {
                            value: null
                        },
                        bloomRadius: {
                            value: 0
                        }
                    },
                    vertexShader: `varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,
                    fragmentShader: `varying vec2 vUv;
				uniform sampler2D blurTexture1;
				uniform sampler2D blurTexture2;
				uniform sampler2D blurTexture3;
				uniform sampler2D blurTexture4;
				uniform sampler2D blurTexture5;
				uniform sampler2D dirtTexture;
				uniform float bloomStrength;
				uniform float bloomRadius;
				uniform float bloomFactors[NUM_MIPS];
				uniform vec3 bloomTintColors[NUM_MIPS];

				float lerpBloomFactor(const in float factor) {
					float mirrorFactor = 1.2 - factor;
					return mix(factor, mirrorFactor, bloomRadius);
				}

				void main() {
					gl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +
						lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +
						lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +
						lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +
						lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );
				}`
                })
            }
        }
        Fr.BlurDirectionX = new X(1, 0), Fr.BlurDirectionY = new X(0, 1);

        function Cn(a) {
            if (a === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return a
        }

        function nf(a, e) {
            a.prototype = Object.create(e.prototype), a.prototype.constructor = a, a.__proto__ = e
        }
        /*!
         * GSAP 3.8.0
         * https://greensock.com
         *
         * @license Copyright 2008-2021, GreenSock. All rights reserved.
         * Subject to the terms at https://greensock.com/standard-license or for
         * Club GreenSock members, the agreement issued with that membership.
         * @author: Jack Doyle, jack@greensock.com
         */
        var Ft = {
                autoSleep: 120,
                force3D: "auto",
                nullTargetWarn: 1,
                units: {
                    lineHeight: ""
                }
            },
            zr = {
                duration: .5,
                overwrite: !1,
                delay: 0
            },
            Al, mn = 1e8,
            Ve = 1 / mn,
            Ll = Math.PI * 2,
            ey = Ll / 4,
            ty = 0,
            rf = Math.sqrt,
            ny = Math.cos,
            iy = Math.sin,
            gt = function(e) {
                return typeof e == "string"
            },
            ht = function(e) {
                return typeof e == "function"
            },
            Pn = function(e) {
                return typeof e == "number"
            },
            Rl = function(e) {
                return typeof e == "undefined"
            },
            Dn = function(e) {
                return typeof e == "object"
            },
            zt = function(e) {
                return e !== !1
            },
            sf = function() {
                return typeof window != "undefined"
            },
            af = function(e) {
                return ht(e) || gt(e)
            },
            of = typeof ArrayBuffer == "function" && ArrayBuffer.isView || function() {},
            Gt = Array.isArray,
            Cl = /(?:-?\.?\d|\.)+/gi,
            lf = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
            Nr = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
            Pl = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
            cf = /[+-]=-?[.\d]+/,
            uf = /[^,'"\[\]\s]+/gi,
            ry = /[\d.+\-=]+(?:e[-+]\d*)*/i,
            Ze, gn, Dl, Il, Ht = {},
            Ha = {},
            hf, ff = function(e) {
                return (Ha = Or(e, Ht)) && vn
            },
            Fl = function(e, t) {
                return console.warn("Invalid property", e, "set to", t, "Missing plugin? gsap.registerPlugin()")
            },
            Va = function(e, t) {
                return !t && console.warn(e)
            },
            df = function(e, t) {
                return e && (Ht[e] = t) && Ha && (Ha[e] = t) || Ht
            },
            Br = function() {
                return 0
            },
            zl = {},
            ri = [],
            Nl = {},
            pf, Vt = {},
            Bl = {},
            mf = 30,
            Wa = [],
            Ol = "",
            Ul = function(e) {
                var t = e[0],
                    n, i;
                if (Dn(t) || ht(t) || (e = [e]), !(n = (t._gsap || {}).harness)) {
                    for (i = Wa.length; i-- && !Wa[i].targetTest(t););
                    n = Wa[i]
                }
                for (i = e.length; i--;) e[i] && (e[i]._gsap || (e[i]._gsap = new Hf(e[i], n))) || e.splice(i, 1);
                return e
            },
            Ri = function(e) {
                return e._gsap || Ul(Kt(e))[0]._gsap
            },
            gf = function(e, t, n) {
                return (n = e[t]) && ht(n) ? e[t]() : Rl(n) && e.getAttribute && e.getAttribute(t) || n
            },
            Wt = function(e, t) {
                return (e = e.split(",")).forEach(t) || e
            },
            rt = function(e) {
                return Math.round(e * 1e5) / 1e5 || 0
            },
            bt = function(e) {
                return Math.round(e * 1e7) / 1e7 || 0
            },
            sy = function(e, t) {
                for (var n = t.length, i = 0; e.indexOf(t[i]) < 0 && ++i < n;);
                return i < n
            },
            qa = function() {
                var e = ri.length,
                    t = ri.slice(0),
                    n, i;
                for (Nl = {}, ri.length = 0, n = 0; n < e; n++) i = t[n], i && i._lazy && (i.render(i._lazy[0], i._lazy[1], !0)._lazy = 0)
            },
            _f = function(e, t, n, i) {
                ri.length && qa(), e.render(t, n, i), ri.length && qa()
            },
            vf = function(e) {
                var t = parseFloat(e);
                return (t || t === 0) && (e + "").match(uf).length < 2 ? t : gt(e) ? e.trim() : e
            },
            xf = function(e) {
                return e
            },
            Jt = function(e, t) {
                for (var n in t) n in e || (e[n] = t[n]);
                return e
            },
            ay = function(e, t) {
                for (var n in t) n in e || n === "duration" || n === "ease" || (e[n] = t[n])
            },
            Or = function(e, t) {
                for (var n in t) e[n] = t[n];
                return e
            },
            yf = function a(e, t) {
                for (var n in t) n !== "__proto__" && n !== "constructor" && n !== "prototype" && (e[n] = Dn(t[n]) ? a(e[n] || (e[n] = {}), t[n]) : t[n]);
                return e
            },
            kl = function(e, t) {
                var n = {},
                    i;
                for (i in e) i in t || (n[i] = e[i]);
                return n
            },
            Es = function(e) {
                var t = e.parent || Ze,
                    n = e.keyframes ? ay : Jt;
                if (zt(e.inherit))
                    for (; t;) n(e, t.vars.defaults), t = t.parent || t._dp;
                return e
            },
            oy = function(e, t) {
                for (var n = e.length, i = n === t.length; i && n-- && e[n] === t[n];);
                return n < 0
            },
            ly = function(e, t, n, i, r) {
                n === void 0 && (n = "_first"), i === void 0 && (i = "_last");
                var s = e[i],
                    o;
                if (r)
                    for (o = t[r]; s && s[r] > o;) s = s._prev;
                return s ? (t._next = s._next, s._next = t) : (t._next = e[n], e[n] = t), t._next ? t._next._prev = t : e[i] = t, t._prev = s, t.parent = t._dp = e, t
            },
            Xa = function(e, t, n, i) {
                n === void 0 && (n = "_first"), i === void 0 && (i = "_last");
                var r = t._prev,
                    s = t._next;
                r ? r._next = s : e[n] === t && (e[n] = s), s ? s._prev = r : e[i] === t && (e[i] = r), t._next = t._prev = t.parent = null
            },
            si = function(e, t) {
                e.parent && (!t || e.parent.autoRemoveChildren) && e.parent.remove(e), e._act = 0
            },
            Ci = function(e, t) {
                if (e && (!t || t._end > e._dur || t._start < 0))
                    for (var n = e; n;) n._dirty = 1, n = n.parent;
                return e
            },
            cy = function(e) {
                for (var t = e.parent; t && t.parent;) t._dirty = 1, t.totalDuration(), t = t.parent;
                return e
            },
            uy = function a(e) {
                return !e || e._ts && a(e.parent)
            },
            Mf = function(e) {
                return e._repeat ? Ur(e._tTime, e = e.duration() + e._rDelay) * e : 0
            },
            Ur = function(e, t) {
                var n = Math.floor(e /= t);
                return e && n === e ? n - 1 : n
            },
            ja = function(e, t) {
                return (e - t._start) * t._ts + (t._ts >= 0 ? 0 : t._dirty ? t.totalDuration() : t._tDur)
            },
            Ya = function(e) {
                return e._end = bt(e._start + (e._tDur / Math.abs(e._ts || e._rts || Ve) || 0))
            },
            bf = function(e, t) {
                var n = e._dp;
                return n && n.smoothChildTiming && e._ts && (e._start = bt(n._time - (e._ts > 0 ? t / e._ts : ((e._dirty ? e.totalDuration() : e._tDur) - t) / -e._ts)), Ya(e), n._dirty || Ci(n, e)), e
            },
            wf = function(e, t) {
                var n;
                if ((t._time || t._initted && !t._dur) && (n = ja(e.rawTime(), t), (!t._dur || Ls(0, t.totalDuration(), n) - t._tTime > Ve) && t.render(n, !0)), Ci(e, t)._dp && e._initted && e._time >= e._dur && e._ts) {
                    if (e._dur < e.duration())
                        for (n = e; n._dp;) n.rawTime() >= 0 && n.totalTime(n._tTime), n = n._dp;
                    e._zTime = -Ve
                }
            },
            _n = function(e, t, n, i) {
                return t.parent && si(t), t._start = bt((Pn(n) ? n : n || e !== Ze ? $t(e, n, t) : e._time) + t._delay), t._end = bt(t._start + (t.totalDuration() / Math.abs(t.timeScale()) || 0)), ly(e, t, "_first", "_last", e._sort ? "_start" : 0), Gl(t) || (e._recent = t), i || wf(e, t), e
            },
            Sf = function(e, t) {
                return (Ht.ScrollTrigger || Fl("scrollTrigger", t)) && Ht.ScrollTrigger.create(t, e)
            },
            Tf = function(e, t, n, i) {
                if (Iy(e, t), !e._initted) return 1;
                if (!n && e._pt && (e._dur && e.vars.lazy !== !1 || !e._dur && e.vars.lazy) && pf !== en.frame) return ri.push(e), e._lazy = [t, i], 1
            },
            hy = function a(e) {
                var t = e.parent;
                return t && t._ts && t._initted && !t._lock && (t.rawTime() < 0 || a(t))
            },
            Gl = function(e) {
                var t = e.data;
                return t === "isFromStart" || t === "isStart"
            },
            fy = function(e, t, n, i) {
                var r = e.ratio,
                    s = t < 0 || !t && (!e._start && hy(e) && !(!e._initted && Gl(e)) || (e._ts < 0 || e._dp._ts < 0) && !Gl(e)) ? 0 : 1,
                    o = e._rDelay,
                    l = 0,
                    c, u, h;
                if (o && e._repeat && (l = Ls(0, e._tDur, t), u = Ur(l, o), h = Ur(e._tTime, o), e._yoyo && u & 1 && (s = 1 - s), u !== h && (r = 1 - s, e.vars.repeatRefresh && e._initted && e.invalidate())), s !== r || i || e._zTime === Ve || !t && e._zTime) {
                    if (!e._initted && Tf(e, t, i, n)) return;
                    for (h = e._zTime, e._zTime = t || (n ? Ve : 0), n || (n = t && !h), e.ratio = s, e._from && (s = 1 - s), e._time = 0, e._tTime = l, c = e._pt; c;) c.r(s, c.d), c = c._next;
                    e._startAt && t < 0 && e._startAt.render(t, !0, !0), e._onUpdate && !n && Qt(e, "onUpdate"), l && e._repeat && !n && e.parent && Qt(e, "onRepeat"), (t >= e._tDur || t < 0) && e.ratio === s && (s && si(e, 1), n || (Qt(e, s ? "onComplete" : "onReverseComplete", !0), e._prom && e._prom()))
                } else e._zTime || (e._zTime = t)
            },
            dy = function(e, t, n) {
                var i;
                if (n > t)
                    for (i = e._first; i && i._start <= n;) {
                        if (!i._dur && i.data === "isPause" && i._start > t) return i;
                        i = i._next
                    } else
                        for (i = e._last; i && i._start >= n;) {
                            if (!i._dur && i.data === "isPause" && i._start < t) return i;
                            i = i._prev
                        }
            },
            kr = function(e, t, n, i) {
                var r = e._repeat,
                    s = bt(t) || 0,
                    o = e._tTime / e._tDur;
                return o && !i && (e._time *= s / e._dur), e._dur = s, e._tDur = r ? r < 0 ? 1e10 : bt(s * (r + 1) + e._rDelay * r) : s, o && !i ? bf(e, e._tTime = e._tDur * o) : e.parent && Ya(e), n || Ci(e.parent, e), e
            },
            Ef = function(e) {
                return e instanceof Nt ? Ci(e) : kr(e, e._dur)
            },
            py = {
                _start: 0,
                endTime: Br,
                totalDuration: Br
            },
            $t = function a(e, t, n) {
                var i = e.labels,
                    r = e._recent || py,
                    s = e.duration() >= mn ? r.endTime(!1) : e._dur,
                    o, l, c;
                return gt(t) && (isNaN(t) || t in i) ? (l = t.charAt(0), c = t.substr(-1) === "%", o = t.indexOf("="), l === "<" || l === ">" ? (o >= 0 && (t = t.replace(/=/, "")), (l === "<" ? r._start : r.endTime(r._repeat >= 0)) + (parseFloat(t.substr(1)) || 0) * (c ? (o < 0 ? r : n).totalDuration() / 100 : 1)) : o < 0 ? (t in i || (i[t] = s), i[t]) : (l = parseFloat(t.charAt(o - 1) + t.substr(o + 1)), c && n && (l = l / 100 * (Gt(n) ? n[0] : n).totalDuration()), o > 1 ? a(e, t.substr(0, o - 1), n) + l : s + l)) : t == null ? s : +t
            },
            As = function(e, t, n) {
                var i = Pn(t[1]),
                    r = (i ? 2 : 1) + (e < 2 ? 0 : 1),
                    s = t[r],
                    o, l;
                if (i && (s.duration = t[1]), s.parent = n, e) {
                    for (o = s, l = n; l && !("immediateRender" in o);) o = l.vars.defaults || {}, l = zt(l.vars.inherit) && l.parent;
                    s.immediateRender = zt(o.immediateRender), e < 2 ? s.runBackwards = 1 : s.startAt = t[r - 1]
                }
                return new ft(t[0], s, t[r + 1])
            },
            ai = function(e, t) {
                return e || e === 0 ? t(e) : t
            },
            Ls = function(e, t, n) {
                return n < e ? e : n > t ? t : n
            },
            qt = function(e) {
                if (typeof e != "string") return "";
                var t = ry.exec(e);
                return t ? e.substr(t.index + t[0].length) : ""
            },
            my = function(e, t, n) {
                return ai(n, function(i) {
                    return Ls(e, t, i)
                })
            },
            Hl = [].slice,
            Af = function(e, t) {
                return e && Dn(e) && "length" in e && (!t && !e.length || e.length - 1 in e && Dn(e[0])) && !e.nodeType && e !== gn
            },
            gy = function(e, t, n) {
                return n === void 0 && (n = []), e.forEach(function(i) {
                    var r;
                    return gt(i) && !t || Af(i, 1) ? (r = n).push.apply(r, Kt(i)) : n.push(i)
                }) || n
            },
            Kt = function(e, t, n) {
                return gt(e) && !n && (Dl || !Hr()) ? Hl.call((t || Il).querySelectorAll(e), 0) : Gt(e) ? gy(e, n) : Af(e) ? Hl.call(e, 0) : e ? [e] : []
            },
            _y = function(e) {
                return e = Kt(e)[0] || Va("Invalid scope") || {},
                    function(t) {
                        var n = e.current || e.nativeElement || e;
                        return Kt(t, n.querySelectorAll ? n : n === e ? Va("Invalid scope") || Il.createElement("div") : e)
                    }
            },
            Lf = function(e) {
                return e.sort(function() {
                    return .5 - Math.random()
                })
            },
            Rf = function(e) {
                if (ht(e)) return e;
                var t = Dn(e) ? e : {
                        each: e
                    },
                    n = Vr(t.ease),
                    i = t.from || 0,
                    r = parseFloat(t.base) || 0,
                    s = {},
                    o = i > 0 && i < 1,
                    l = isNaN(i) || o,
                    c = t.axis,
                    u = i,
                    h = i;
                return gt(i) ? u = h = {
                        center: .5,
                        edges: .5,
                        end: 1
                    }[i] || 0 : !o && l && (u = i[0], h = i[1]),
                    function(f, d, m) {
                        var g = (m || t).length,
                            v = s[g],
                            p, _, M, y, b, T, x, R, P;
                        if (!v) {
                            if (P = t.grid === "auto" ? 0 : (t.grid || [1, mn])[1], !P) {
                                for (x = -mn; x < (x = m[P++].getBoundingClientRect().left) && P < g;);
                                P--
                            }
                            for (v = s[g] = [], p = l ? Math.min(P, g) * u - .5 : i % P, _ = l ? g * h / P - .5 : i / P | 0, x = 0, R = mn, T = 0; T < g; T++) M = T % P - p, y = _ - (T / P | 0), v[T] = b = c ? Math.abs(c === "y" ? y : M) : rf(M * M + y * y), b > x && (x = b), b < R && (R = b);
                            i === "random" && Lf(v), v.max = x - R, v.min = R, v.v = g = (parseFloat(t.amount) || parseFloat(t.each) * (P > g ? g - 1 : c ? c === "y" ? g / P : P : Math.max(P, g / P)) || 0) * (i === "edges" ? -1 : 1), v.b = g < 0 ? r - g : r, v.u = qt(t.amount || t.each) || 0, n = n && g < 0 ? Uf(n) : n
                        }
                        return g = (v[f] - v.min) / v.max || 0, bt(v.b + (n ? n(g) : g) * v.v) + v.u
                    }
            },
            Vl = function(e) {
                var t = Math.pow(10, ((e + "").split(".")[1] || "").length);
                return function(n) {
                    var i = Math.round(parseFloat(n) / e) * e * t;
                    return (i - i % 1) / t + (Pn(n) ? 0 : qt(n))
                }
            },
            Cf = function(e, t) {
                var n = Gt(e),
                    i, r;
                return !n && Dn(e) && (i = n = e.radius || mn, e.values ? (e = Kt(e.values), (r = !Pn(e[0])) && (i *= i)) : e = Vl(e.increment)), ai(t, n ? ht(e) ? function(s) {
                    return r = e(s), Math.abs(r - s) <= i ? r : s
                } : function(s) {
                    for (var o = parseFloat(r ? s.x : s), l = parseFloat(r ? s.y : 0), c = mn, u = 0, h = e.length, f, d; h--;) r ? (f = e[h].x - o, d = e[h].y - l, f = f * f + d * d) : f = Math.abs(e[h] - o), f < c && (c = f, u = h);
                    return u = !i || c <= i ? e[u] : s, r || u === s || Pn(s) ? u : u + qt(s)
                } : Vl(e))
            },
            Pf = function(e, t, n, i) {
                return ai(Gt(e) ? !t : n === !0 ? !!(n = 0) : !i, function() {
                    return Gt(e) ? e[~~(Math.random() * e.length)] : (n = n || 1e-5) && (i = n < 1 ? Math.pow(10, (n + "").length - 2) : 1) && Math.floor(Math.round((e - n / 2 + Math.random() * (t - e + n * .99)) / n) * n * i) / i
                })
            },
            vy = function() {
                for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
                return function(i) {
                    return t.reduce(function(r, s) {
                        return s(r)
                    }, i)
                }
            },
            xy = function(e, t) {
                return function(n) {
                    return e(parseFloat(n)) + (t || qt(n))
                }
            },
            yy = function(e, t, n) {
                return If(e, t, 0, 1, n)
            },
            Df = function(e, t, n) {
                return ai(n, function(i) {
                    return e[~~t(i)]
                })
            },
            My = function a(e, t, n) {
                var i = t - e;
                return Gt(e) ? Df(e, a(0, e.length), t) : ai(n, function(r) {
                    return (i + (r - e) % i) % i + e
                })
            },
            by = function a(e, t, n) {
                var i = t - e,
                    r = i * 2;
                return Gt(e) ? Df(e, a(0, e.length - 1), t) : ai(n, function(s) {
                    return s = (r + (s - e) % r) % r || 0, e + (s > i ? r - s : s)
                })
            },
            Rs = function(e) {
                for (var t = 0, n = "", i, r, s, o; ~(i = e.indexOf("random(", t));) s = e.indexOf(")", i), o = e.charAt(i + 7) === "[", r = e.substr(i + 7, s - i - 7).match(o ? uf : Cl), n += e.substr(t, i - t) + Pf(o ? r : +r[0], o ? 0 : +r[1], +r[2] || 1e-5), t = s + 1;
                return n + e.substr(t, e.length - t)
            },
            If = function(e, t, n, i, r) {
                var s = t - e,
                    o = i - n;
                return ai(r, function(l) {
                    return n + ((l - e) / s * o || 0)
                })
            },
            wy = function a(e, t, n, i) {
                var r = isNaN(e + t) ? 0 : function(d) {
                    return (1 - d) * e + d * t
                };
                if (!r) {
                    var s = gt(e),
                        o = {},
                        l, c, u, h, f;
                    if (n === !0 && (i = 1) && (n = null), s) e = {
                        p: e
                    }, t = {
                        p: t
                    };
                    else if (Gt(e) && !Gt(t)) {
                        for (u = [], h = e.length, f = h - 2, c = 1; c < h; c++) u.push(a(e[c - 1], e[c]));
                        h--, r = function(m) {
                            m *= h;
                            var g = Math.min(f, ~~m);
                            return u[g](m - g)
                        }, n = t
                    } else i || (e = Or(Gt(e) ? [] : {}, e));
                    if (!u) {
                        for (l in t) jl.call(o, e, l, "get", t[l]);
                        r = function(m) {
                            return Jl(m, o) || (s ? e.p : e)
                        }
                    }
                }
                return ai(n, r)
            },
            Ff = function(e, t, n) {
                var i = e.labels,
                    r = mn,
                    s, o, l;
                for (s in i) o = i[s] - t, o < 0 == !!n && o && r > (o = Math.abs(o)) && (l = s, r = o);
                return l
            },
            Qt = function(e, t, n) {
                var i = e.vars,
                    r = i[t],
                    s, o;
                if (!!r) return s = i[t + "Params"], o = i.callbackScope || e, n && ri.length && qa(), s ? r.apply(o, s) : r.call(o)
            },
            Cs = function(e) {
                return si(e), e.scrollTrigger && e.scrollTrigger.kill(!1), e.progress() < 1 && Qt(e, "onInterrupt"), e
            },
            Gr, Sy = function(e) {
                e = !e.name && e.default || e;
                var t = e.name,
                    n = ht(e),
                    i = t && !n && e.init ? function() {
                        this._props = []
                    } : e,
                    r = {
                        init: Br,
                        render: Jl,
                        add: jl,
                        kill: ky,
                        modifier: Uy,
                        rawVars: 0
                    },
                    s = {
                        targetTest: 0,
                        get: 0,
                        getSetter: Zl,
                        aliases: {},
                        register: 0
                    };
                if (Hr(), e !== i) {
                    if (Vt[t]) return;
                    Jt(i, Jt(kl(e, r), s)), Or(i.prototype, Or(r, kl(e, s))), Vt[i.prop = t] = i, e.targetTest && (Wa.push(i), zl[t] = 1), t = (t === "css" ? "CSS" : t.charAt(0).toUpperCase() + t.substr(1)) + "Plugin"
                }
                df(t, i), e.register && e.register(vn, i, Bt)
            },
            We = 255,
            Ps = {
                aqua: [0, We, We],
                lime: [0, We, 0],
                silver: [192, 192, 192],
                black: [0, 0, 0],
                maroon: [128, 0, 0],
                teal: [0, 128, 128],
                blue: [0, 0, We],
                navy: [0, 0, 128],
                white: [We, We, We],
                olive: [128, 128, 0],
                yellow: [We, We, 0],
                orange: [We, 165, 0],
                gray: [128, 128, 128],
                purple: [128, 0, 128],
                green: [0, 128, 0],
                red: [We, 0, 0],
                pink: [We, 192, 203],
                cyan: [0, We, We],
                transparent: [We, We, We, 0]
            },
            Wl = function(e, t, n) {
                return e = e < 0 ? e + 1 : e > 1 ? e - 1 : e, (e * 6 < 1 ? t + (n - t) * e * 6 : e < .5 ? n : e * 3 < 2 ? t + (n - t) * (2 / 3 - e) * 6 : t) * We + .5 | 0
            },
            zf = function(e, t, n) {
                var i = e ? Pn(e) ? [e >> 16, e >> 8 & We, e & We] : 0 : Ps.black,
                    r, s, o, l, c, u, h, f, d, m;
                if (!i) {
                    if (e.substr(-1) === "," && (e = e.substr(0, e.length - 1)), Ps[e]) i = Ps[e];
                    else if (e.charAt(0) === "#") {
                        if (e.length < 6 && (r = e.charAt(1), s = e.charAt(2), o = e.charAt(3), e = "#" + r + r + s + s + o + o + (e.length === 5 ? e.charAt(4) + e.charAt(4) : "")), e.length === 9) return i = parseInt(e.substr(1, 6), 16), [i >> 16, i >> 8 & We, i & We, parseInt(e.substr(7), 16) / 255];
                        e = parseInt(e.substr(1), 16), i = [e >> 16, e >> 8 & We, e & We]
                    } else if (e.substr(0, 3) === "hsl") {
                        if (i = m = e.match(Cl), !t) l = +i[0] % 360 / 360, c = +i[1] / 100, u = +i[2] / 100, s = u <= .5 ? u * (c + 1) : u + c - u * c, r = u * 2 - s, i.length > 3 && (i[3] *= 1), i[0] = Wl(l + 1 / 3, r, s), i[1] = Wl(l, r, s), i[2] = Wl(l - 1 / 3, r, s);
                        else if (~e.indexOf("=")) return i = e.match(lf), n && i.length < 4 && (i[3] = 1), i
                    } else i = e.match(Cl) || Ps.transparent;
                    i = i.map(Number)
                }
                return t && !m && (r = i[0] / We, s = i[1] / We, o = i[2] / We, h = Math.max(r, s, o), f = Math.min(r, s, o), u = (h + f) / 2, h === f ? l = c = 0 : (d = h - f, c = u > .5 ? d / (2 - h - f) : d / (h + f), l = h === r ? (s - o) / d + (s < o ? 6 : 0) : h === s ? (o - r) / d + 2 : (r - s) / d + 4, l *= 60), i[0] = ~~(l + .5), i[1] = ~~(c * 100 + .5), i[2] = ~~(u * 100 + .5)), n && i.length < 4 && (i[3] = 1), i
            },
            Nf = function(e) {
                var t = [],
                    n = [],
                    i = -1;
                return e.split(oi).forEach(function(r) {
                    var s = r.match(Nr) || [];
                    t.push.apply(t, s), n.push(i += s.length + 1)
                }), t.c = n, t
            },
            Bf = function(e, t, n) {
                var i = "",
                    r = (e + i).match(oi),
                    s = t ? "hsla(" : "rgba(",
                    o = 0,
                    l, c, u, h;
                if (!r) return e;
                if (r = r.map(function(f) {
                        return (f = zf(f, t, 1)) && s + (t ? f[0] + "," + f[1] + "%," + f[2] + "%," + f[3] : f.join(",")) + ")"
                    }), n && (u = Nf(e), l = n.c, l.join(i) !== u.c.join(i)))
                    for (c = e.replace(oi, "1").split(Nr), h = c.length - 1; o < h; o++) i += c[o] + (~l.indexOf(o) ? r.shift() || s + "0,0,0,0)" : (u.length ? u : r.length ? r : n).shift());
                if (!c)
                    for (c = e.split(oi), h = c.length - 1; o < h; o++) i += c[o] + r[o];
                return i + c[h]
            },
            oi = function() {
                var a = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b",
                    e;
                for (e in Ps) a += "|" + e + "\\b";
                return new RegExp(a + ")", "gi")
            }(),
            Ty = /hsl[a]?\(/,
            Of = function(e) {
                var t = e.join(" "),
                    n;
                if (oi.lastIndex = 0, oi.test(t)) return n = Ty.test(t), e[1] = Bf(e[1], n), e[0] = Bf(e[0], n, Nf(e[1])), !0
            },
            Za, en = function() {
                var a = Date.now,
                    e = 500,
                    t = 33,
                    n = a(),
                    i = n,
                    r = 1e3 / 240,
                    s = r,
                    o = [],
                    l, c, u, h, f, d, m = function g(v) {
                        var p = a() - i,
                            _ = v === !0,
                            M, y, b, T;
                        if (p > e && (n += p - t), i += p, b = i - n, M = b - s, (M > 0 || _) && (T = ++h.frame, f = b - h.time * 1e3, h.time = b = b / 1e3, s += M + (M >= r ? 4 : r - M), y = 1), _ || (l = c(g)), y)
                            for (d = 0; d < o.length; d++) o[d](b, f, T, v)
                    };
                return h = {
                    time: 0,
                    frame: 0,
                    tick: function() {
                        m(!0)
                    },
                    deltaRatio: function(v) {
                        return f / (1e3 / (v || 60))
                    },
                    wake: function() {
                        hf && (!Dl && sf() && (gn = Dl = window, Il = gn.document || {}, Ht.gsap = vn, (gn.gsapVersions || (gn.gsapVersions = [])).push(vn.version), ff(Ha || gn.GreenSockGlobals || !gn.gsap && gn || {}), u = gn.requestAnimationFrame), l && h.sleep(), c = u || function(v) {
                            return setTimeout(v, s - h.time * 1e3 + 1 | 0)
                        }, Za = 1, m(2))
                    },
                    sleep: function() {
                        (u ? gn.cancelAnimationFrame : clearTimeout)(l), Za = 0, c = Br
                    },
                    lagSmoothing: function(v, p) {
                        e = v || 1 / Ve, t = Math.min(p, e, 0)
                    },
                    fps: function(v) {
                        r = 1e3 / (v || 240), s = h.time * 1e3 + r
                    },
                    add: function(v) {
                        o.indexOf(v) < 0 && o.push(v), Hr()
                    },
                    remove: function(v) {
                        var p;
                        ~(p = o.indexOf(v)) && o.splice(p, 1) && d >= p && d--
                    },
                    _listeners: o
                }, h
            }(),
            Hr = function() {
                return !Za && en.wake()
            },
            Ie = {},
            Ey = /^[\d.\-M][\d.\-,\s]/,
            Ay = /["']/g,
            Ly = function(e) {
                for (var t = {}, n = e.substr(1, e.length - 3).split(":"), i = n[0], r = 1, s = n.length, o, l, c; r < s; r++) l = n[r], o = r !== s - 1 ? l.lastIndexOf(",") : l.length, c = l.substr(0, o), t[i] = isNaN(c) ? c.replace(Ay, "").trim() : +c, i = l.substr(o + 1).trim();
                return t
            },
            Ry = function(e) {
                var t = e.indexOf("(") + 1,
                    n = e.indexOf(")"),
                    i = e.indexOf("(", t);
                return e.substring(t, ~i && i < n ? e.indexOf(")", n + 1) : n)
            },
            Cy = function(e) {
                var t = (e + "").split("("),
                    n = Ie[t[0]];
                return n && t.length > 1 && n.config ? n.config.apply(null, ~e.indexOf("{") ? [Ly(t[1])] : Ry(e).split(",").map(vf)) : Ie._CE && Ey.test(e) ? Ie._CE("", e) : n
            },
            Uf = function(e) {
                return function(t) {
                    return 1 - e(1 - t)
                }
            },
            kf = function a(e, t) {
                for (var n = e._first, i; n;) n instanceof Nt ? a(n, t) : n.vars.yoyoEase && (!n._yoyo || !n._repeat) && n._yoyo !== t && (n.timeline ? a(n.timeline, t) : (i = n._ease, n._ease = n._yEase, n._yEase = i, n._yoyo = t)), n = n._next
            },
            Vr = function(e, t) {
                return e && (ht(e) ? e : Ie[e] || Cy(e)) || t
            },
            Pi = function(e, t, n, i) {
                n === void 0 && (n = function(l) {
                    return 1 - t(1 - l)
                }), i === void 0 && (i = function(l) {
                    return l < .5 ? t(l * 2) / 2 : 1 - t((1 - l) * 2) / 2
                });
                var r = {
                        easeIn: t,
                        easeOut: n,
                        easeInOut: i
                    },
                    s;
                return Wt(e, function(o) {
                    Ie[o] = Ht[o] = r, Ie[s = o.toLowerCase()] = n;
                    for (var l in r) Ie[s + (l === "easeIn" ? ".in" : l === "easeOut" ? ".out" : ".inOut")] = Ie[o + "." + l] = r[l]
                }), r
            },
            Gf = function(e) {
                return function(t) {
                    return t < .5 ? (1 - e(1 - t * 2)) / 2 : .5 + e((t - .5) * 2) / 2
                }
            },
            ql = function a(e, t, n) {
                var i = t >= 1 ? t : 1,
                    r = (n || (e ? .3 : .45)) / (t < 1 ? t : 1),
                    s = r / Ll * (Math.asin(1 / i) || 0),
                    o = function(u) {
                        return u === 1 ? 1 : i * Math.pow(2, -10 * u) * iy((u - s) * r) + 1
                    },
                    l = e === "out" ? o : e === "in" ? function(c) {
                        return 1 - o(1 - c)
                    } : Gf(o);
                return r = Ll / r, l.config = function(c, u) {
                    return a(e, c, u)
                }, l
            },
            Xl = function a(e, t) {
                t === void 0 && (t = 1.70158);
                var n = function(s) {
                        return s ? --s * s * ((t + 1) * s + t) + 1 : 0
                    },
                    i = e === "out" ? n : e === "in" ? function(r) {
                        return 1 - n(1 - r)
                    } : Gf(n);
                return i.config = function(r) {
                    return a(e, r)
                }, i
            };
        Wt("Linear,Quad,Cubic,Quart,Quint,Strong", function(a, e) {
                var t = e < 5 ? e + 1 : e;
                Pi(a + ",Power" + (t - 1), e ? function(n) {
                    return Math.pow(n, t)
                } : function(n) {
                    return n
                }, function(n) {
                    return 1 - Math.pow(1 - n, t)
                }, function(n) {
                    return n < .5 ? Math.pow(n * 2, t) / 2 : 1 - Math.pow((1 - n) * 2, t) / 2
                })
            }), Ie.Linear.easeNone = Ie.none = Ie.Linear.easeIn, Pi("Elastic", ql("in"), ql("out"), ql()),
            function(a, e) {
                var t = 1 / e,
                    n = 2 * t,
                    i = 2.5 * t,
                    r = function(o) {
                        return o < t ? a * o * o : o < n ? a * Math.pow(o - 1.5 / e, 2) + .75 : o < i ? a * (o -= 2.25 / e) * o + .9375 : a * Math.pow(o - 2.625 / e, 2) + .984375
                    };
                Pi("Bounce", function(s) {
                    return 1 - r(1 - s)
                }, r)
            }(7.5625, 2.75), Pi("Expo", function(a) {
                return a ? Math.pow(2, 10 * (a - 1)) : 0
            }), Pi("Circ", function(a) {
                return -(rf(1 - a * a) - 1)
            }), Pi("Sine", function(a) {
                return a === 1 ? 1 : -ny(a * ey) + 1
            }), Pi("Back", Xl("in"), Xl("out"), Xl()), Ie.SteppedEase = Ie.steps = Ht.SteppedEase = {
                config: function(e, t) {
                    e === void 0 && (e = 1);
                    var n = 1 / e,
                        i = e + (t ? 0 : 1),
                        r = t ? 1 : 0,
                        s = 1 - Ve;
                    return function(o) {
                        return ((i * Ls(0, s, o) | 0) + r) * n
                    }
                }
            }, zr.ease = Ie["quad.out"], Wt("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function(a) {
                return Ol += a + "," + a + "Params,"
            });
        var Hf = function(e, t) {
                this.id = ty++, e._gsap = this, this.target = e, this.harness = t, this.get = t ? t.get : gf, this.set = t ? t.getSetter : Zl
            },
            Ds = function() {
                function a(t) {
                    this.vars = t, this._delay = +t.delay || 0, (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) && (this._rDelay = t.repeatDelay || 0, this._yoyo = !!t.yoyo || !!t.yoyoEase), this._ts = 1, kr(this, +t.duration, 1, 1), this.data = t.data, Za || en.wake()
                }
                var e = a.prototype;
                return e.delay = function(n) {
                    return n || n === 0 ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + n - this._delay), this._delay = n, this) : this._delay
                }, e.duration = function(n) {
                    return arguments.length ? this.totalDuration(this._repeat > 0 ? n + (n + this._rDelay) * this._repeat : n) : this.totalDuration() && this._dur
                }, e.totalDuration = function(n) {
                    return arguments.length ? (this._dirty = 0, kr(this, this._repeat < 0 ? n : (n - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur
                }, e.totalTime = function(n, i) {
                    if (Hr(), !arguments.length) return this._tTime;
                    var r = this._dp;
                    if (r && r.smoothChildTiming && this._ts) {
                        for (bf(this, n), !r._dp || r.parent || wf(r, this); r && r.parent;) r.parent._time !== r._start + (r._ts >= 0 ? r._tTime / r._ts : (r.totalDuration() - r._tTime) / -r._ts) && r.totalTime(r._tTime, !0), r = r.parent;
                        !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && n < this._tDur || this._ts < 0 && n > 0 || !this._tDur && !n) && _n(this._dp, this, this._start - this._delay)
                    }
                    return (this._tTime !== n || !this._dur && !i || this._initted && Math.abs(this._zTime) === Ve || !n && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = n), _f(this, n, i)), this
                }, e.time = function(n, i) {
                    return arguments.length ? this.totalTime(Math.min(this.totalDuration(), n + Mf(this)) % (this._dur + this._rDelay) || (n ? this._dur : 0), i) : this._time
                }, e.totalProgress = function(n, i) {
                    return arguments.length ? this.totalTime(this.totalDuration() * n, i) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio
                }, e.progress = function(n, i) {
                    return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - n : n) + Mf(this), i) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio
                }, e.iteration = function(n, i) {
                    var r = this.duration() + this._rDelay;
                    return arguments.length ? this.totalTime(this._time + (n - 1) * r, i) : this._repeat ? Ur(this._tTime, r) + 1 : 1
                }, e.timeScale = function(n) {
                    if (!arguments.length) return this._rts === -Ve ? 0 : this._rts;
                    if (this._rts === n) return this;
                    var i = this.parent && this._ts ? ja(this.parent._time, this) : this._tTime;
                    return this._rts = +n || 0, this._ts = this._ps || n === -Ve ? 0 : this._rts, cy(this.totalTime(Ls(-this._delay, this._tDur, i), !0)), Ya(this), this
                }, e.paused = function(n) {
                    return arguments.length ? (this._ps !== n && (this._ps = n, n ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (Hr(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== Ve && (this._tTime -= Ve)))), this) : this._ps
                }, e.startTime = function(n) {
                    if (arguments.length) {
                        this._start = n;
                        var i = this.parent || this._dp;
                        return i && (i._sort || !this.parent) && _n(i, this, n - this._delay), this
                    }
                    return this._start
                }, e.endTime = function(n) {
                    return this._start + (zt(n) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1)
                }, e.rawTime = function(n) {
                    var i = this.parent || this._dp;
                    return i ? n && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? ja(i.rawTime(n), this) : this._tTime : this._tTime
                }, e.globalTime = function(n) {
                    for (var i = this, r = arguments.length ? n : i.rawTime(); i;) r = i._start + r / (i._ts || 1), i = i._dp;
                    return r
                }, e.repeat = function(n) {
                    return arguments.length ? (this._repeat = n === 1 / 0 ? -2 : n, Ef(this)) : this._repeat === -2 ? 1 / 0 : this._repeat
                }, e.repeatDelay = function(n) {
                    if (arguments.length) {
                        var i = this._time;
                        return this._rDelay = n, Ef(this), i ? this.time(i) : this
                    }
                    return this._rDelay
                }, e.yoyo = function(n) {
                    return arguments.length ? (this._yoyo = n, this) : this._yoyo
                }, e.seek = function(n, i) {
                    return this.totalTime($t(this, n), zt(i))
                }, e.restart = function(n, i) {
                    return this.play().totalTime(n ? -this._delay : 0, zt(i))
                }, e.play = function(n, i) {
                    return n != null && this.seek(n, i), this.reversed(!1).paused(!1)
                }, e.reverse = function(n, i) {
                    return n != null && this.seek(n || this.totalDuration(), i), this.reversed(!0).paused(!1)
                }, e.pause = function(n, i) {
                    return n != null && this.seek(n, i), this.paused(!0)
                }, e.resume = function() {
                    return this.paused(!1)
                }, e.reversed = function(n) {
                    return arguments.length ? (!!n !== this.reversed() && this.timeScale(-this._rts || (n ? -Ve : 0)), this) : this._rts < 0
                }, e.invalidate = function() {
                    return this._initted = this._act = 0, this._zTime = -Ve, this
                }, e.isActive = function() {
                    var n = this.parent || this._dp,
                        i = this._start,
                        r;
                    return !!(!n || this._ts && this._initted && n.isActive() && (r = n.rawTime(!0)) >= i && r < this.endTime(!0) - Ve)
                }, e.eventCallback = function(n, i, r) {
                    var s = this.vars;
                    return arguments.length > 1 ? (i ? (s[n] = i, r && (s[n + "Params"] = r), n === "onUpdate" && (this._onUpdate = i)) : delete s[n], this) : s[n]
                }, e.then = function(n) {
                    var i = this;
                    return new Promise(function(r) {
                        var s = ht(n) ? n : xf,
                            o = function() {
                                var c = i.then;
                                i.then = null, ht(s) && (s = s(i)) && (s.then || s === i) && (i.then = c), r(s), i.then = c
                            };
                        i._initted && i.totalProgress() === 1 && i._ts >= 0 || !i._tTime && i._ts < 0 ? o() : i._prom = o
                    })
                }, e.kill = function() {
                    Cs(this)
                }, a
            }();
        Jt(Ds.prototype, {
            _time: 0,
            _start: 0,
            _end: 0,
            _tTime: 0,
            _tDur: 0,
            _dirty: 0,
            _repeat: 0,
            _yoyo: !1,
            parent: null,
            _initted: !1,
            _rDelay: 0,
            _ts: 1,
            _dp: 0,
            ratio: 0,
            _zTime: -Ve,
            _prom: 0,
            _ps: !1,
            _rts: 1
        });
        var Nt = function(a) {
            nf(e, a);

            function e(n, i) {
                var r;
                return n === void 0 && (n = {}), r = a.call(this, n) || this, r.labels = {}, r.smoothChildTiming = !!n.smoothChildTiming, r.autoRemoveChildren = !!n.autoRemoveChildren, r._sort = zt(n.sortChildren), Ze && _n(n.parent || Ze, Cn(r), i), n.reversed && r.reverse(), n.paused && r.paused(!0), n.scrollTrigger && Sf(Cn(r), n.scrollTrigger), r
            }
            var t = e.prototype;
            return t.to = function(i, r, s) {
                return As(0, arguments, this), this
            }, t.from = function(i, r, s) {
                return As(1, arguments, this), this
            }, t.fromTo = function(i, r, s, o) {
                return As(2, arguments, this), this
            }, t.set = function(i, r, s) {
                return r.duration = 0, r.parent = this, Es(r).repeatDelay || (r.repeat = 0), r.immediateRender = !!r.immediateRender, new ft(i, r, $t(this, s), 1), this
            }, t.call = function(i, r, s) {
                return _n(this, ft.delayedCall(0, i, r), s)
            }, t.staggerTo = function(i, r, s, o, l, c, u) {
                return s.duration = r, s.stagger = s.stagger || o, s.onComplete = c, s.onCompleteParams = u, s.parent = this, new ft(i, s, $t(this, l)), this
            }, t.staggerFrom = function(i, r, s, o, l, c, u) {
                return s.runBackwards = 1, Es(s).immediateRender = zt(s.immediateRender), this.staggerTo(i, r, s, o, l, c, u)
            }, t.staggerFromTo = function(i, r, s, o, l, c, u, h) {
                return o.startAt = s, Es(o).immediateRender = zt(o.immediateRender), this.staggerTo(i, r, o, l, c, u, h)
            }, t.render = function(i, r, s) {
                var o = this._time,
                    l = this._dirty ? this.totalDuration() : this._tDur,
                    c = this._dur,
                    u = i <= 0 ? 0 : bt(i),
                    h = this._zTime < 0 != i < 0 && (this._initted || !c),
                    f, d, m, g, v, p, _, M, y, b, T, x;
                if (this !== Ze && u > l && i >= 0 && (u = l), u !== this._tTime || s || h) {
                    if (o !== this._time && c && (u += this._time - o, i += this._time - o), f = u, y = this._start, M = this._ts, p = !M, h && (c || (o = this._zTime), (i || !r) && (this._zTime = i)), this._repeat) {
                        if (T = this._yoyo, v = c + this._rDelay, this._repeat < -1 && i < 0) return this.totalTime(v * 100 + i, r, s);
                        if (f = bt(u % v), u === l ? (g = this._repeat, f = c) : (g = ~~(u / v), g && g === u / v && (f = c, g--), f > c && (f = c)), b = Ur(this._tTime, v), !o && this._tTime && b !== g && (b = g), T && g & 1 && (f = c - f, x = 1), g !== b && !this._lock) {
                            var R = T && b & 1,
                                P = R === (T && g & 1);
                            if (g < b && (R = !R), o = R ? 0 : c, this._lock = 1, this.render(o || (x ? 0 : bt(g * v)), r, !c)._lock = 0, this._tTime = u, !r && this.parent && Qt(this, "onRepeat"), this.vars.repeatRefresh && !x && (this.invalidate()._lock = 1), o && o !== this._time || p !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) return this;
                            if (c = this._dur, l = this._tDur, P && (this._lock = 2, o = R ? c : -1e-4, this.render(o, !0), this.vars.repeatRefresh && !x && this.invalidate()), this._lock = 0, !this._ts && !p) return this;
                            kf(this, x)
                        }
                    }
                    if (this._hasPause && !this._forcing && this._lock < 2 && (_ = dy(this, bt(o), bt(f)), _ && (u -= f - (f = _._start))), this._tTime = u, this._time = f, this._act = !M, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = i, o = 0), !o && f && !r && (Qt(this, "onStart"), this._tTime !== u)) return this;
                    if (f >= o && i >= 0)
                        for (d = this._first; d;) {
                            if (m = d._next, (d._act || f >= d._start) && d._ts && _ !== d) {
                                if (d.parent !== this) return this.render(i, r, s);
                                if (d.render(d._ts > 0 ? (f - d._start) * d._ts : (d._dirty ? d.totalDuration() : d._tDur) + (f - d._start) * d._ts, r, s), f !== this._time || !this._ts && !p) {
                                    _ = 0, m && (u += this._zTime = -Ve);
                                    break
                                }
                            }
                            d = m
                        } else {
                            d = this._last;
                            for (var I = i < 0 ? i : f; d;) {
                                if (m = d._prev, (d._act || I <= d._end) && d._ts && _ !== d) {
                                    if (d.parent !== this) return this.render(i, r, s);
                                    if (d.render(d._ts > 0 ? (I - d._start) * d._ts : (d._dirty ? d.totalDuration() : d._tDur) + (I - d._start) * d._ts, r, s), f !== this._time || !this._ts && !p) {
                                        _ = 0, m && (u += this._zTime = I ? -Ve : Ve);
                                        break
                                    }
                                }
                                d = m
                            }
                        }
                    if (_ && !r && (this.pause(), _.render(f >= o ? 0 : -Ve)._zTime = f >= o ? 1 : -1, this._ts)) return this._start = y, Ya(this), this.render(i, r, s);
                    this._onUpdate && !r && Qt(this, "onUpdate", !0), (u === l && l >= this.totalDuration() || !u && o) && (y === this._start || Math.abs(M) !== Math.abs(this._ts)) && (this._lock || ((i || !c) && (u === l && this._ts > 0 || !u && this._ts < 0) && si(this, 1), !r && !(i < 0 && !o) && (u || o || !l) && (Qt(this, u === l && i >= 0 ? "onComplete" : "onReverseComplete", !0), this._prom && !(u < l && this.timeScale() > 0) && this._prom())))
                }
                return this
            }, t.add = function(i, r) {
                var s = this;
                if (Pn(r) || (r = $t(this, r, i)), !(i instanceof Ds)) {
                    if (Gt(i)) return i.forEach(function(o) {
                        return s.add(o, r)
                    }), this;
                    if (gt(i)) return this.addLabel(i, r);
                    if (ht(i)) i = ft.delayedCall(0, i);
                    else return this
                }
                return this !== i ? _n(this, i, r) : this
            }, t.getChildren = function(i, r, s, o) {
                i === void 0 && (i = !0), r === void 0 && (r = !0), s === void 0 && (s = !0), o === void 0 && (o = -mn);
                for (var l = [], c = this._first; c;) c._start >= o && (c instanceof ft ? r && l.push(c) : (s && l.push(c), i && l.push.apply(l, c.getChildren(!0, r, s)))), c = c._next;
                return l
            }, t.getById = function(i) {
                for (var r = this.getChildren(1, 1, 1), s = r.length; s--;)
                    if (r[s].vars.id === i) return r[s]
            }, t.remove = function(i) {
                return gt(i) ? this.removeLabel(i) : ht(i) ? this.killTweensOf(i) : (Xa(this, i), i === this._recent && (this._recent = this._last), Ci(this))
            }, t.totalTime = function(i, r) {
                return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = bt(en.time - (this._ts > 0 ? i / this._ts : (this.totalDuration() - i) / -this._ts))), a.prototype.totalTime.call(this, i, r), this._forcing = 0, this) : this._tTime
            }, t.addLabel = function(i, r) {
                return this.labels[i] = $t(this, r), this
            }, t.removeLabel = function(i) {
                return delete this.labels[i], this
            }, t.addPause = function(i, r, s) {
                var o = ft.delayedCall(0, r || Br, s);
                return o.data = "isPause", this._hasPause = 1, _n(this, o, $t(this, i))
            }, t.removePause = function(i) {
                var r = this._first;
                for (i = $t(this, i); r;) r._start === i && r.data === "isPause" && si(r), r = r._next
            }, t.killTweensOf = function(i, r, s) {
                for (var o = this.getTweensOf(i, s), l = o.length; l--;) li !== o[l] && o[l].kill(i, r);
                return this
            }, t.getTweensOf = function(i, r) {
                for (var s = [], o = Kt(i), l = this._first, c = Pn(r), u; l;) l instanceof ft ? sy(l._targets, o) && (c ? (!li || l._initted && l._ts) && l.globalTime(0) <= r && l.globalTime(l.totalDuration()) > r : !r || l.isActive()) && s.push(l) : (u = l.getTweensOf(o, r)).length && s.push.apply(s, u), l = l._next;
                return s
            }, t.tweenTo = function(i, r) {
                r = r || {};
                var s = this,
                    o = $t(s, i),
                    l = r,
                    c = l.startAt,
                    u = l.onStart,
                    h = l.onStartParams,
                    f = l.immediateRender,
                    d, m = ft.to(s, Jt({
                        ease: r.ease || "none",
                        lazy: !1,
                        immediateRender: !1,
                        time: o,
                        overwrite: "auto",
                        duration: r.duration || Math.abs((o - (c && "time" in c ? c.time : s._time)) / s.timeScale()) || Ve,
                        onStart: function() {
                            if (s.pause(), !d) {
                                var v = r.duration || Math.abs((o - (c && "time" in c ? c.time : s._time)) / s.timeScale());
                                m._dur !== v && kr(m, v, 0, 1).render(m._time, !0, !0), d = 1
                            }
                            u && u.apply(m, h || [])
                        }
                    }, r));
                return f ? m.render(0) : m
            }, t.tweenFromTo = function(i, r, s) {
                return this.tweenTo(r, Jt({
                    startAt: {
                        time: $t(this, i)
                    }
                }, s))
            }, t.recent = function() {
                return this._recent
            }, t.nextLabel = function(i) {
                return i === void 0 && (i = this._time), Ff(this, $t(this, i))
            }, t.previousLabel = function(i) {
                return i === void 0 && (i = this._time), Ff(this, $t(this, i), 1)
            }, t.currentLabel = function(i) {
                return arguments.length ? this.seek(i, !0) : this.previousLabel(this._time + Ve)
            }, t.shiftChildren = function(i, r, s) {
                s === void 0 && (s = 0);
                for (var o = this._first, l = this.labels, c; o;) o._start >= s && (o._start += i, o._end += i), o = o._next;
                if (r)
                    for (c in l) l[c] >= s && (l[c] += i);
                return Ci(this)
            }, t.invalidate = function() {
                var i = this._first;
                for (this._lock = 0; i;) i.invalidate(), i = i._next;
                return a.prototype.invalidate.call(this)
            }, t.clear = function(i) {
                i === void 0 && (i = !0);
                for (var r = this._first, s; r;) s = r._next, this.remove(r), r = s;
                return this._dp && (this._time = this._tTime = this._pTime = 0), i && (this.labels = {}), Ci(this)
            }, t.totalDuration = function(i) {
                var r = 0,
                    s = this,
                    o = s._last,
                    l = mn,
                    c, u, h;
                if (arguments.length) return s.timeScale((s._repeat < 0 ? s.duration() : s.totalDuration()) / (s.reversed() ? -i : i));
                if (s._dirty) {
                    for (h = s.parent; o;) c = o._prev, o._dirty && o.totalDuration(), u = o._start, u > l && s._sort && o._ts && !s._lock ? (s._lock = 1, _n(s, o, u - o._delay, 1)._lock = 0) : l = u, u < 0 && o._ts && (r -= u, (!h && !s._dp || h && h.smoothChildTiming) && (s._start += u / s._ts, s._time -= u, s._tTime -= u), s.shiftChildren(-u, !1, -1 / 0), l = 0), o._end > r && o._ts && (r = o._end), o = c;
                    kr(s, s === Ze && s._time > r ? s._time : r, 1, 1), s._dirty = 0
                }
                return s._tDur
            }, e.updateRoot = function(i) {
                if (Ze._ts && (_f(Ze, ja(i, Ze)), pf = en.frame), en.frame >= mf) {
                    mf += Ft.autoSleep || 120;
                    var r = Ze._first;
                    if ((!r || !r._ts) && Ft.autoSleep && en._listeners.length < 2) {
                        for (; r && !r._ts;) r = r._next;
                        r || en.sleep()
                    }
                }
            }, e
        }(Ds);
        Jt(Nt.prototype, {
            _lock: 0,
            _hasPause: 0,
            _forcing: 0
        });
        var Py = function(e, t, n, i, r, s, o) {
                var l = new Bt(this._pt, e, t, 0, 1, jf, null, r),
                    c = 0,
                    u = 0,
                    h, f, d, m, g, v, p, _;
                for (l.b = n, l.e = i, n += "", i += "", (p = ~i.indexOf("random(")) && (i = Rs(i)), s && (_ = [n, i], s(_, e, t), n = _[0], i = _[1]), f = n.match(Pl) || []; h = Pl.exec(i);) m = h[0], g = i.substring(c, h.index), d ? d = (d + 1) % 5 : g.substr(-5) === "rgba(" && (d = 1), m !== f[u++] && (v = parseFloat(f[u - 1]) || 0, l._pt = {
                    _next: l._pt,
                    p: g || u === 1 ? g : ",",
                    s: v,
                    c: m.charAt(1) === "=" ? parseFloat(m.substr(2)) * (m.charAt(0) === "-" ? -1 : 1) : parseFloat(m) - v,
                    m: d && d < 4 ? Math.round : 0
                }, c = Pl.lastIndex);
                return l.c = c < i.length ? i.substring(c, i.length) : "", l.fp = o, (cf.test(i) || p) && (l.e = 0), this._pt = l, l
            },
            jl = function(e, t, n, i, r, s, o, l, c) {
                ht(i) && (i = i(r || 0, e, s));
                var u = e[t],
                    h = n !== "get" ? n : ht(u) ? c ? e[t.indexOf("set") || !ht(e["get" + t.substr(3)]) ? t : "get" + t.substr(3)](c) : e[t]() : u,
                    f = ht(u) ? c ? Ny : qf : Yl,
                    d;
                if (gt(i) && (~i.indexOf("random(") && (i = Rs(i)), i.charAt(1) === "=" && (d = parseFloat(h) + parseFloat(i.substr(2)) * (i.charAt(0) === "-" ? -1 : 1) + (qt(h) || 0), (d || d === 0) && (i = d))), h !== i) return !isNaN(h * i) && i !== "" ? (d = new Bt(this._pt, e, t, +h || 0, i - (h || 0), typeof u == "boolean" ? Oy : Xf, 0, f), c && (d.fp = c), o && d.modifier(o, this, e), this._pt = d) : (!u && !(t in e) && Fl(t, i), Py.call(this, e, t, h, i, f, l || Ft.stringFilter, c))
            },
            Dy = function(e, t, n, i, r) {
                if (ht(e) && (e = Is(e, r, t, n, i)), !Dn(e) || e.style && e.nodeType || Gt(e) || of (e)) return gt(e) ? Is(e, r, t, n, i) : e;
                var s = {},
                    o;
                for (o in e) s[o] = Is(e[o], r, t, n, i);
                return s
            },
            Vf = function(e, t, n, i, r, s) {
                var o, l, c, u;
                if (Vt[e] && (o = new Vt[e]).init(r, o.rawVars ? t[e] : Dy(t[e], i, r, s, n), n, i, s) !== !1 && (n._pt = l = new Bt(n._pt, r, e, 0, 1, o.render, o, 0, o.priority), n !== Gr))
                    for (c = n._ptLookup[n._targets.indexOf(r)], u = o._props.length; u--;) c[o._props[u]] = l;
                return o
            },
            li, Iy = function a(e, t) {
                var n = e.vars,
                    i = n.ease,
                    r = n.startAt,
                    s = n.immediateRender,
                    o = n.lazy,
                    l = n.onUpdate,
                    c = n.onUpdateParams,
                    u = n.callbackScope,
                    h = n.runBackwards,
                    f = n.yoyoEase,
                    d = n.keyframes,
                    m = n.autoRevert,
                    g = e._dur,
                    v = e._startAt,
                    p = e._targets,
                    _ = e.parent,
                    M = _ && _.data === "nested" ? _.parent._targets : p,
                    y = e._overwrite === "auto" && !Al,
                    b = e.timeline,
                    T, x, R, P, I, L, Y, D, F, N, z, k, J;
                if (b && (!d || !i) && (i = "none"), e._ease = Vr(i, zr.ease), e._yEase = f ? Uf(Vr(f === !0 ? i : f, zr.ease)) : 0, f && e._yoyo && !e._repeat && (f = e._yEase, e._yEase = e._ease, e._ease = f), e._from = !b && !!n.runBackwards, !b) {
                    if (D = p[0] ? Ri(p[0]).harness : 0, k = D && n[D.prop], T = kl(n, zl), v && v.render(-1, !0).kill(), r)
                        if (si(e._startAt = ft.set(p, Jt({
                                data: "isStart",
                                overwrite: !1,
                                parent: _,
                                immediateRender: !0,
                                lazy: zt(o),
                                startAt: null,
                                delay: 0,
                                onUpdate: l,
                                onUpdateParams: c,
                                callbackScope: u,
                                stagger: 0
                            }, r))), t < 0 && !s && !m && e._startAt.render(-1, !0), s) {
                            if (t > 0 && !m && (e._startAt = 0), g && t <= 0) {
                                t && (e._zTime = t);
                                return
                            }
                        } else m === !1 && (e._startAt = 0);
                    else if (h && g) {
                        if (v) !m && (e._startAt = 0);
                        else if (t && (s = !1), R = Jt({
                                overwrite: !1,
                                data: "isFromStart",
                                lazy: s && zt(o),
                                immediateRender: s,
                                stagger: 0,
                                parent: _
                            }, T), k && (R[D.prop] = k), si(e._startAt = ft.set(p, R)), t < 0 && e._startAt.render(-1, !0), !s) a(e._startAt, Ve);
                        else if (!t) return
                    }
                    for (e._pt = 0, o = g && zt(o) || o && !g, x = 0; x < p.length; x++) {
                        if (I = p[x], Y = I._gsap || Ul(p)[x]._gsap, e._ptLookup[x] = N = {}, Nl[Y.id] && ri.length && qa(), z = M === p ? x : M.indexOf(I), D && (F = new D).init(I, k || T, e, z, M) !== !1 && (e._pt = P = new Bt(e._pt, I, F.name, 0, 1, F.render, F, 0, F.priority), F._props.forEach(function(oe) {
                                N[oe] = P
                            }), F.priority && (L = 1)), !D || k)
                            for (R in T) Vt[R] && (F = Vf(R, T, e, z, I, M)) ? F.priority && (L = 1) : N[R] = P = jl.call(e, I, R, "get", T[R], z, M, 0, n.stringFilter);
                        e._op && e._op[x] && e.kill(I, e._op[x]), y && e._pt && (li = e, Ze.killTweensOf(I, N, e.globalTime(t)), J = !e.parent, li = 0), e._pt && o && (Nl[Y.id] = 1)
                    }
                    L && Yf(e), e._onInit && e._onInit(e)
                }
                e._onUpdate = l, e._initted = (!e._op || e._pt) && !J
            },
            Fy = function(e, t) {
                var n = e[0] ? Ri(e[0]).harness : 0,
                    i = n && n.aliases,
                    r, s, o, l;
                if (!i) return t;
                r = Or({}, t);
                for (s in i)
                    if (s in r)
                        for (l = i[s].split(","), o = l.length; o--;) r[l[o]] = r[s];
                return r
            },
            Is = function(e, t, n, i, r) {
                return ht(e) ? e.call(t, n, i, r) : gt(e) && ~e.indexOf("random(") ? Rs(e) : e
            },
            Wf = Ol + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase",
            zy = (Wf + ",id,stagger,delay,duration,paused,scrollTrigger").split(","),
            ft = function(a) {
                nf(e, a);

                function e(n, i, r, s) {
                    var o;
                    typeof i == "number" && (r.duration = i, i = r, r = null), o = a.call(this, s ? i : Es(i)) || this;
                    var l = o.vars,
                        c = l.duration,
                        u = l.delay,
                        h = l.immediateRender,
                        f = l.stagger,
                        d = l.overwrite,
                        m = l.keyframes,
                        g = l.defaults,
                        v = l.scrollTrigger,
                        p = l.yoyoEase,
                        _ = i.parent || Ze,
                        M = (Gt(n) || of (n) ? Pn(n[0]) : "length" in i) ? [n] : Kt(n),
                        y, b, T, x, R, P, I, L;
                    if (o._targets = M.length ? Ul(M) : Va("GSAP target " + n + " not found. https://greensock.com", !Ft.nullTargetWarn) || [], o._ptLookup = [], o._overwrite = d, m || f || af(c) || af(u)) {
                        if (i = o.vars, y = o.timeline = new Nt({
                                data: "nested",
                                defaults: g || {}
                            }), y.kill(), y.parent = y._dp = Cn(o), y._start = 0, m) Es(Jt(y.vars.defaults, {
                            ease: "none"
                        })), f ? M.forEach(function(Y, D) {
                            return m.forEach(function(F, N) {
                                return y.to(Y, F, N ? ">" : D * f)
                            })
                        }) : m.forEach(function(Y) {
                            return y.to(M, Y, ">")
                        });
                        else {
                            if (x = M.length, I = f ? Rf(f) : Br, Dn(f))
                                for (R in f) ~Wf.indexOf(R) && (L || (L = {}), L[R] = f[R]);
                            for (b = 0; b < x; b++) {
                                T = {};
                                for (R in i) zy.indexOf(R) < 0 && (T[R] = i[R]);
                                T.stagger = 0, p && (T.yoyoEase = p), L && Or(T, L), P = M[b], T.duration = +Is(c, Cn(o), b, P, M), T.delay = (+Is(u, Cn(o), b, P, M) || 0) - o._delay, !f && x === 1 && T.delay && (o._delay = u = T.delay, o._start += u, T.delay = 0), y.to(P, T, I(b, P, M))
                            }
                            y.duration() ? c = u = 0 : o.timeline = 0
                        }
                        c || o.duration(c = y.duration())
                    } else o.timeline = 0;
                    return d === !0 && !Al && (li = Cn(o), Ze.killTweensOf(M), li = 0), _n(_, Cn(o), r), i.reversed && o.reverse(), i.paused && o.paused(!0), (h || !c && !m && o._start === bt(_._time) && zt(h) && uy(Cn(o)) && _.data !== "nested") && (o._tTime = -Ve, o.render(Math.max(0, -u))), v && Sf(Cn(o), v), o
                }
                var t = e.prototype;
                return t.render = function(i, r, s) {
                    var o = this._time,
                        l = this._tDur,
                        c = this._dur,
                        u = i > l - Ve && i >= 0 ? l : i < Ve ? 0 : i,
                        h, f, d, m, g, v, p, _, M;
                    if (!c) fy(this, i, r, s);
                    else if (u !== this._tTime || !i || s || !this._initted && this._tTime || this._startAt && this._zTime < 0 != i < 0) {
                        if (h = u, _ = this.timeline, this._repeat) {
                            if (m = c + this._rDelay, this._repeat < -1 && i < 0) return this.totalTime(m * 100 + i, r, s);
                            if (h = bt(u % m), u === l ? (d = this._repeat, h = c) : (d = ~~(u / m), d && d === u / m && (h = c, d--), h > c && (h = c)), v = this._yoyo && d & 1, v && (M = this._yEase, h = c - h), g = Ur(this._tTime, m), h === o && !s && this._initted) return this;
                            d !== g && (_ && this._yEase && kf(_, v), this.vars.repeatRefresh && !v && !this._lock && (this._lock = s = 1, this.render(bt(m * d), !0).invalidate()._lock = 0))
                        }
                        if (!this._initted) {
                            if (Tf(this, i < 0 ? i : h, s, r)) return this._tTime = 0, this;
                            if (c !== this._dur) return this.render(i, r, s)
                        }
                        if (this._tTime = u, this._time = h, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = p = (M || this._ease)(h / c), this._from && (this.ratio = p = 1 - p), h && !o && !r && (Qt(this, "onStart"), this._tTime !== u)) return this;
                        for (f = this._pt; f;) f.r(p, f.d), f = f._next;
                        _ && _.render(i < 0 ? i : !h && v ? -Ve : _._dur * p, r, s) || this._startAt && (this._zTime = i), this._onUpdate && !r && (i < 0 && this._startAt && this._startAt.render(i, !0, s), Qt(this, "onUpdate")), this._repeat && d !== g && this.vars.onRepeat && !r && this.parent && Qt(this, "onRepeat"), (u === this._tDur || !u) && this._tTime === u && (i < 0 && this._startAt && !this._onUpdate && this._startAt.render(i, !0, !0), (i || !c) && (u === this._tDur && this._ts > 0 || !u && this._ts < 0) && si(this, 1), !r && !(i < 0 && !o) && (u || o) && (Qt(this, u === l ? "onComplete" : "onReverseComplete", !0), this._prom && !(u < l && this.timeScale() > 0) && this._prom()))
                    }
                    return this
                }, t.targets = function() {
                    return this._targets
                }, t.invalidate = function() {
                    return this._pt = this._op = this._startAt = this._onUpdate = this._lazy = this.ratio = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(), a.prototype.invalidate.call(this)
                }, t.kill = function(i, r) {
                    if (r === void 0 && (r = "all"), !i && (!r || r === "all")) return this._lazy = this._pt = 0, this.parent ? Cs(this) : this;
                    if (this.timeline) {
                        var s = this.timeline.totalDuration();
                        return this.timeline.killTweensOf(i, r, li && li.vars.overwrite !== !0)._first || Cs(this), this.parent && s !== this.timeline.totalDuration() && kr(this, this._dur * this.timeline._tDur / s, 0, 1), this
                    }
                    var o = this._targets,
                        l = i ? Kt(i) : o,
                        c = this._ptLookup,
                        u = this._pt,
                        h, f, d, m, g, v, p;
                    if ((!r || r === "all") && oy(o, l)) return r === "all" && (this._pt = 0), Cs(this);
                    for (h = this._op = this._op || [], r !== "all" && (gt(r) && (g = {}, Wt(r, function(_) {
                            return g[_] = 1
                        }), r = g), r = Fy(o, r)), p = o.length; p--;)
                        if (~l.indexOf(o[p])) {
                            f = c[p], r === "all" ? (h[p] = r, m = f, d = {}) : (d = h[p] = h[p] || {}, m = r);
                            for (g in m) v = f && f[g], v && ((!("kill" in v.d) || v.d.kill(g) === !0) && Xa(this, v, "_pt"), delete f[g]), d !== "all" && (d[g] = 1)
                        }
                    return this._initted && !this._pt && u && Cs(this), this
                }, e.to = function(i, r) {
                    return new e(i, r, arguments[2])
                }, e.from = function(i, r) {
                    return As(1, arguments)
                }, e.delayedCall = function(i, r, s, o) {
                    return new e(r, 0, {
                        immediateRender: !1,
                        lazy: !1,
                        overwrite: !1,
                        delay: i,
                        onComplete: r,
                        onReverseComplete: r,
                        onCompleteParams: s,
                        onReverseCompleteParams: s,
                        callbackScope: o
                    })
                }, e.fromTo = function(i, r, s) {
                    return As(2, arguments)
                }, e.set = function(i, r) {
                    return r.duration = 0, r.repeatDelay || (r.repeat = 0), new e(i, r)
                }, e.killTweensOf = function(i, r, s) {
                    return Ze.killTweensOf(i, r, s)
                }, e
            }(Ds);
        Jt(ft.prototype, {
            _targets: [],
            _lazy: 0,
            _startAt: 0,
            _op: 0,
            _onInit: 0
        }), Wt("staggerTo,staggerFrom,staggerFromTo", function(a) {
            ft[a] = function() {
                var e = new Nt,
                    t = Hl.call(arguments, 0);
                return t.splice(a === "staggerFromTo" ? 5 : 4, 0, 0), e[a].apply(e, t)
            }
        });
        var Yl = function(e, t, n) {
                return e[t] = n
            },
            qf = function(e, t, n) {
                return e[t](n)
            },
            Ny = function(e, t, n, i) {
                return e[t](i.fp, n)
            },
            By = function(e, t, n) {
                return e.setAttribute(t, n)
            },
            Zl = function(e, t) {
                return ht(e[t]) ? qf : Rl(e[t]) && e.setAttribute ? By : Yl
            },
            Xf = function(e, t) {
                return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e6) / 1e6, t)
            },
            Oy = function(e, t) {
                return t.set(t.t, t.p, !!(t.s + t.c * e), t)
            },
            jf = function(e, t) {
                var n = t._pt,
                    i = "";
                if (!e && t.b) i = t.b;
                else if (e === 1 && t.e) i = t.e;
                else {
                    for (; n;) i = n.p + (n.m ? n.m(n.s + n.c * e) : Math.round((n.s + n.c * e) * 1e4) / 1e4) + i, n = n._next;
                    i += t.c
                }
                t.set(t.t, t.p, i, t)
            },
            Jl = function(e, t) {
                for (var n = t._pt; n;) n.r(e, n.d), n = n._next
            },
            Uy = function(e, t, n, i) {
                for (var r = this._pt, s; r;) s = r._next, r.p === i && r.modifier(e, t, n), r = s
            },
            ky = function(e) {
                for (var t = this._pt, n, i; t;) i = t._next, t.p === e && !t.op || t.op === e ? Xa(this, t, "_pt") : t.dep || (n = 1), t = i;
                return !n
            },
            Gy = function(e, t, n, i) {
                i.mSet(e, t, i.m.call(i.tween, n, i.mt), i)
            },
            Yf = function(e) {
                for (var t = e._pt, n, i, r, s; t;) {
                    for (n = t._next, i = r; i && i.pr > t.pr;) i = i._next;
                    (t._prev = i ? i._prev : s) ? t._prev._next = t: r = t, (t._next = i) ? i._prev = t : s = t, t = n
                }
                e._pt = r
            },
            Bt = function() {
                function a(t, n, i, r, s, o, l, c, u) {
                    this.t = n, this.s = r, this.c = s, this.p = i, this.r = o || Xf, this.d = l || this, this.set = c || Yl, this.pr = u || 0, this._next = t, t && (t._prev = this)
                }
                var e = a.prototype;
                return e.modifier = function(n, i, r) {
                    this.mSet = this.mSet || this.set, this.set = Gy, this.m = n, this.mt = r, this.tween = i
                }, a
            }();
        Wt(Ol + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function(a) {
            return zl[a] = 1
        }), Ht.TweenMax = Ht.TweenLite = ft, Ht.TimelineLite = Ht.TimelineMax = Nt, Ze = new Nt({
            sortChildren: !1,
            defaults: zr,
            autoRemoveChildren: !0,
            id: "root",
            smoothChildTiming: !0
        }), Ft.stringFilter = Of;
        var Ja = {
            registerPlugin: function() {
                for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
                t.forEach(function(i) {
                    return Sy(i)
                })
            },
            timeline: function(e) {
                return new Nt(e)
            },
            getTweensOf: function(e, t) {
                return Ze.getTweensOf(e, t)
            },
            getProperty: function(e, t, n, i) {
                gt(e) && (e = Kt(e)[0]);
                var r = Ri(e || {}).get,
                    s = n ? xf : vf;
                return n === "native" && (n = ""), e && (t ? s((Vt[t] && Vt[t].get || r)(e, t, n, i)) : function(o, l, c) {
                    return s((Vt[o] && Vt[o].get || r)(e, o, l, c))
                })
            },
            quickSetter: function(e, t, n) {
                if (e = Kt(e), e.length > 1) {
                    var i = e.map(function(u) {
                            return vn.quickSetter(u, t, n)
                        }),
                        r = i.length;
                    return function(u) {
                        for (var h = r; h--;) i[h](u)
                    }
                }
                e = e[0] || {};
                var s = Vt[t],
                    o = Ri(e),
                    l = o.harness && (o.harness.aliases || {})[t] || t,
                    c = s ? function(u) {
                        var h = new s;
                        Gr._pt = 0, h.init(e, n ? u + n : u, Gr, 0, [e]), h.render(1, h), Gr._pt && Jl(1, Gr)
                    } : o.set(e, l);
                return s ? c : function(u) {
                    return c(e, l, n ? u + n : u, o, 1)
                }
            },
            isTweening: function(e) {
                return Ze.getTweensOf(e, !0).length > 0
            },
            defaults: function(e) {
                return e && e.ease && (e.ease = Vr(e.ease, zr.ease)), yf(zr, e || {})
            },
            config: function(e) {
                return yf(Ft, e || {})
            },
            registerEffect: function(e) {
                var t = e.name,
                    n = e.effect,
                    i = e.plugins,
                    r = e.defaults,
                    s = e.extendTimeline;
                (i || "").split(",").forEach(function(o) {
                    return o && !Vt[o] && !Ht[o] && Va(t + " effect requires " + o + " plugin.")
                }), Bl[t] = function(o, l, c) {
                    return n(Kt(o), Jt(l || {}, r), c)
                }, s && (Nt.prototype[t] = function(o, l, c) {
                    return this.add(Bl[t](o, Dn(l) ? l : (c = l) && {}, this), c)
                })
            },
            registerEase: function(e, t) {
                Ie[e] = Vr(t)
            },
            parseEase: function(e, t) {
                return arguments.length ? Vr(e, t) : Ie
            },
            getById: function(e) {
                return Ze.getById(e)
            },
            exportRoot: function(e, t) {
                e === void 0 && (e = {});
                var n = new Nt(e),
                    i, r;
                for (n.smoothChildTiming = zt(e.smoothChildTiming), Ze.remove(n), n._dp = 0, n._time = n._tTime = Ze._time, i = Ze._first; i;) r = i._next, (t || !(!i._dur && i instanceof ft && i.vars.onComplete === i._targets[0])) && _n(n, i, i._start - i._delay), i = r;
                return _n(Ze, n, 0), n
            },
            utils: {
                wrap: My,
                wrapYoyo: by,
                distribute: Rf,
                random: Pf,
                snap: Cf,
                normalize: yy,
                getUnit: qt,
                clamp: my,
                splitColor: zf,
                toArray: Kt,
                selector: _y,
                mapRange: If,
                pipe: vy,
                unitize: xy,
                interpolate: wy,
                shuffle: Lf
            },
            install: ff,
            effects: Bl,
            ticker: en,
            updateRoot: Nt.updateRoot,
            plugins: Vt,
            globalTimeline: Ze,
            core: {
                PropTween: Bt,
                globals: df,
                Tween: ft,
                Timeline: Nt,
                Animation: Ds,
                getCache: Ri,
                _removeLinkedListItem: Xa,
                suppressOverwrites: function(e) {
                    return Al = e
                }
            }
        };
        Wt("to,from,fromTo,delayedCall,set,killTweensOf", function(a) {
            return Ja[a] = ft[a]
        }), en.add(Nt.updateRoot), Gr = Ja.to({}, {
            duration: 0
        });
        var Hy = function(e, t) {
                for (var n = e._pt; n && n.p !== t && n.op !== t && n.fp !== t;) n = n._next;
                return n
            },
            Vy = function(e, t) {
                var n = e._targets,
                    i, r, s;
                for (i in t)
                    for (r = n.length; r--;) s = e._ptLookup[r][i], s && (s = s.d) && (s._pt && (s = Hy(s, i)), s && s.modifier && s.modifier(t[i], e, n[r], i))
            },
            $l = function(e, t) {
                return {
                    name: e,
                    rawVars: 1,
                    init: function(i, r, s) {
                        s._onInit = function(o) {
                            var l, c;
                            if (gt(r) && (l = {}, Wt(r, function(u) {
                                    return l[u] = 1
                                }), r = l), t) {
                                l = {};
                                for (c in r) l[c] = t(r[c]);
                                r = l
                            }
                            Vy(o, r)
                        }
                    }
                }
            },
            vn = Ja.registerPlugin({
                name: "attr",
                init: function(e, t, n, i, r) {
                    var s, o;
                    for (s in t) o = this.add(e, "setAttribute", (e.getAttribute(s) || 0) + "", t[s], i, r, 0, 0, s), o && (o.op = s), this._props.push(s)
                }
            }, {
                name: "endArray",
                init: function(e, t) {
                    for (var n = t.length; n--;) this.add(e, n, e[n] || 0, t[n])
                }
            }, $l("roundProps", Vl), $l("modifiers"), $l("snap", Cf)) || Ja;
        ft.version = Nt.version = vn.version = "3.8.0", hf = 1, sf() && Hr(), Ie.Power0, Ie.Power1, Ie.Power2, Ie.Power3, Ie.Power4, Ie.Linear, Ie.Quad, Ie.Cubic, Ie.Quart, Ie.Quint, Ie.Strong, Ie.Elastic, Ie.Back, Ie.SteppedEase, Ie.Bounce, Ie.Sine, Ie.Expo, Ie.Circ;
        /*!
         * CSSPlugin 3.8.0
         * https://greensock.com
         *
         * Copyright 2008-2021, GreenSock. All rights reserved.
         * Subject to the terms at https://greensock.com/standard-license or for
         * Club GreenSock members, the agreement issued with that membership.
         * @author: Jack Doyle, jack@greensock.com
         */
        var Zf, ci, Wr, Kl, Di, Jf, Wy = function() {
                return typeof window != "undefined"
            },
            ui = {},
            Ii = 180 / Math.PI,
            qr = Math.PI / 180,
            Xr = Math.atan2,
            $f = 1e8,
            Kf = /([A-Z])/g,
            qy = /(?:left|right|width|margin|padding|x)/i,
            Xy = /[\s,\(]\S/,
            hi = {
                autoAlpha: "opacity,visibility",
                scale: "scaleX,scaleY",
                alpha: "opacity"
            },
            Qf = function(e, t) {
                return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u, t)
            },
            jy = function(e, t) {
                return t.set(t.t, t.p, e === 1 ? t.e : Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u, t)
            },
            Yy = function(e, t) {
                return t.set(t.t, t.p, e ? Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u : t.b, t)
            },
            Zy = function(e, t) {
                var n = t.s + t.c * e;
                t.set(t.t, t.p, ~~(n + (n < 0 ? -.5 : .5)) + t.u, t)
            },
            ed = function(e, t) {
                return t.set(t.t, t.p, e ? t.e : t.b, t)
            },
            td = function(e, t) {
                return t.set(t.t, t.p, e !== 1 ? t.b : t.e, t)
            },
            Jy = function(e, t, n) {
                return e.style[t] = n
            },
            $y = function(e, t, n) {
                return e.style.setProperty(t, n)
            },
            Ky = function(e, t, n) {
                return e._gsap[t] = n
            },
            Qy = function(e, t, n) {
                return e._gsap.scaleX = e._gsap.scaleY = n
            },
            e1 = function(e, t, n, i, r) {
                var s = e._gsap;
                s.scaleX = s.scaleY = n, s.renderTransform(r, s)
            },
            t1 = function(e, t, n, i, r) {
                var s = e._gsap;
                s[t] = n, s.renderTransform(r, s)
            },
            _t = "transform",
            fi = _t + "Origin",
            nd, Ql = function(e, t) {
                var n = ci.createElementNS ? ci.createElementNS((t || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), e) : ci.createElement(e);
                return n.style ? n : ci.createElement(e)
            },
            In = function a(e, t, n) {
                var i = getComputedStyle(e);
                return i[t] || i.getPropertyValue(t.replace(Kf, "-$1").toLowerCase()) || i.getPropertyValue(t) || !n && a(e, jr(t) || t, 1) || ""
            },
            id = "O,Moz,ms,Ms,Webkit".split(","),
            jr = function(e, t, n) {
                var i = t || Di,
                    r = i.style,
                    s = 5;
                if (e in r && !n) return e;
                for (e = e.charAt(0).toUpperCase() + e.substr(1); s-- && !(id[s] + e in r););
                return s < 0 ? null : (s === 3 ? "ms" : s >= 0 ? id[s] : "") + e
            },
            ec = function() {
                Wy() && window.document && (Zf = window, ci = Zf.document, Wr = ci.documentElement, Di = Ql("div") || {
                    style: {}
                }, Ql("div"), _t = jr(_t), fi = _t + "Origin", Di.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", nd = !!jr("perspective"), Kl = 1)
            },
            tc = function a(e) {
                var t = Ql("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
                    n = this.parentNode,
                    i = this.nextSibling,
                    r = this.style.cssText,
                    s;
                if (Wr.appendChild(t), t.appendChild(this), this.style.display = "block", e) try {
                    s = this.getBBox(), this._gsapBBox = this.getBBox, this.getBBox = a
                } catch {} else this._gsapBBox && (s = this._gsapBBox());
                return n && (i ? n.insertBefore(this, i) : n.appendChild(this)), Wr.removeChild(t), this.style.cssText = r, s
            },
            rd = function(e, t) {
                for (var n = t.length; n--;)
                    if (e.hasAttribute(t[n])) return e.getAttribute(t[n])
            },
            sd = function(e) {
                var t;
                try {
                    t = e.getBBox()
                } catch {
                    t = tc.call(e, !0)
                }
                return t && (t.width || t.height) || e.getBBox === tc || (t = tc.call(e, !0)), t && !t.width && !t.x && !t.y ? {
                    x: +rd(e, ["x", "cx", "x1"]) || 0,
                    y: +rd(e, ["y", "cy", "y1"]) || 0,
                    width: 0,
                    height: 0
                } : t
            },
            ad = function(e) {
                return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && sd(e))
            },
            Fs = function(e, t) {
                if (t) {
                    var n = e.style;
                    t in ui && t !== fi && (t = _t), n.removeProperty ? ((t.substr(0, 2) === "ms" || t.substr(0, 6) === "webkit") && (t = "-" + t), n.removeProperty(t.replace(Kf, "-$1").toLowerCase())) : n.removeAttribute(t)
                }
            },
            di = function(e, t, n, i, r, s) {
                var o = new Bt(e._pt, t, n, 0, 1, s ? td : ed);
                return e._pt = o, o.b = i, o.e = r, e._props.push(n), o
            },
            od = {
                deg: 1,
                rad: 1,
                turn: 1
            },
            pi = function a(e, t, n, i) {
                var r = parseFloat(n) || 0,
                    s = (n + "").trim().substr((r + "").length) || "px",
                    o = Di.style,
                    l = qy.test(t),
                    c = e.tagName.toLowerCase() === "svg",
                    u = (c ? "client" : "offset") + (l ? "Width" : "Height"),
                    h = 100,
                    f = i === "px",
                    d = i === "%",
                    m, g, v, p;
                return i === s || !r || od[i] || od[s] ? r : (s !== "px" && !f && (r = a(e, t, n, "px")), p = e.getCTM && ad(e), (d || s === "%") && (ui[t] || ~t.indexOf("adius")) ? (m = p ? e.getBBox()[l ? "width" : "height"] : e[u], rt(d ? r / m * h : r / 100 * m)) : (o[l ? "width" : "height"] = h + (f ? s : i), g = ~t.indexOf("adius") || i === "em" && e.appendChild && !c ? e : e.parentNode, p && (g = (e.ownerSVGElement || {}).parentNode), (!g || g === ci || !g.appendChild) && (g = ci.body), v = g._gsap, v && d && v.width && l && v.time === en.time ? rt(r / v.width * h) : ((d || s === "%") && (o.position = In(e, "position")), g === e && (o.position = "static"), g.appendChild(Di), m = Di[u], g.removeChild(Di), o.position = "absolute", l && d && (v = Ri(g), v.time = en.time, v.width = g[u]), rt(f ? m * r / h : m && r ? h / m * r : 0))))
            },
            Yr = function(e, t, n, i) {
                var r;
                return Kl || ec(), t in hi && t !== "transform" && (t = hi[t], ~t.indexOf(",") && (t = t.split(",")[0])), ui[t] && t !== "transform" ? (r = Ns(e, i), r = t !== "transformOrigin" ? r[t] : r.svg ? r.origin : Ka(In(e, fi)) + " " + r.zOrigin + "px") : (r = e.style[t], (!r || r === "auto" || i || ~(r + "").indexOf("calc(")) && (r = $a[t] && $a[t](e, t, n) || In(e, t) || gf(e, t) || (t === "opacity" ? 1 : 0))), n && !~(r + "").trim().indexOf(" ") ? pi(e, t, r, n) + n : r
            },
            n1 = function(e, t, n, i) {
                if (!n || n === "none") {
                    var r = jr(t, e, 1),
                        s = r && In(e, r, 1);
                    s && s !== n ? (t = r, n = s) : t === "borderColor" && (n = In(e, "borderTopColor"))
                }
                var o = new Bt(this._pt, e.style, t, 0, 1, jf),
                    l = 0,
                    c = 0,
                    u, h, f, d, m, g, v, p, _, M, y, b, T;
                if (o.b = n, o.e = i, n += "", i += "", i === "auto" && (e.style[t] = i, i = In(e, t) || i, e.style[t] = n), u = [n, i], Of(u), n = u[0], i = u[1], f = n.match(Nr) || [], T = i.match(Nr) || [], T.length) {
                    for (; h = Nr.exec(i);) v = h[0], _ = i.substring(l, h.index), m ? m = (m + 1) % 5 : (_.substr(-5) === "rgba(" || _.substr(-5) === "hsla(") && (m = 1), v !== (g = f[c++] || "") && (d = parseFloat(g) || 0, y = g.substr((d + "").length), b = v.charAt(1) === "=" ? +(v.charAt(0) + "1") : 0, b && (v = v.substr(2)), p = parseFloat(v), M = v.substr((p + "").length), l = Nr.lastIndex - M.length, M || (M = M || Ft.units[t] || y, l === i.length && (i += M, o.e += M)), y !== M && (d = pi(e, t, g, M) || 0), o._pt = {
                        _next: o._pt,
                        p: _ || c === 1 ? _ : ",",
                        s: d,
                        c: b ? b * p : p - d,
                        m: m && m < 4 || t === "zIndex" ? Math.round : 0
                    });
                    o.c = l < i.length ? i.substring(l, i.length) : ""
                } else o.r = t === "display" && i === "none" ? td : ed;
                return cf.test(i) && (o.e = 0), this._pt = o, o
            },
            ld = {
                top: "0%",
                bottom: "100%",
                left: "0%",
                right: "100%",
                center: "50%"
            },
            i1 = function(e) {
                var t = e.split(" "),
                    n = t[0],
                    i = t[1] || "50%";
                return (n === "top" || n === "bottom" || i === "left" || i === "right") && (e = n, n = i, i = e), t[0] = ld[n] || n, t[1] = ld[i] || i, t.join(" ")
            },
            r1 = function(e, t) {
                if (t.tween && t.tween._time === t.tween._dur) {
                    var n = t.t,
                        i = n.style,
                        r = t.u,
                        s = n._gsap,
                        o, l, c;
                    if (r === "all" || r === !0) i.cssText = "", l = 1;
                    else
                        for (r = r.split(","), c = r.length; --c > -1;) o = r[c], ui[o] && (l = 1, o = o === "transformOrigin" ? fi : _t), Fs(n, o);
                    l && (Fs(n, _t), s && (s.svg && n.removeAttribute("transform"), Ns(n, 1), s.uncache = 1))
                }
            },
            $a = {
                clearProps: function(e, t, n, i, r) {
                    if (r.data !== "isFromStart") {
                        var s = e._pt = new Bt(e._pt, t, n, 0, 0, r1);
                        return s.u = i, s.pr = -10, s.tween = r, e._props.push(n), 1
                    }
                }
            },
            zs = [1, 0, 0, 1, 0, 0],
            cd = {},
            ud = function(e) {
                return e === "matrix(1, 0, 0, 1, 0, 0)" || e === "none" || !e
            },
            hd = function(e) {
                var t = In(e, _t);
                return ud(t) ? zs : t.substr(7).match(lf).map(rt)
            },
            nc = function(e, t) {
                var n = e._gsap || Ri(e),
                    i = e.style,
                    r = hd(e),
                    s, o, l, c;
                return n.svg && e.getAttribute("transform") ? (l = e.transform.baseVal.consolidate().matrix, r = [l.a, l.b, l.c, l.d, l.e, l.f], r.join(",") === "1,0,0,1,0,0" ? zs : r) : (r === zs && !e.offsetParent && e !== Wr && !n.svg && (l = i.display, i.display = "block", s = e.parentNode, (!s || !e.offsetParent) && (c = 1, o = e.nextSibling, Wr.appendChild(e)), r = hd(e), l ? i.display = l : Fs(e, "display"), c && (o ? s.insertBefore(e, o) : s ? s.appendChild(e) : Wr.removeChild(e))), t && r.length > 6 ? [r[0], r[1], r[4], r[5], r[12], r[13]] : r)
            },
            ic = function(e, t, n, i, r, s) {
                var o = e._gsap,
                    l = r || nc(e, !0),
                    c = o.xOrigin || 0,
                    u = o.yOrigin || 0,
                    h = o.xOffset || 0,
                    f = o.yOffset || 0,
                    d = l[0],
                    m = l[1],
                    g = l[2],
                    v = l[3],
                    p = l[4],
                    _ = l[5],
                    M = t.split(" "),
                    y = parseFloat(M[0]) || 0,
                    b = parseFloat(M[1]) || 0,
                    T, x, R, P;
                n ? l !== zs && (x = d * v - m * g) && (R = y * (v / x) + b * (-g / x) + (g * _ - v * p) / x, P = y * (-m / x) + b * (d / x) - (d * _ - m * p) / x, y = R, b = P) : (T = sd(e), y = T.x + (~M[0].indexOf("%") ? y / 100 * T.width : y), b = T.y + (~(M[1] || M[0]).indexOf("%") ? b / 100 * T.height : b)), i || i !== !1 && o.smooth ? (p = y - c, _ = b - u, o.xOffset = h + (p * d + _ * g) - p, o.yOffset = f + (p * m + _ * v) - _) : o.xOffset = o.yOffset = 0, o.xOrigin = y, o.yOrigin = b, o.smooth = !!i, o.origin = t, o.originIsAbsolute = !!n, e.style[fi] = "0px 0px", s && (di(s, o, "xOrigin", c, y), di(s, o, "yOrigin", u, b), di(s, o, "xOffset", h, o.xOffset), di(s, o, "yOffset", f, o.yOffset)), e.setAttribute("data-svg-origin", y + " " + b)
            },
            Ns = function(e, t) {
                var n = e._gsap || new Hf(e);
                if ("x" in n && !t && !n.uncache) return n;
                var i = e.style,
                    r = n.scaleX < 0,
                    s = "px",
                    o = "deg",
                    l = In(e, fi) || "0",
                    c, u, h, f, d, m, g, v, p, _, M, y, b, T, x, R, P, I, L, Y, D, F, N, z, k, J, oe, he, ie, be, W, $;
                return c = u = h = m = g = v = p = _ = M = 0, f = d = 1, n.svg = !!(e.getCTM && ad(e)), T = nc(e, n.svg), n.svg && (z = (!n.uncache || l === "0px 0px") && !t && e.getAttribute("data-svg-origin"), ic(e, z || l, !!z || n.originIsAbsolute, n.smooth !== !1, T)), y = n.xOrigin || 0, b = n.yOrigin || 0, T !== zs && (I = T[0], L = T[1], Y = T[2], D = T[3], c = F = T[4], u = N = T[5], T.length === 6 ? (f = Math.sqrt(I * I + L * L), d = Math.sqrt(D * D + Y * Y), m = I || L ? Xr(L, I) * Ii : 0, p = Y || D ? Xr(Y, D) * Ii + m : 0, p && (d *= Math.abs(Math.cos(p * qr))), n.svg && (c -= y - (y * I + b * Y), u -= b - (y * L + b * D))) : ($ = T[6], be = T[7], oe = T[8], he = T[9], ie = T[10], W = T[11], c = T[12], u = T[13], h = T[14], x = Xr($, ie), g = x * Ii, x && (R = Math.cos(-x), P = Math.sin(-x), z = F * R + oe * P, k = N * R + he * P, J = $ * R + ie * P, oe = F * -P + oe * R, he = N * -P + he * R, ie = $ * -P + ie * R, W = be * -P + W * R, F = z, N = k, $ = J), x = Xr(-Y, ie), v = x * Ii, x && (R = Math.cos(-x), P = Math.sin(-x), z = I * R - oe * P, k = L * R - he * P, J = Y * R - ie * P, W = D * P + W * R, I = z, L = k, Y = J), x = Xr(L, I), m = x * Ii, x && (R = Math.cos(x), P = Math.sin(x), z = I * R + L * P, k = F * R + N * P, L = L * R - I * P, N = N * R - F * P, I = z, F = k), g && Math.abs(g) + Math.abs(m) > 359.9 && (g = m = 0, v = 180 - v), f = rt(Math.sqrt(I * I + L * L + Y * Y)), d = rt(Math.sqrt(N * N + $ * $)), x = Xr(F, N), p = Math.abs(x) > 2e-4 ? x * Ii : 0, M = W ? 1 / (W < 0 ? -W : W) : 0), n.svg && (z = e.getAttribute("transform"), n.forceCSS = e.setAttribute("transform", "") || !ud(In(e, _t)), z && e.setAttribute("transform", z))), Math.abs(p) > 90 && Math.abs(p) < 270 && (r ? (f *= -1, p += m <= 0 ? 180 : -180, m += m <= 0 ? 180 : -180) : (d *= -1, p += p <= 0 ? 180 : -180)), n.x = c - ((n.xPercent = c && (n.xPercent || (Math.round(e.offsetWidth / 2) === Math.round(-c) ? -50 : 0))) ? e.offsetWidth * n.xPercent / 100 : 0) + s, n.y = u - ((n.yPercent = u && (n.yPercent || (Math.round(e.offsetHeight / 2) === Math.round(-u) ? -50 : 0))) ? e.offsetHeight * n.yPercent / 100 : 0) + s, n.z = h + s, n.scaleX = rt(f), n.scaleY = rt(d), n.rotation = rt(m) + o, n.rotationX = rt(g) + o, n.rotationY = rt(v) + o, n.skewX = p + o, n.skewY = _ + o, n.transformPerspective = M + s, (n.zOrigin = parseFloat(l.split(" ")[2]) || 0) && (i[fi] = Ka(l)), n.xOffset = n.yOffset = 0, n.force3D = Ft.force3D, n.renderTransform = n.svg ? a1 : nd ? fd : s1, n.uncache = 0, n
            },
            Ka = function(e) {
                return (e = e.split(" "))[0] + " " + e[1]
            },
            rc = function(e, t, n) {
                var i = qt(t);
                return rt(parseFloat(t) + parseFloat(pi(e, "x", n + "px", i))) + i
            },
            s1 = function(e, t) {
                t.z = "0px", t.rotationY = t.rotationX = "0deg", t.force3D = 0, fd(e, t)
            },
            Fi = "0deg",
            Bs = "0px",
            zi = ") ",
            fd = function(e, t) {
                var n = t || this,
                    i = n.xPercent,
                    r = n.yPercent,
                    s = n.x,
                    o = n.y,
                    l = n.z,
                    c = n.rotation,
                    u = n.rotationY,
                    h = n.rotationX,
                    f = n.skewX,
                    d = n.skewY,
                    m = n.scaleX,
                    g = n.scaleY,
                    v = n.transformPerspective,
                    p = n.force3D,
                    _ = n.target,
                    M = n.zOrigin,
                    y = "",
                    b = p === "auto" && e && e !== 1 || p === !0;
                if (M && (h !== Fi || u !== Fi)) {
                    var T = parseFloat(u) * qr,
                        x = Math.sin(T),
                        R = Math.cos(T),
                        P;
                    T = parseFloat(h) * qr, P = Math.cos(T), s = rc(_, s, x * P * -M), o = rc(_, o, -Math.sin(T) * -M), l = rc(_, l, R * P * -M + M)
                }
                v !== Bs && (y += "perspective(" + v + zi), (i || r) && (y += "translate(" + i + "%, " + r + "%) "), (b || s !== Bs || o !== Bs || l !== Bs) && (y += l !== Bs || b ? "translate3d(" + s + ", " + o + ", " + l + ") " : "translate(" + s + ", " + o + zi), c !== Fi && (y += "rotate(" + c + zi), u !== Fi && (y += "rotateY(" + u + zi), h !== Fi && (y += "rotateX(" + h + zi), (f !== Fi || d !== Fi) && (y += "skew(" + f + ", " + d + zi), (m !== 1 || g !== 1) && (y += "scale(" + m + ", " + g + zi), _.style[_t] = y || "translate(0, 0)"
            },
            a1 = function(e, t) {
                var n = t || this,
                    i = n.xPercent,
                    r = n.yPercent,
                    s = n.x,
                    o = n.y,
                    l = n.rotation,
                    c = n.skewX,
                    u = n.skewY,
                    h = n.scaleX,
                    f = n.scaleY,
                    d = n.target,
                    m = n.xOrigin,
                    g = n.yOrigin,
                    v = n.xOffset,
                    p = n.yOffset,
                    _ = n.forceCSS,
                    M = parseFloat(s),
                    y = parseFloat(o),
                    b, T, x, R, P;
                l = parseFloat(l), c = parseFloat(c), u = parseFloat(u), u && (u = parseFloat(u), c += u, l += u), l || c ? (l *= qr, c *= qr, b = Math.cos(l) * h, T = Math.sin(l) * h, x = Math.sin(l - c) * -f, R = Math.cos(l - c) * f, c && (u *= qr, P = Math.tan(c - u), P = Math.sqrt(1 + P * P), x *= P, R *= P, u && (P = Math.tan(u), P = Math.sqrt(1 + P * P), b *= P, T *= P)), b = rt(b), T = rt(T), x = rt(x), R = rt(R)) : (b = h, R = f, T = x = 0), (M && !~(s + "").indexOf("px") || y && !~(o + "").indexOf("px")) && (M = pi(d, "x", s, "px"), y = pi(d, "y", o, "px")), (m || g || v || p) && (M = rt(M + m - (m * b + g * x) + v), y = rt(y + g - (m * T + g * R) + p)), (i || r) && (P = d.getBBox(), M = rt(M + i / 100 * P.width), y = rt(y + r / 100 * P.height)), P = "matrix(" + b + "," + T + "," + x + "," + R + "," + M + "," + y + ")", d.setAttribute("transform", P), _ && (d.style[_t] = P)
            },
            o1 = function(e, t, n, i, r, s) {
                var o = 360,
                    l = gt(r),
                    c = parseFloat(r) * (l && ~r.indexOf("rad") ? Ii : 1),
                    u = s ? c * s : c - i,
                    h = i + u + "deg",
                    f, d;
                return l && (f = r.split("_")[1], f === "short" && (u %= o, u !== u % (o / 2) && (u += u < 0 ? o : -o)), f === "cw" && u < 0 ? u = (u + o * $f) % o - ~~(u / o) * o : f === "ccw" && u > 0 && (u = (u - o * $f) % o - ~~(u / o) * o)), e._pt = d = new Bt(e._pt, t, n, i, u, jy), d.e = h, d.u = "deg", e._props.push(n), d
            },
            dd = function(e, t) {
                for (var n in t) e[n] = t[n];
                return e
            },
            l1 = function(e, t, n) {
                var i = dd({}, n._gsap),
                    r = "perspective,force3D,transformOrigin,svgOrigin",
                    s = n.style,
                    o, l, c, u, h, f, d, m;
                i.svg ? (c = n.getAttribute("transform"), n.setAttribute("transform", ""), s[_t] = t, o = Ns(n, 1), Fs(n, _t), n.setAttribute("transform", c)) : (c = getComputedStyle(n)[_t], s[_t] = t, o = Ns(n, 1), s[_t] = c);
                for (l in ui) c = i[l], u = o[l], c !== u && r.indexOf(l) < 0 && (d = qt(c), m = qt(u), h = d !== m ? pi(n, l, c, m) : parseFloat(c), f = parseFloat(u), e._pt = new Bt(e._pt, o, l, h, f - h, Qf), e._pt.u = m || 0, e._props.push(l));
                dd(o, i)
            };
        Wt("padding,margin,Width,Radius", function(a, e) {
            var t = "Top",
                n = "Right",
                i = "Bottom",
                r = "Left",
                s = (e < 3 ? [t, n, i, r] : [t + r, t + n, i + n, i + r]).map(function(o) {
                    return e < 2 ? a + o : "border" + o + a
                });
            $a[e > 1 ? "border" + a : a] = function(o, l, c, u, h) {
                var f, d;
                if (arguments.length < 4) return f = s.map(function(m) {
                    return Yr(o, m, c)
                }), d = f.join(" "), d.split(f[0]).length === 5 ? f[0] : d;
                f = (u + "").split(" "), d = {}, s.forEach(function(m, g) {
                    return d[m] = f[g] = f[g] || f[(g - 1) / 2 | 0]
                }), o.init(l, d, h)
            }
        });
        var pd = {
            name: "css",
            register: ec,
            targetTest: function(e) {
                return e.style && e.nodeType
            },
            init: function(e, t, n, i, r) {
                var s = this._props,
                    o = e.style,
                    l = n.vars.startAt,
                    c, u, h, f, d, m, g, v, p, _, M, y, b, T, x;
                Kl || ec();
                for (g in t)
                    if (g !== "autoRound" && (u = t[g], !(Vt[g] && Vf(g, t, n, i, e, r)))) {
                        if (d = typeof u, m = $a[g], d === "function" && (u = u.call(n, i, e, r), d = typeof u), d === "string" && ~u.indexOf("random(") && (u = Rs(u)), m) m(this, e, g, u, n) && (x = 1);
                        else if (g.substr(0, 2) === "--") c = (getComputedStyle(e).getPropertyValue(g) + "").trim(), u += "", oi.lastIndex = 0, oi.test(c) || (v = qt(c), p = qt(u)), p ? v !== p && (c = pi(e, g, c, p) + p) : v && (u += v), this.add(o, "setProperty", c, u, i, r, 0, 0, g), s.push(g);
                        else if (d !== "undefined") {
                            if (l && g in l ? (c = typeof l[g] == "function" ? l[g].call(n, i, e, r) : l[g], g in Ft.units && !qt(c) && (c += Ft.units[g]), gt(c) && ~c.indexOf("random(") && (c = Rs(c)), (c + "").charAt(1) === "=" && (c = Yr(e, g))) : c = Yr(e, g), f = parseFloat(c), _ = d === "string" && u.charAt(1) === "=" ? +(u.charAt(0) + "1") : 0, _ && (u = u.substr(2)), h = parseFloat(u), g in hi && (g === "autoAlpha" && (f === 1 && Yr(e, "visibility") === "hidden" && h && (f = 0), di(this, o, "visibility", f ? "inherit" : "hidden", h ? "inherit" : "hidden", !h)), g !== "scale" && g !== "transform" && (g = hi[g], ~g.indexOf(",") && (g = g.split(",")[0]))), M = g in ui, M) {
                                if (y || (b = e._gsap, b.renderTransform && !t.parseTransform || Ns(e, t.parseTransform), T = t.smoothOrigin !== !1 && b.smooth, y = this._pt = new Bt(this._pt, o, _t, 0, 1, b.renderTransform, b, 0, -1), y.dep = 1), g === "scale") this._pt = new Bt(this._pt, b, "scaleY", b.scaleY, (_ ? _ * h : h - b.scaleY) || 0), s.push("scaleY", g), g += "X";
                                else if (g === "transformOrigin") {
                                    u = i1(u), b.svg ? ic(e, u, 0, T, 0, this) : (p = parseFloat(u.split(" ")[2]) || 0, p !== b.zOrigin && di(this, b, "zOrigin", b.zOrigin, p), di(this, o, g, Ka(c), Ka(u)));
                                    continue
                                } else if (g === "svgOrigin") {
                                    ic(e, u, 1, T, 0, this);
                                    continue
                                } else if (g in cd) {
                                    o1(this, b, g, f, u, _);
                                    continue
                                } else if (g === "smoothOrigin") {
                                    di(this, b, "smooth", b.smooth, u);
                                    continue
                                } else if (g === "force3D") {
                                    b[g] = u;
                                    continue
                                } else if (g === "transform") {
                                    l1(this, u, e);
                                    continue
                                }
                            } else g in o || (g = jr(g) || g);
                            if (M || (h || h === 0) && (f || f === 0) && !Xy.test(u) && g in o) v = (c + "").substr((f + "").length), h || (h = 0), p = qt(u) || (g in Ft.units ? Ft.units[g] : v), v !== p && (f = pi(e, g, c, p)), this._pt = new Bt(this._pt, M ? b : o, g, f, _ ? _ * h : h - f, !M && (p === "px" || g === "zIndex") && t.autoRound !== !1 ? Zy : Qf), this._pt.u = p || 0, v !== p && p !== "%" && (this._pt.b = c, this._pt.r = Yy);
                            else if (g in o) n1.call(this, e, g, c, u);
                            else if (g in e) this.add(e, g, c || e[g], u, i, r);
                            else {
                                Fl(g, u);
                                continue
                            }
                            s.push(g)
                        }
                    }
                x && Yf(this)
            },
            get: Yr,
            aliases: hi,
            getSetter: function(e, t, n) {
                var i = hi[t];
                return i && i.indexOf(",") < 0 && (t = i), t in ui && t !== fi && (e._gsap.x || Yr(e, "x")) ? n && Jf === n ? t === "scale" ? Qy : Ky : (Jf = n || {}) && (t === "scale" ? e1 : t1) : e.style && !Rl(e.style[t]) ? Jy : ~t.indexOf("-") ? $y : Zl(e, t)
            },
            core: {
                _removeProperty: Fs,
                _getMatrix: nc
            }
        };
        vn.utils.checkPrefix = jr,
            function(a, e, t, n) {
                var i = Wt(a + "," + e + "," + t, function(r) {
                    ui[r] = 1
                });
                Wt(e, function(r) {
                    Ft.units[r] = "deg", cd[r] = 1
                }), hi[i[13]] = a + "," + e, Wt(n, function(r) {
                    var s = r.split(":");
                    hi[s[1]] = i[s[0]]
                })
            }("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY"), Wt("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function(a) {
                Ft.units[a] = "px"
            }), vn.registerPlugin(pd);
        var md = vn.registerPlugin(pd) || vn;
        md.core.Tween;
        class Os extends Ge {
            constructor() {
                const e = Os.SkyShader,
                    t = new It({
                        name: "SkyShader",
                        fragmentShader: e.fragmentShader,
                        vertexShader: e.vertexShader,
                        uniforms: ls.clone(e.uniforms),
                        side: nt,
                        depthWrite: !1
                    });
                super(new Yn(1, 1, 1), t)
            }
        }
        Os.prototype.isSky = !0, Os.SkyShader = {
            uniforms: {
                turbidity: {
                    value: 2
                },
                rayleigh: {
                    value: 1
                },
                mieCoefficient: {
                    value: .005
                },
                mieDirectionalG: {
                    value: .8
                },
                sunPosition: {
                    value: new E
                },
                up: {
                    value: new E(0, 1, 0)
                }
            },
            vertexShader: `
		uniform vec3 sunPosition;
		uniform float rayleigh;
		uniform float turbidity;
		uniform float mieCoefficient;
		uniform vec3 up;

		varying vec3 vWorldPosition;
		varying vec3 vSunDirection;
		varying float vSunfade;
		varying vec3 vBetaR;
		varying vec3 vBetaM;
		varying float vSunE;

		// constants for atmospheric scattering
		const float e = 2.71828182845904523536028747135266249775724709369995957;
		const float pi = 3.141592653589793238462643383279502884197169;

		// wavelength of used primaries, according to preetham
		const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );
		// this pre-calcuation replaces older TotalRayleigh(vec3 lambda) function:
		// (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))
		const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );

		// mie stuff
		// K coefficient for the primaries
		const float v = 4.0;
		const vec3 K = vec3( 0.686, 0.678, 0.666 );
		// MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K
		const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );

		// earth shadow hack
		// cutoffAngle = pi / 1.95;
		const float cutoffAngle = 1.6110731556870734;
		const float steepness = 1.5;
		const float EE = 1000.0;

		float sunIntensity( float zenithAngleCos ) {
			zenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );
			return EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );
		}

		vec3 totalMie( float T ) {
			float c = ( 0.2 * T ) * 10E-18;
			return 0.434 * c * MieConst;
		}

		void main() {

			vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
			vWorldPosition = worldPosition.xyz;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			gl_Position.z = gl_Position.w; // set z to camera.far

			vSunDirection = normalize( sunPosition );

			vSunE = sunIntensity( dot( vSunDirection, up ) );

			vSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );

			float rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );

			// extinction (absorbtion + out scattering)
			// rayleigh coefficients
			vBetaR = totalRayleigh * rayleighCoefficient;

			// mie coefficients
			vBetaM = totalMie( turbidity ) * mieCoefficient;

		}`,
            fragmentShader: `
		varying vec3 vWorldPosition;
		varying vec3 vSunDirection;
		varying float vSunfade;
		varying vec3 vBetaR;
		varying vec3 vBetaM;
		varying float vSunE;

		uniform float mieDirectionalG;
		uniform vec3 up;

		const vec3 cameraPos = vec3( 0.0, 0.0, 0.0 );

		// constants for atmospheric scattering
		const float pi = 3.141592653589793238462643383279502884197169;

		const float n = 1.0003; // refractive index of air
		const float N = 2.545E25; // number of molecules per unit volume for air at 288.15K and 1013mb (sea level -45 celsius)

		// optical length at zenith for molecules
		const float rayleighZenithLength = 8.4E3;
		const float mieZenithLength = 1.25E3;
		// 66 arc seconds -> degrees, and the cosine of that
		const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;

		// 3.0 / ( 16.0 * pi )
		const float THREE_OVER_SIXTEENPI = 0.05968310365946075;
		// 1.0 / ( 4.0 * pi )
		const float ONE_OVER_FOURPI = 0.07957747154594767;

		float rayleighPhase( float cosTheta ) {
			return THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );
		}

		float hgPhase( float cosTheta, float g ) {
			float g2 = pow( g, 2.0 );
			float inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );
			return ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );
		}

		void main() {

			vec3 direction = normalize( vWorldPosition - cameraPos );

			// optical length
			// cutoff angle at 90 to avoid singularity in next formula.
			float zenithAngle = acos( max( 0.0, dot( up, direction ) ) );
			float inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );
			float sR = rayleighZenithLength * inverse;
			float sM = mieZenithLength * inverse;

			// combined extinction factor
			vec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );

			// in scattering
			float cosTheta = dot( direction, vSunDirection );

			float rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );
			vec3 betaRTheta = vBetaR * rPhase;

			float mPhase = hgPhase( cosTheta, mieDirectionalG );
			vec3 betaMTheta = vBetaM * mPhase;

			vec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );
			Lin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );

			// nightsky
			float theta = acos( direction.y ); // elevation --> y-axis, [-pi/2, pi/2]
			float phi = atan( direction.z, direction.x ); // azimuth --> x-axis [-pi/2, pi/2]
			vec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );
			vec3 L0 = vec3( 0.1 ) * Fex;

			// composition + solar disc
			float sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );
			L0 += ( vSunE * 19000.0 * Fex ) * sundisk;

			vec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );

			vec3 retColor = pow( texColor, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );

			gl_FragColor = vec4( retColor, 1.0 );

			#include <tonemapping_fragment>
			#include <encodings_fragment>

		}`
        };
        class c1 extends wa {
            constructor(e, t) {
                super();
                const n = go.degToRad(90 - e),
                    i = go.degToRad(t),
                    r = new Os;
                r.scale.setScalar(1e3), r.material.uniforms.turbidity.value = 10, r.material.uniforms.rayleigh.value = 3, r.material.uniforms.mieCoefficient.value = .005, r.material.uniforms.mieDirectionalG.value = .7, r.material.uniforms.sunPosition.value.copy(new E().setFromSphericalCoords(1, n, i)), this.add(r)
            }
            a0() {
                this.traverse(e => {
                    var t, n;
                    e instanceof Ge && ((t = e == null ? void 0 : e.material) == null || t.dispose(), (n = e == null ? void 0 : e.geometry) == null || n.dispose())
                })
            }
        }
        class u1 extends Rn {
            constructor(e) {
                super(e);
                this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function(t) {
                    return new p1(t)
                }), this.register(function(t) {
                    return new x1(t)
                }), this.register(function(t) {
                    return new y1(t)
                }), this.register(function(t) {
                    return new m1(t)
                }), this.register(function(t) {
                    return new g1(t)
                }), this.register(function(t) {
                    return new _1(t)
                }), this.register(function(t) {
                    return new v1(t)
                }), this.register(function(t) {
                    return new f1(t)
                }), this.register(function(t) {
                    return new M1(t)
                })
            }
            load(e, t, n, i) {
                const r = this;
                let s;
                this.resourcePath !== "" ? s = this.resourcePath : this.path !== "" ? s = this.path : s = Ir.extractUrlBase(e), this.manager.itemStart(e);
                const o = function(c) {
                        i ? i(c) : console.error(c), r.manager.itemError(e), r.manager.itemEnd(e)
                    },
                    l = new ml(this.manager);
                l.setPath(this.path), l.setResponseType("arraybuffer"), l.setRequestHeader(this.requestHeader), l.setWithCredentials(this.withCredentials), l.load(e, function(c) {
                    try {
                        r.parse(c, s, function(u) {
                            t(u), r.manager.itemEnd(e)
                        }, o)
                    } catch (u) {
                        o(u)
                    }
                }, n, o)
            }
            setDRACOLoader(e) {
                return this.dracoLoader = e, this
            }
            setDDSLoader() {
                throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')
            }
            setKTX2Loader(e) {
                return this.ktx2Loader = e, this
            }
            setMeshoptDecoder(e) {
                return this.meshoptDecoder = e, this
            }
            register(e) {
                return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e), this
            }
            unregister(e) {
                return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this
            }
            parse(e, t, n, i) {
                let r;
                const s = {},
                    o = {};
                if (typeof e == "string") r = e;
                else if (Ir.decodeText(new Uint8Array(e, 0, 4)) === gd) {
                    try {
                        s[Fe.KHR_BINARY_GLTF] = new b1(e)
                    } catch (h) {
                        i && i(h);
                        return
                    }
                    r = s[Fe.KHR_BINARY_GLTF].content
                } else r = Ir.decodeText(new Uint8Array(e));
                const l = JSON.parse(r);
                if (l.asset === void 0 || l.asset.version[0] < 2) {
                    i && i(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
                    return
                }
                const c = new F1(l, {
                    path: t || this.resourcePath || "",
                    crossOrigin: this.crossOrigin,
                    requestHeader: this.requestHeader,
                    manager: this.manager,
                    ktx2Loader: this.ktx2Loader,
                    meshoptDecoder: this.meshoptDecoder
                });
                c.fileLoader.setRequestHeader(this.requestHeader);
                for (let u = 0; u < this.pluginCallbacks.length; u++) {
                    const h = this.pluginCallbacks[u](c);
                    o[h.name] = h, s[h.name] = !0
                }
                if (l.extensionsUsed)
                    for (let u = 0; u < l.extensionsUsed.length; ++u) {
                        const h = l.extensionsUsed[u],
                            f = l.extensionsRequired || [];
                        switch (h) {
                            case Fe.KHR_MATERIALS_UNLIT:
                                s[h] = new d1;
                                break;
                            case Fe.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                                s[h] = new T1;
                                break;
                            case Fe.KHR_DRACO_MESH_COMPRESSION:
                                s[h] = new w1(l, this.dracoLoader);
                                break;
                            case Fe.KHR_TEXTURE_TRANSFORM:
                                s[h] = new S1;
                                break;
                            case Fe.KHR_MESH_QUANTIZATION:
                                s[h] = new E1;
                                break;
                            default:
                                f.indexOf(h) >= 0 && o[h] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + h + '".')
                        }
                    }
                c.setExtensions(s), c.setPlugins(o), c.parse(n, i)
            }
        }

        function h1() {
            let a = {};
            return {
                get: function(e) {
                    return a[e]
                },
                add: function(e, t) {
                    a[e] = t
                },
                remove: function(e) {
                    delete a[e]
                },
                removeAll: function() {
                    a = {}
                }
            }
        }
        const Fe = {
            KHR_BINARY_GLTF: "KHR_binary_glTF",
            KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
            KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
            KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
            KHR_MATERIALS_IOR: "KHR_materials_ior",
            KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness",
            KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
            KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
            KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
            KHR_MATERIALS_VOLUME: "KHR_materials_volume",
            KHR_TEXTURE_BASISU: "KHR_texture_basisu",
            KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
            KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
            EXT_TEXTURE_WEBP: "EXT_texture_webp",
            EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression"
        };
        class f1 {
            constructor(e) {
                this.parser = e, this.name = Fe.KHR_LIGHTS_PUNCTUAL, this.cache = {
                    refs: {},
                    uses: {}
                }
            }
            _markDefs() {
                const e = this.parser,
                    t = this.parser.json.nodes || [];
                for (let n = 0, i = t.length; n < i; n++) {
                    const r = t[n];
                    r.extensions && r.extensions[this.name] && r.extensions[this.name].light !== void 0 && e._addNodeRef(this.cache, r.extensions[this.name].light)
                }
            }
            _loadLight(e) {
                const t = this.parser,
                    n = "light:" + e;
                let i = t.cache.get(n);
                if (i) return i;
                const r = t.json,
                    l = ((r.extensions && r.extensions[this.name] || {}).lights || [])[e];
                let c;
                const u = new ne(16777215);
                l.color !== void 0 && u.fromArray(l.color);
                const h = l.range !== void 0 ? l.range : 0;
                switch (l.type) {
                    case "directional":
                        c = new xl(u), c.target.position.set(0, 0, -1), c.add(c.target);
                        break;
                    case "point":
                        c = new Ss(u), c.distance = h;
                        break;
                    case "spot":
                        c = new Gh(u), c.distance = h, l.spot = l.spot || {}, l.spot.innerConeAngle = l.spot.innerConeAngle !== void 0 ? l.spot.innerConeAngle : 0, l.spot.outerConeAngle = l.spot.outerConeAngle !== void 0 ? l.spot.outerConeAngle : Math.PI / 4, c.angle = l.spot.outerConeAngle, c.penumbra = 1 - l.spot.innerConeAngle / l.spot.outerConeAngle, c.target.position.set(0, 0, -1), c.add(c.target);
                        break;
                    default:
                        throw new Error("THREE.GLTFLoader: Unexpected light type: " + l.type)
                }
                return c.position.set(0, 0, 0), c.decay = 2, l.intensity !== void 0 && (c.intensity = l.intensity), c.name = t.createUniqueName(l.name || "light_" + e), i = Promise.resolve(c), t.cache.add(n, i), i
            }
            createNodeAttachment(e) {
                const t = this,
                    n = this.parser,
                    r = n.json.nodes[e],
                    o = (r.extensions && r.extensions[this.name] || {}).light;
                return o === void 0 ? null : this._loadLight(o).then(function(l) {
                    return n._getNodeRef(t.cache, o, l)
                })
            }
        }
        class d1 {
            constructor() {
                this.name = Fe.KHR_MATERIALS_UNLIT
            }
            getMaterialType() {
                return un
            }
            extendParams(e, t, n) {
                const i = [];
                e.color = new ne(1, 1, 1), e.opacity = 1;
                const r = t.pbrMetallicRoughness;
                if (r) {
                    if (Array.isArray(r.baseColorFactor)) {
                        const s = r.baseColorFactor;
                        e.color.fromArray(s), e.opacity = s[3]
                    }
                    r.baseColorTexture !== void 0 && i.push(n.assignTexture(e, "map", r.baseColorTexture))
                }
                return Promise.all(i)
            }
        }
        class p1 {
            constructor(e) {
                this.parser = e, this.name = Fe.KHR_MATERIALS_CLEARCOAT
            }
            getMaterialType(e) {
                const n = this.parser.json.materials[e];
                return !n.extensions || !n.extensions[this.name] ? null : Rr
            }
            extendMaterialParams(e, t) {
                const n = this.parser,
                    i = n.json.materials[e];
                if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
                const r = [],
                    s = i.extensions[this.name];
                if (s.clearcoatFactor !== void 0 && (t.clearcoat = s.clearcoatFactor), s.clearcoatTexture !== void 0 && r.push(n.assignTexture(t, "clearcoatMap", s.clearcoatTexture)), s.clearcoatRoughnessFactor !== void 0 && (t.clearcoatRoughness = s.clearcoatRoughnessFactor), s.clearcoatRoughnessTexture !== void 0 && r.push(n.assignTexture(t, "clearcoatRoughnessMap", s.clearcoatRoughnessTexture)), s.clearcoatNormalTexture !== void 0 && (r.push(n.assignTexture(t, "clearcoatNormalMap", s.clearcoatNormalTexture)), s.clearcoatNormalTexture.scale !== void 0)) {
                    const o = s.clearcoatNormalTexture.scale;
                    t.clearcoatNormalScale = new X(o, o)
                }
                return Promise.all(r)
            }
        }
        class m1 {
            constructor(e) {
                this.parser = e, this.name = Fe.KHR_MATERIALS_TRANSMISSION
            }
            getMaterialType(e) {
                const n = this.parser.json.materials[e];
                return !n.extensions || !n.extensions[this.name] ? null : Rr
            }
            extendMaterialParams(e, t) {
                const n = this.parser,
                    i = n.json.materials[e];
                if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
                const r = [],
                    s = i.extensions[this.name];
                return s.transmissionFactor !== void 0 && (t.transmission = s.transmissionFactor), s.transmissionTexture !== void 0 && r.push(n.assignTexture(t, "transmissionMap", s.transmissionTexture)), Promise.all(r)
            }
        }
        class g1 {
            constructor(e) {
                this.parser = e, this.name = Fe.KHR_MATERIALS_VOLUME
            }
            getMaterialType(e) {
                const n = this.parser.json.materials[e];
                return !n.extensions || !n.extensions[this.name] ? null : Rr
            }
            extendMaterialParams(e, t) {
                const n = this.parser,
                    i = n.json.materials[e];
                if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
                const r = [],
                    s = i.extensions[this.name];
                t.thickness = s.thicknessFactor !== void 0 ? s.thicknessFactor : 0, s.thicknessTexture !== void 0 && r.push(n.assignTexture(t, "thicknessMap", s.thicknessTexture)), t.attenuationDistance = s.attenuationDistance || 0;
                const o = s.attenuationColor || [1, 1, 1];
                return t.attenuationTint = new ne(o[0], o[1], o[2]), Promise.all(r)
            }
        }
        class _1 {
            constructor(e) {
                this.parser = e, this.name = Fe.KHR_MATERIALS_IOR
            }
            getMaterialType(e) {
                const n = this.parser.json.materials[e];
                return !n.extensions || !n.extensions[this.name] ? null : Rr
            }
            extendMaterialParams(e, t) {
                const i = this.parser.json.materials[e];
                if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
                const r = i.extensions[this.name];
                return t.ior = r.ior !== void 0 ? r.ior : 1.5, Promise.resolve()
            }
        }
        class v1 {
            constructor(e) {
                this.parser = e, this.name = Fe.KHR_MATERIALS_SPECULAR
            }
            getMaterialType(e) {
                const n = this.parser.json.materials[e];
                return !n.extensions || !n.extensions[this.name] ? null : Rr
            }
            extendMaterialParams(e, t) {
                const n = this.parser,
                    i = n.json.materials[e];
                if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
                const r = [],
                    s = i.extensions[this.name];
                t.specularIntensity = s.specularFactor !== void 0 ? s.specularFactor : 1, s.specularTexture !== void 0 && r.push(n.assignTexture(t, "specularIntensityMap", s.specularTexture));
                const o = s.specularColorFactor || [1, 1, 1];
                return t.specularTint = new ne(o[0], o[1], o[2]), s.specularColorTexture !== void 0 && r.push(n.assignTexture(t, "specularTintMap", s.specularColorTexture).then(function(l) {
                    l.encoding = Ot
                })), Promise.all(r)
            }
        }
        class x1 {
            constructor(e) {
                this.parser = e, this.name = Fe.KHR_TEXTURE_BASISU
            }
            loadTexture(e) {
                const t = this.parser,
                    n = t.json,
                    i = n.textures[e];
                if (!i.extensions || !i.extensions[this.name]) return null;
                const r = i.extensions[this.name],
                    s = n.images[r.source],
                    o = t.options.ktx2Loader;
                if (!o) {
                    if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
                    return null
                }
                return t.loadTextureImage(e, s, o)
            }
        }
        class y1 {
            constructor(e) {
                this.parser = e, this.name = Fe.EXT_TEXTURE_WEBP, this.isSupported = null
            }
            loadTexture(e) {
                const t = this.name,
                    n = this.parser,
                    i = n.json,
                    r = i.textures[e];
                if (!r.extensions || !r.extensions[t]) return null;
                const s = r.extensions[t],
                    o = i.images[s.source];
                let l = n.textureLoader;
                if (o.uri) {
                    const c = n.options.manager.getHandler(o.uri);
                    c !== null && (l = c)
                }
                return this.detectSupport().then(function(c) {
                    if (c) return n.loadTextureImage(e, o, l);
                    if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
                    return n.loadTexture(e)
                })
            }
            detectSupport() {
                return this.isSupported || (this.isSupported = new Promise(function(e) {
                    const t = new Image;
                    t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function() {
                        e(t.height === 1)
                    }
                })), this.isSupported
            }
        }
        class M1 {
            constructor(e) {
                this.name = Fe.EXT_MESHOPT_COMPRESSION, this.parser = e
            }
            loadBufferView(e) {
                const t = this.parser.json,
                    n = t.bufferViews[e];
                if (n.extensions && n.extensions[this.name]) {
                    const i = n.extensions[this.name],
                        r = this.parser.getDependency("buffer", i.buffer),
                        s = this.parser.options.meshoptDecoder;
                    if (!s || !s.supported) {
                        if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
                        return null
                    }
                    return Promise.all([r, s.ready]).then(function(o) {
                        const l = i.byteOffset || 0,
                            c = i.byteLength || 0,
                            u = i.count,
                            h = i.byteStride,
                            f = new ArrayBuffer(u * h),
                            d = new Uint8Array(o[0], l, c);
                        return s.decodeGltfBuffer(new Uint8Array(f), u, h, d, i.mode, i.filter), f
                    })
                } else return null
            }
        }
        const gd = "glTF",
            Us = 12,
            _d = {
                JSON: 1313821514,
                BIN: 5130562
            };
        class b1 {
            constructor(e) {
                this.name = Fe.KHR_BINARY_GLTF, this.content = null, this.body = null;
                const t = new DataView(e, 0, Us);
                if (this.header = {
                        magic: Ir.decodeText(new Uint8Array(e.slice(0, 4))),
                        version: t.getUint32(4, !0),
                        length: t.getUint32(8, !0)
                    }, this.header.magic !== gd) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
                if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
                const n = this.header.length - Us,
                    i = new DataView(e, Us);
                let r = 0;
                for (; r < n;) {
                    const s = i.getUint32(r, !0);
                    r += 4;
                    const o = i.getUint32(r, !0);
                    if (r += 4, o === _d.JSON) {
                        const l = new Uint8Array(e, Us + r, s);
                        this.content = Ir.decodeText(l)
                    } else if (o === _d.BIN) {
                        const l = Us + r;
                        this.body = e.slice(l, l + s)
                    }
                    r += s
                }
                if (this.content === null) throw new Error("THREE.GLTFLoader: JSON content not found.")
            }
        }
        class w1 {
            constructor(e, t) {
                if (!t) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
                this.name = Fe.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload()
            }
            decodePrimitive(e, t) {
                const n = this.json,
                    i = this.dracoLoader,
                    r = e.extensions[this.name].bufferView,
                    s = e.extensions[this.name].attributes,
                    o = {},
                    l = {},
                    c = {};
                for (const u in s) {
                    const h = ac[u] || u.toLowerCase();
                    o[h] = s[u]
                }
                for (const u in e.attributes) {
                    const h = ac[u] || u.toLowerCase();
                    if (s[u] !== void 0) {
                        const f = n.accessors[e.attributes[u]],
                            d = ks[f.componentType];
                        c[h] = d, l[h] = f.normalized === !0
                    }
                }
                return t.getDependency("bufferView", r).then(function(u) {
                    return new Promise(function(h) {
                        i.decodeDracoFile(u, function(f) {
                            for (const d in f.attributes) {
                                const m = f.attributes[d],
                                    g = l[d];
                                g !== void 0 && (m.normalized = g)
                            }
                            h(f)
                        }, o, c)
                    })
                })
            }
        }
        class S1 {
            constructor() {
                this.name = Fe.KHR_TEXTURE_TRANSFORM
            }
            extendTexture(e, t) {
                return t.texCoord !== void 0 && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'), t.offset === void 0 && t.rotation === void 0 && t.scale === void 0 || (e = e.clone(), t.offset !== void 0 && e.offset.fromArray(t.offset), t.rotation !== void 0 && (e.rotation = t.rotation), t.scale !== void 0 && e.repeat.fromArray(t.scale), e.needsUpdate = !0), e
            }
        }
        class sc extends ni {
            constructor(e) {
                super();
                this.isGLTFSpecularGlossinessMaterial = !0;
                const t = ["#ifdef USE_SPECULARMAP", "	uniform sampler2D specularMap;", "#endif"].join(`
`),
                    n = ["#ifdef USE_GLOSSINESSMAP", "	uniform sampler2D glossinessMap;", "#endif"].join(`
`),
                    i = ["vec3 specularFactor = specular;", "#ifdef USE_SPECULARMAP", "	vec4 texelSpecular = texture2D( specularMap, vUv );", "	texelSpecular = sRGBToLinear( texelSpecular );", "	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture", "	specularFactor *= texelSpecular.rgb;", "#endif"].join(`
`),
                    r = ["float glossinessFactor = glossiness;", "#ifdef USE_GLOSSINESSMAP", "	vec4 texelGlossiness = texture2D( glossinessMap, vUv );", "	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture", "	glossinessFactor *= texelGlossiness.a;", "#endif"].join(`
`),
                    s = ["PhysicalMaterial material;", "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );", "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );", "material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.", "material.roughness += geometryRoughness;", "material.roughness = min( material.roughness, 1.0 );", "material.specularColor = specularFactor;"].join(`
`),
                    o = {
                        specular: {
                            value: new ne().setHex(16777215)
                        },
                        glossiness: {
                            value: 1
                        },
                        specularMap: {
                            value: null
                        },
                        glossinessMap: {
                            value: null
                        }
                    };
                this._extraUniforms = o, this.onBeforeCompile = function(l) {
                    for (const c in o) l.uniforms[c] = o[c];
                    l.fragmentShader = l.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", t).replace("#include <metalnessmap_pars_fragment>", n).replace("#include <roughnessmap_fragment>", i).replace("#include <metalnessmap_fragment>", r).replace("#include <lights_physical_fragment>", s)
                }, Object.defineProperties(this, {
                    specular: {
                        get: function() {
                            return o.specular.value
                        },
                        set: function(l) {
                            o.specular.value = l
                        }
                    },
                    specularMap: {
                        get: function() {
                            return o.specularMap.value
                        },
                        set: function(l) {
                            o.specularMap.value = l, l ? this.defines.USE_SPECULARMAP = "" : delete this.defines.USE_SPECULARMAP
                        }
                    },
                    glossiness: {
                        get: function() {
                            return o.glossiness.value
                        },
                        set: function(l) {
                            o.glossiness.value = l
                        }
                    },
                    glossinessMap: {
                        get: function() {
                            return o.glossinessMap.value
                        },
                        set: function(l) {
                            o.glossinessMap.value = l, l ? (this.defines.USE_GLOSSINESSMAP = "", this.defines.USE_UV = "") : (delete this.defines.USE_GLOSSINESSMAP, delete this.defines.USE_UV)
                        }
                    }
                }), delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this.setValues(e)
            }
            copy(e) {
                return super.copy(e), this.specularMap = e.specularMap, this.specular.copy(e.specular), this.glossinessMap = e.glossinessMap, this.glossiness = e.glossiness, delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this
            }
        }
        class T1 {
            constructor() {
                this.name = Fe.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS, this.specularGlossinessParams = ["color", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "normalMapType", "displacementMap", "displacementScale", "displacementBias", "specularMap", "specular", "glossinessMap", "glossiness", "alphaMap", "envMap", "envMapIntensity", "refractionRatio"]
            }
            getMaterialType() {
                return sc
            }
            extendParams(e, t, n) {
                const i = t.extensions[this.name];
                e.color = new ne(1, 1, 1), e.opacity = 1;
                const r = [];
                if (Array.isArray(i.diffuseFactor)) {
                    const s = i.diffuseFactor;
                    e.color.fromArray(s), e.opacity = s[3]
                }
                if (i.diffuseTexture !== void 0 && r.push(n.assignTexture(e, "map", i.diffuseTexture)), e.emissive = new ne(0, 0, 0), e.glossiness = i.glossinessFactor !== void 0 ? i.glossinessFactor : 1, e.specular = new ne(1, 1, 1), Array.isArray(i.specularFactor) && e.specular.fromArray(i.specularFactor), i.specularGlossinessTexture !== void 0) {
                    const s = i.specularGlossinessTexture;
                    r.push(n.assignTexture(e, "glossinessMap", s)), r.push(n.assignTexture(e, "specularMap", s))
                }
                return Promise.all(r)
            }
            createMaterial(e) {
                const t = new sc(e);
                return t.fog = !0, t.color = e.color, t.map = e.map === void 0 ? null : e.map, t.lightMap = null, t.lightMapIntensity = 1, t.aoMap = e.aoMap === void 0 ? null : e.aoMap, t.aoMapIntensity = 1, t.emissive = e.emissive, t.emissiveIntensity = 1, t.emissiveMap = e.emissiveMap === void 0 ? null : e.emissiveMap, t.bumpMap = e.bumpMap === void 0 ? null : e.bumpMap, t.bumpScale = 1, t.normalMap = e.normalMap === void 0 ? null : e.normalMap, t.normalMapType = kn, e.normalScale && (t.normalScale = e.normalScale), t.displacementMap = null, t.displacementScale = 1, t.displacementBias = 0, t.specularMap = e.specularMap === void 0 ? null : e.specularMap, t.specular = e.specular, t.glossinessMap = e.glossinessMap === void 0 ? null : e.glossinessMap, t.glossiness = e.glossiness, t.alphaMap = null, t.envMap = e.envMap === void 0 ? null : e.envMap, t.envMapIntensity = 1, t.refractionRatio = .98, t
            }
        }
        class E1 {
            constructor() {
                this.name = Fe.KHR_MESH_QUANTIZATION
            }
        }
        class Ni extends Ln {
            constructor(e, t, n, i) {
                super(e, t, n, i)
            }
            copySampleValue_(e) {
                const t = this.resultBuffer,
                    n = this.sampleValues,
                    i = this.valueSize,
                    r = e * i * 3 + i;
                for (let s = 0; s !== i; s++) t[s] = n[r + s];
                return t
            }
        }
        Ni.prototype.beforeStart_ = Ni.prototype.copySampleValue_, Ni.prototype.afterEnd_ = Ni.prototype.copySampleValue_, Ni.prototype.interpolate_ = function(a, e, t, n) {
            const i = this.resultBuffer,
                r = this.sampleValues,
                s = this.valueSize,
                o = s * 2,
                l = s * 3,
                c = n - e,
                u = (t - e) / c,
                h = u * u,
                f = h * u,
                d = a * l,
                m = d - l,
                g = -2 * f + 3 * h,
                v = f - h,
                p = 1 - g,
                _ = v - h + u;
            for (let M = 0; M !== s; M++) {
                const y = r[m + M + s],
                    b = r[m + M + o] * c,
                    T = r[d + M + s],
                    x = r[d + M] * c;
                i[M] = p * y + _ * b + g * T + v * x
            }
            return i
        };
        const A1 = new At;
        class L1 extends Ni {
            interpolate_(e, t, n, i) {
                const r = super.interpolate_(e, t, n, i);
                return A1.fromArray(r).normalize().toArray(r), r
            }
        }
        const Fn = {
                FLOAT: 5126,
                FLOAT_MAT3: 35675,
                FLOAT_MAT4: 35676,
                FLOAT_VEC2: 35664,
                FLOAT_VEC3: 35665,
                FLOAT_VEC4: 35666,
                LINEAR: 9729,
                REPEAT: 10497,
                SAMPLER_2D: 35678,
                POINTS: 0,
                LINES: 1,
                LINE_LOOP: 2,
                LINE_STRIP: 3,
                TRIANGLES: 4,
                TRIANGLE_STRIP: 5,
                TRIANGLE_FAN: 6,
                UNSIGNED_BYTE: 5121,
                UNSIGNED_SHORT: 5123
            },
            ks = {
                5120: Int8Array,
                5121: Uint8Array,
                5122: Int16Array,
                5123: Uint16Array,
                5125: Uint32Array,
                5126: Float32Array
            },
            vd = {
                9728: st,
                9729: lt,
                9984: ao,
                9985: Ic,
                9986: oo,
                9987: qi
            },
            xd = {
                33071: Ct,
                33648: Zs,
                10497: xn
            },
            yd = {
                SCALAR: 1,
                VEC2: 2,
                VEC3: 3,
                VEC4: 4,
                MAT2: 4,
                MAT3: 9,
                MAT4: 16
            },
            ac = {
                POSITION: "position",
                NORMAL: "normal",
                TANGENT: "tangent",
                TEXCOORD_0: "uv",
                TEXCOORD_1: "uv2",
                COLOR_0: "color",
                WEIGHTS_0: "skinWeight",
                JOINTS_0: "skinIndex"
            },
            mi = {
                scale: "scale",
                translation: "position",
                rotation: "quaternion",
                weights: "morphTargetInfluences"
            },
            R1 = {
                CUBICSPLINE: void 0,
                LINEAR: Yi,
                STEP: Qr
            },
            oc = {
                OPAQUE: "OPAQUE",
                MASK: "MASK",
                BLEND: "BLEND"
            };

        function Md(a, e) {
            return typeof a != "string" || a === "" ? "" : (/^https?:\/\//i.test(e) && /^\//.test(a) && (e = e.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(a) || /^data:.*,.*$/i.test(a) || /^blob:.*$/i.test(a) ? a : e + a)
        }

        function C1(a) {
            return a.DefaultMaterial === void 0 && (a.DefaultMaterial = new ni({
                color: 16777215,
                emissive: 0,
                metalness: 1,
                roughness: 1,
                transparent: !1,
                depthTest: !0,
                side: Vi
            })), a.DefaultMaterial
        }

        function Gs(a, e, t) {
            for (const n in t.extensions) a[n] === void 0 && (e.userData.gltfExtensions = e.userData.gltfExtensions || {}, e.userData.gltfExtensions[n] = t.extensions[n])
        }

        function Bi(a, e) {
            e.extras !== void 0 && (typeof e.extras == "object" ? Object.assign(a.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras))
        }

        function P1(a, e, t) {
            let n = !1,
                i = !1;
            for (let o = 0, l = e.length; o < l; o++) {
                const c = e[o];
                if (c.POSITION !== void 0 && (n = !0), c.NORMAL !== void 0 && (i = !0), n && i) break
            }
            if (!n && !i) return Promise.resolve(a);
            const r = [],
                s = [];
            for (let o = 0, l = e.length; o < l; o++) {
                const c = e[o];
                if (n) {
                    const u = c.POSITION !== void 0 ? t.getDependency("accessor", c.POSITION) : a.attributes.position;
                    r.push(u)
                }
                if (i) {
                    const u = c.NORMAL !== void 0 ? t.getDependency("accessor", c.NORMAL) : a.attributes.normal;
                    s.push(u)
                }
            }
            return Promise.all([Promise.all(r), Promise.all(s)]).then(function(o) {
                const l = o[0],
                    c = o[1];
                return n && (a.morphAttributes.position = l), i && (a.morphAttributes.normal = c), a.morphTargetsRelative = !0, a
            })
        }

        function D1(a, e) {
            if (a.updateMorphTargets(), e.weights !== void 0)
                for (let t = 0, n = e.weights.length; t < n; t++) a.morphTargetInfluences[t] = e.weights[t];
            if (e.extras && Array.isArray(e.extras.targetNames)) {
                const t = e.extras.targetNames;
                if (a.morphTargetInfluences.length === t.length) {
                    a.morphTargetDictionary = {};
                    for (let n = 0, i = t.length; n < i; n++) a.morphTargetDictionary[t[n]] = n
                } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")
            }
        }

        function I1(a) {
            const e = a.extensions && a.extensions[Fe.KHR_DRACO_MESH_COMPRESSION];
            let t;
            return e ? t = "draco:" + e.bufferView + ":" + e.indices + ":" + bd(e.attributes) : t = a.indices + ":" + bd(a.attributes) + ":" + a.mode, t
        }

        function bd(a) {
            let e = "";
            const t = Object.keys(a).sort();
            for (let n = 0, i = t.length; n < i; n++) e += t[n] + ":" + a[t[n]] + ";";
            return e
        }

        function lc(a) {
            switch (a) {
                case Int8Array:
                    return 1 / 127;
                case Uint8Array:
                    return 1 / 255;
                case Int16Array:
                    return 1 / 32767;
                case Uint16Array:
                    return 1 / 65535;
                default:
                    throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")
            }
        }
        class F1 {
            constructor(e = {}, t = {}) {
                this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new h1, this.associations = new Map, this.primitiveCache = {}, this.meshCache = {
                    refs: {},
                    uses: {}
                }, this.cameraCache = {
                    refs: {},
                    uses: {}
                }, this.lightCache = {
                    refs: {},
                    uses: {}
                }, this.textureCache = {}, this.nodeNamesUsed = {}, typeof createImageBitmap != "undefined" && /Firefox/.test(navigator.userAgent) === !1 ? this.textureLoader = new Xh(this.options.manager) : this.textureLoader = new gl(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new ml(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0)
            }
            setExtensions(e) {
                this.extensions = e
            }
            setPlugins(e) {
                this.plugins = e
            }
            parse(e, t) {
                const n = this,
                    i = this.json,
                    r = this.extensions;
                this.cache.removeAll(), this._invokeAll(function(s) {
                    return s._markDefs && s._markDefs()
                }), Promise.all(this._invokeAll(function(s) {
                    return s.beforeRoot && s.beforeRoot()
                })).then(function() {
                    return Promise.all([n.getDependencies("scene"), n.getDependencies("animation"), n.getDependencies("camera")])
                }).then(function(s) {
                    const o = {
                        scene: s[0][i.scene || 0],
                        scenes: s[0],
                        animations: s[1],
                        cameras: s[2],
                        asset: i.asset,
                        parser: n,
                        userData: {}
                    };
                    Gs(r, o, i), Bi(o, i), Promise.all(n._invokeAll(function(l) {
                        return l.afterRoot && l.afterRoot(o)
                    })).then(function() {
                        e(o)
                    })
                }).catch(t)
            }
            _markDefs() {
                const e = this.json.nodes || [],
                    t = this.json.skins || [],
                    n = this.json.meshes || [];
                for (let i = 0, r = t.length; i < r; i++) {
                    const s = t[i].joints;
                    for (let o = 0, l = s.length; o < l; o++) e[s[o]].isBone = !0
                }
                for (let i = 0, r = e.length; i < r; i++) {
                    const s = e[i];
                    s.mesh !== void 0 && (this._addNodeRef(this.meshCache, s.mesh), s.skin !== void 0 && (n[s.mesh].isSkinnedMesh = !0)), s.camera !== void 0 && this._addNodeRef(this.cameraCache, s.camera)
                }
            }
            _addNodeRef(e, t) {
                t !== void 0 && (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++)
            }
            _getNodeRef(e, t, n) {
                if (e.refs[t] <= 1) return n;
                const i = n.clone(),
                    r = (s, o) => {
                        const l = this.associations.get(s);
                        l != null && this.associations.set(o, l);
                        for (const [c, u] of s.children.entries()) r(u, o.children[c])
                    };
                return r(n, i), i.name += "_instance_" + e.uses[t]++, i
            }
            _invokeOne(e) {
                const t = Object.values(this.plugins);
                t.push(this);
                for (let n = 0; n < t.length; n++) {
                    const i = e(t[n]);
                    if (i) return i
                }
                return null
            }
            _invokeAll(e) {
                const t = Object.values(this.plugins);
                t.unshift(this);
                const n = [];
                for (let i = 0; i < t.length; i++) {
                    const r = e(t[i]);
                    r && n.push(r)
                }
                return n
            }
            getDependency(e, t) {
                const n = e + ":" + t;
                let i = this.cache.get(n);
                if (!i) {
                    switch (e) {
                        case "scene":
                            i = this.loadScene(t);
                            break;
                        case "node":
                            i = this.loadNode(t);
                            break;
                        case "mesh":
                            i = this._invokeOne(function(r) {
                                return r.loadMesh && r.loadMesh(t)
                            });
                            break;
                        case "accessor":
                            i = this.loadAccessor(t);
                            break;
                        case "bufferView":
                            i = this._invokeOne(function(r) {
                                return r.loadBufferView && r.loadBufferView(t)
                            });
                            break;
                        case "buffer":
                            i = this.loadBuffer(t);
                            break;
                        case "material":
                            i = this._invokeOne(function(r) {
                                return r.loadMaterial && r.loadMaterial(t)
                            });
                            break;
                        case "texture":
                            i = this._invokeOne(function(r) {
                                return r.loadTexture && r.loadTexture(t)
                            });
                            break;
                        case "skin":
                            i = this.loadSkin(t);
                            break;
                        case "animation":
                            i = this.loadAnimation(t);
                            break;
                        case "camera":
                            i = this.loadCamera(t);
                            break;
                        default:
                            throw new Error("Unknown type: " + e)
                    }
                    this.cache.add(n, i)
                }
                return i
            }
            getDependencies(e) {
                let t = this.cache.get(e);
                if (!t) {
                    const n = this,
                        i = this.json[e + (e === "mesh" ? "es" : "s")] || [];
                    t = Promise.all(i.map(function(r, s) {
                        return n.getDependency(e, s)
                    })), this.cache.add(e, t)
                }
                return t
            }
            loadBuffer(e) {
                const t = this.json.buffers[e],
                    n = this.fileLoader;
                if (t.type && t.type !== "arraybuffer") throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
                if (t.uri === void 0 && e === 0) return Promise.resolve(this.extensions[Fe.KHR_BINARY_GLTF].body);
                const i = this.options;
                return new Promise(function(r, s) {
                    n.load(Md(t.uri, i.path), r, void 0, function() {
                        s(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'))
                    })
                })
            }
            loadBufferView(e) {
                const t = this.json.bufferViews[e];
                return this.getDependency("buffer", t.buffer).then(function(n) {
                    const i = t.byteLength || 0,
                        r = t.byteOffset || 0;
                    return n.slice(r, r + i)
                })
            }
            loadAccessor(e) {
                const t = this,
                    n = this.json,
                    i = this.json.accessors[e];
                if (i.bufferView === void 0 && i.sparse === void 0) return Promise.resolve(null);
                const r = [];
                return i.bufferView !== void 0 ? r.push(this.getDependency("bufferView", i.bufferView)) : r.push(null), i.sparse !== void 0 && (r.push(this.getDependency("bufferView", i.sparse.indices.bufferView)), r.push(this.getDependency("bufferView", i.sparse.values.bufferView))), Promise.all(r).then(function(s) {
                    const o = s[0],
                        l = yd[i.type],
                        c = ks[i.componentType],
                        u = c.BYTES_PER_ELEMENT,
                        h = u * l,
                        f = i.byteOffset || 0,
                        d = i.bufferView !== void 0 ? n.bufferViews[i.bufferView].byteStride : void 0,
                        m = i.normalized === !0;
                    let g, v;
                    if (d && d !== h) {
                        const p = Math.floor(f / d),
                            _ = "InterleavedBuffer:" + i.bufferView + ":" + i.componentType + ":" + p + ":" + i.count;
                        let M = t.cache.get(_);
                        M || (g = new c(o, p * d, i.count * d / u), M = new xr(g, d / u), t.cache.add(_, M)), v = new yr(M, l, f % d / u, m)
                    } else o === null ? g = new c(i.count * l) : g = new c(o, f, i.count * l), v = new Qe(g, l, m);
                    if (i.sparse !== void 0) {
                        const p = yd.SCALAR,
                            _ = ks[i.sparse.indices.componentType],
                            M = i.sparse.indices.byteOffset || 0,
                            y = i.sparse.values.byteOffset || 0,
                            b = new _(s[1], M, i.sparse.count * p),
                            T = new c(s[2], y, i.sparse.count * l);
                        o !== null && (v = new Qe(v.array.slice(), v.itemSize, v.normalized));
                        for (let x = 0, R = b.length; x < R; x++) {
                            const P = b[x];
                            if (v.setX(P, T[x * l]), l >= 2 && v.setY(P, T[x * l + 1]), l >= 3 && v.setZ(P, T[x * l + 2]), l >= 4 && v.setW(P, T[x * l + 3]), l >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")
                        }
                    }
                    return v
                })
            }
            loadTexture(e) {
                const t = this.json,
                    n = this.options,
                    i = t.textures[e],
                    r = t.images[i.source];
                let s = this.textureLoader;
                if (r.uri) {
                    const o = n.manager.getHandler(r.uri);
                    o !== null && (s = o)
                }
                return this.loadTextureImage(e, r, s)
            }
            loadTextureImage(e, t, n) {
                const i = this,
                    r = this.json,
                    s = this.options,
                    o = r.textures[e],
                    l = (t.uri || t.bufferView) + ":" + o.sampler;
                if (this.textureCache[l]) return this.textureCache[l];
                const c = self.URL || self.webkitURL;
                let u = t.uri || "",
                    h = !1;
                if (t.bufferView !== void 0) u = i.getDependency("bufferView", t.bufferView).then(function(d) {
                    h = !0;
                    const m = new Blob([d], {
                        type: t.mimeType
                    });
                    return u = c.createObjectURL(m), u
                });
                else if (t.uri === void 0) throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
                const f = Promise.resolve(u).then(function(d) {
                    return new Promise(function(m, g) {
                        let v = m;
                        n.isImageBitmapLoader === !0 && (v = function(p) {
                            const _ = new at(p);
                            _.needsUpdate = !0, m(_)
                        }), n.load(Md(d, s.path), v, void 0, g)
                    })
                }).then(function(d) {
                    h === !0 && c.revokeObjectURL(u), d.flipY = !1, o.name && (d.name = o.name);
                    const g = (r.samplers || {})[o.sampler] || {};
                    return d.magFilter = vd[g.magFilter] || lt, d.minFilter = vd[g.minFilter] || qi, d.wrapS = xd[g.wrapS] || xn, d.wrapT = xd[g.wrapT] || xn, i.associations.set(d, {
                        textures: e
                    }), d
                }).catch(function() {
                    return console.error("THREE.GLTFLoader: Couldn't load texture", u), null
                });
                return this.textureCache[l] = f, f
            }
            assignTexture(e, t, n) {
                const i = this;
                return this.getDependency("texture", n.index).then(function(r) {
                    if (n.texCoord !== void 0 && n.texCoord != 0 && !(t === "aoMap" && n.texCoord == 1) && console.warn("THREE.GLTFLoader: Custom UV set " + n.texCoord + " for texture " + t + " not yet supported."), i.extensions[Fe.KHR_TEXTURE_TRANSFORM]) {
                        const s = n.extensions !== void 0 ? n.extensions[Fe.KHR_TEXTURE_TRANSFORM] : void 0;
                        if (s) {
                            const o = i.associations.get(r);
                            r = i.extensions[Fe.KHR_TEXTURE_TRANSFORM].extendTexture(r, s), i.associations.set(r, o)
                        }
                    }
                    return e[t] = r, r
                })
            }
            assignFinalMaterial(e) {
                const t = e.geometry;
                let n = e.material;
                const i = t.attributes.tangent === void 0,
                    r = t.attributes.color !== void 0,
                    s = t.attributes.normal === void 0;
                if (e.isPoints) {
                    const o = "PointsMaterial:" + n.uuid;
                    let l = this.cache.get(o);
                    l || (l = new tl, ot.prototype.copy.call(l, n), l.color.copy(n.color), l.map = n.map, l.sizeAttenuation = !1, this.cache.add(o, l)), n = l
                } else if (e.isLine) {
                    const o = "LineBasicMaterial:" + n.uuid;
                    let l = this.cache.get(o);
                    l || (l = new Er, ot.prototype.copy.call(l, n), l.color.copy(n.color), this.cache.add(o, l)), n = l
                }
                if (i || r || s) {
                    let o = "ClonedMaterial:" + n.uuid + ":";
                    n.isGLTFSpecularGlossinessMaterial && (o += "specular-glossiness:"), i && (o += "derivative-tangents:"), r && (o += "vertex-colors:"), s && (o += "flat-shading:");
                    let l = this.cache.get(o);
                    l || (l = n.clone(), r && (l.vertexColors = !0), s && (l.flatShading = !0), i && (l.normalScale && (l.normalScale.y *= -1), l.clearcoatNormalScale && (l.clearcoatNormalScale.y *= -1)), this.cache.add(o, l), this.associations.set(l, this.associations.get(n))), n = l
                }
                n.aoMap && t.attributes.uv2 === void 0 && t.attributes.uv !== void 0 && t.setAttribute("uv2", t.attributes.uv), e.material = n
            }
            getMaterialType() {
                return ni
            }
            loadMaterial(e) {
                const t = this,
                    n = this.json,
                    i = this.extensions,
                    r = n.materials[e];
                let s;
                const o = {},
                    l = r.extensions || {},
                    c = [];
                if (l[Fe.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
                    const h = i[Fe.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
                    s = h.getMaterialType(), c.push(h.extendParams(o, r, t))
                } else if (l[Fe.KHR_MATERIALS_UNLIT]) {
                    const h = i[Fe.KHR_MATERIALS_UNLIT];
                    s = h.getMaterialType(), c.push(h.extendParams(o, r, t))
                } else {
                    const h = r.pbrMetallicRoughness || {};
                    if (o.color = new ne(1, 1, 1), o.opacity = 1, Array.isArray(h.baseColorFactor)) {
                        const f = h.baseColorFactor;
                        o.color.fromArray(f), o.opacity = f[3]
                    }
                    h.baseColorTexture !== void 0 && c.push(t.assignTexture(o, "map", h.baseColorTexture)), o.metalness = h.metallicFactor !== void 0 ? h.metallicFactor : 1, o.roughness = h.roughnessFactor !== void 0 ? h.roughnessFactor : 1, h.metallicRoughnessTexture !== void 0 && (c.push(t.assignTexture(o, "metalnessMap", h.metallicRoughnessTexture)), c.push(t.assignTexture(o, "roughnessMap", h.metallicRoughnessTexture))), s = this._invokeOne(function(f) {
                        return f.getMaterialType && f.getMaterialType(e)
                    }), c.push(Promise.all(this._invokeAll(function(f) {
                        return f.extendMaterialParams && f.extendMaterialParams(e, o)
                    })))
                }
                r.doubleSided === !0 && (o.side = vi);
                const u = r.alphaMode || oc.OPAQUE;
                if (u === oc.BLEND ? (o.transparent = !0, o.depthWrite = !1) : (o.format = yi, o.transparent = !1, u === oc.MASK && (o.alphaTest = r.alphaCutoff !== void 0 ? r.alphaCutoff : .5)), r.normalTexture !== void 0 && s !== un && (c.push(t.assignTexture(o, "normalMap", r.normalTexture)), o.normalScale = new X(1, 1), r.normalTexture.scale !== void 0)) {
                    const h = r.normalTexture.scale;
                    o.normalScale.set(h, h)
                }
                return r.occlusionTexture !== void 0 && s !== un && (c.push(t.assignTexture(o, "aoMap", r.occlusionTexture)), r.occlusionTexture.strength !== void 0 && (o.aoMapIntensity = r.occlusionTexture.strength)), r.emissiveFactor !== void 0 && s !== un && (o.emissive = new ne().fromArray(r.emissiveFactor)), r.emissiveTexture !== void 0 && s !== un && c.push(t.assignTexture(o, "emissiveMap", r.emissiveTexture)), Promise.all(c).then(function() {
                    let h;
                    return s === sc ? h = i[Fe.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(o) : h = new s(o), r.name && (h.name = r.name), h.map && (h.map.encoding = Ot), h.emissiveMap && (h.emissiveMap.encoding = Ot), Bi(h, r), t.associations.set(h, {
                        materials: e
                    }), r.extensions && Gs(i, h, r), h
                })
            }
            createUniqueName(e) {
                const t = Be.sanitizeNodeName(e || "");
                let n = t;
                for (let i = 1; this.nodeNamesUsed[n]; ++i) n = t + "_" + i;
                return this.nodeNamesUsed[n] = !0, n
            }
            loadGeometries(e) {
                const t = this,
                    n = this.extensions,
                    i = this.primitiveCache;

                function r(o) {
                    return n[Fe.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(o, t).then(function(l) {
                        return Sd(l, o, t)
                    })
                }
                const s = [];
                for (let o = 0, l = e.length; o < l; o++) {
                    const c = e[o],
                        u = I1(c),
                        h = i[u];
                    if (h) s.push(h.promise);
                    else {
                        let f;
                        c.extensions && c.extensions[Fe.KHR_DRACO_MESH_COMPRESSION] ? f = r(c) : f = Sd(new ke, c, t), i[u] = {
                            primitive: c,
                            promise: f
                        }, s.push(f)
                    }
                }
                return Promise.all(s)
            }
            loadMesh(e) {
                const t = this,
                    n = this.json,
                    i = this.extensions,
                    r = n.meshes[e],
                    s = r.primitives,
                    o = [];
                for (let l = 0, c = s.length; l < c; l++) {
                    const u = s[l].material === void 0 ? C1(this.cache) : this.getDependency("material", s[l].material);
                    o.push(u)
                }
                return o.push(t.loadGeometries(s)), Promise.all(o).then(function(l) {
                    const c = l.slice(0, l.length - 1),
                        u = l[l.length - 1],
                        h = [];
                    for (let d = 0, m = u.length; d < m; d++) {
                        const g = u[d],
                            v = s[d];
                        let p;
                        const _ = c[d];
                        if (v.mode === Fn.TRIANGLES || v.mode === Fn.TRIANGLE_STRIP || v.mode === Fn.TRIANGLE_FAN || v.mode === void 0) p = r.isSkinnedMesh === !0 ? new $o(g, _) : new Ge(g, _), p.isSkinnedMesh === !0 && !p.geometry.attributes.skinWeight.normalized && p.normalizeSkinWeights(), v.mode === Fn.TRIANGLE_STRIP ? p.geometry = Td(p.geometry, om) : v.mode === Fn.TRIANGLE_FAN && (p.geometry = Td(p.geometry, qc));
                        else if (v.mode === Fn.LINES) p = new Ca(g, _);
                        else if (v.mode === Fn.LINE_STRIP) p = new Ra(g, _);
                        else if (v.mode === Fn.LINE_LOOP) p = new vh(g, _);
                        else if (v.mode === Fn.POINTS) p = new yh(g, _);
                        else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + v.mode);
                        Object.keys(p.geometry.morphAttributes).length > 0 && D1(p, r), p.name = t.createUniqueName(r.name || "mesh_" + e), Bi(p, r), v.extensions && Gs(i, p, v), t.assignFinalMaterial(p), h.push(p)
                    }
                    for (let d = 0, m = h.length; d < m; d++) t.associations.set(h[d], {
                        meshes: e,
                        primitives: d
                    });
                    if (h.length === 1) return h[0];
                    const f = new Qn;
                    t.associations.set(f, {
                        meshes: e
                    });
                    for (let d = 0, m = h.length; d < m; d++) f.add(h[d]);
                    return f
                })
            }
            loadCamera(e) {
                let t;
                const n = this.json.cameras[e],
                    i = n[n.type];
                if (!i) {
                    console.warn("THREE.GLTFLoader: Missing camera parameters.");
                    return
                }
                return n.type === "perspective" ? t = new yt(go.radToDeg(i.yfov), i.aspectRatio || 1, i.znear || 1, i.zfar || 2e6) : n.type === "orthographic" && (t = new dr(-i.xmag, i.xmag, i.ymag, -i.ymag, i.znear, i.zfar)), n.name && (t.name = this.createUniqueName(n.name)), Bi(t, n), Promise.resolve(t)
            }
            loadSkin(e) {
                const t = this.json.skins[e],
                    n = {
                        joints: t.joints
                    };
                return t.inverseBindMatrices === void 0 ? Promise.resolve(n) : this.getDependency("accessor", t.inverseBindMatrices).then(function(i) {
                    return n.inverseBindMatrices = i, n
                })
            }
            loadAnimation(e) {
                const n = this.json.animations[e],
                    i = [],
                    r = [],
                    s = [],
                    o = [],
                    l = [];
                for (let c = 0, u = n.channels.length; c < u; c++) {
                    const h = n.channels[c],
                        f = n.samplers[h.sampler],
                        d = h.target,
                        m = d.node !== void 0 ? d.node : d.id,
                        g = n.parameters !== void 0 ? n.parameters[f.input] : f.input,
                        v = n.parameters !== void 0 ? n.parameters[f.output] : f.output;
                    i.push(this.getDependency("node", m)), r.push(this.getDependency("accessor", g)), s.push(this.getDependency("accessor", v)), o.push(f), l.push(d)
                }
                return Promise.all([Promise.all(i), Promise.all(r), Promise.all(s), Promise.all(o), Promise.all(l)]).then(function(c) {
                    const u = c[0],
                        h = c[1],
                        f = c[2],
                        d = c[3],
                        m = c[4],
                        g = [];
                    for (let p = 0, _ = u.length; p < _; p++) {
                        const M = u[p],
                            y = h[p],
                            b = f[p],
                            T = d[p],
                            x = m[p];
                        if (M === void 0) continue;
                        M.updateMatrix(), M.matrixAutoUpdate = !0;
                        let R;
                        switch (mi[x.path]) {
                            case mi.weights:
                                R = Ms;
                                break;
                            case mi.rotation:
                                R = Li;
                                break;
                            case mi.position:
                            case mi.scale:
                            default:
                                R = bs;
                                break
                        }
                        const P = M.name ? M.name : M.uuid,
                            I = T.interpolation !== void 0 ? R1[T.interpolation] : Yi,
                            L = [];
                        mi[x.path] === mi.weights ? M.traverse(function(D) {
                            D.isMesh === !0 && D.morphTargetInfluences && L.push(D.name ? D.name : D.uuid)
                        }) : L.push(P);
                        let Y = b.array;
                        if (b.normalized) {
                            const D = lc(Y.constructor),
                                F = new Float32Array(Y.length);
                            for (let N = 0, z = Y.length; N < z; N++) F[N] = Y[N] * D;
                            Y = F
                        }
                        for (let D = 0, F = L.length; D < F; D++) {
                            const N = new R(L[D] + "." + mi[x.path], y.array, Y, I);
                            T.interpolation === "CUBICSPLINE" && (N.createInterpolant = function(k) {
                                const J = this instanceof Li ? L1 : Ni;
                                return new J(this.times, this.values, this.getValueSize() / 3, k)
                            }, N.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0), g.push(N)
                        }
                    }
                    const v = n.name ? n.name : "animation_" + e;
                    return new pl(v, void 0, g)
                })
            }
            createNodeMesh(e) {
                const t = this.json,
                    n = this,
                    i = t.nodes[e];
                return i.mesh === void 0 ? null : n.getDependency("mesh", i.mesh).then(function(r) {
                    const s = n._getNodeRef(n.meshCache, i.mesh, r);
                    return i.weights !== void 0 && s.traverse(function(o) {
                        if (!!o.isMesh)
                            for (let l = 0, c = i.weights.length; l < c; l++) o.morphTargetInfluences[l] = i.weights[l]
                    }), s
                })
            }
            loadNode(e) {
                const t = this.json,
                    n = this.extensions,
                    i = this,
                    r = t.nodes[e],
                    s = r.name ? i.createUniqueName(r.name) : "";
                return function() {
                    const o = [],
                        l = i._invokeOne(function(c) {
                            return c.createNodeMesh && c.createNodeMesh(e)
                        });
                    return l && o.push(l), r.camera !== void 0 && o.push(i.getDependency("camera", r.camera).then(function(c) {
                        return i._getNodeRef(i.cameraCache, r.camera, c)
                    })), i._invokeAll(function(c) {
                        return c.createNodeAttachment && c.createNodeAttachment(e)
                    }).forEach(function(c) {
                        o.push(c)
                    }), Promise.all(o)
                }().then(function(o) {
                    let l;
                    if (r.isBone === !0 ? l = new Ko : o.length > 1 ? l = new Qn : o.length === 1 ? l = o[0] : l = new Te, l !== o[0])
                        for (let c = 0, u = o.length; c < u; c++) l.add(o[c]);
                    if (r.name && (l.userData.name = r.name, l.name = s), Bi(l, r), r.extensions && Gs(n, l, r), r.matrix !== void 0) {
                        const c = new fe;
                        c.fromArray(r.matrix), l.applyMatrix4(c)
                    } else r.translation !== void 0 && l.position.fromArray(r.translation), r.rotation !== void 0 && l.quaternion.fromArray(r.rotation), r.scale !== void 0 && l.scale.fromArray(r.scale);
                    return i.associations.has(l) || i.associations.set(l, {}), i.associations.get(l).nodes = e, l
                })
            }
            loadScene(e) {
                const t = this.json,
                    n = this.extensions,
                    i = this.json.scenes[e],
                    r = this,
                    s = new Qn;
                i.name && (s.name = r.createUniqueName(i.name)), Bi(s, i), i.extensions && Gs(n, s, i);
                const o = i.nodes || [],
                    l = [];
                for (let c = 0, u = o.length; c < u; c++) l.push(wd(o[c], s, t, r));
                return Promise.all(l).then(function() {
                    const c = u => {
                        const h = new Map;
                        for (const [f, d] of r.associations)(f instanceof ot || f instanceof at) && h.set(f, d);
                        return u.traverse(f => {
                            const d = r.associations.get(f);
                            d != null && h.set(f, d)
                        }), h
                    };
                    return r.associations = c(s), s
                })
            }
        }

        function wd(a, e, t, n) {
            const i = t.nodes[a];
            return n.getDependency("node", a).then(function(r) {
                if (i.skin === void 0) return r;
                let s;
                return n.getDependency("skin", i.skin).then(function(o) {
                    s = o;
                    const l = [];
                    for (let c = 0, u = s.joints.length; c < u; c++) l.push(n.getDependency("node", s.joints[c]));
                    return Promise.all(l)
                }).then(function(o) {
                    return r.traverse(function(l) {
                        if (!l.isMesh) return;
                        const c = [],
                            u = [];
                        for (let h = 0, f = o.length; h < f; h++) {
                            const d = o[h];
                            if (d) {
                                c.push(d);
                                const m = new fe;
                                s.inverseBindMatrices !== void 0 && m.fromArray(s.inverseBindMatrices.array, h * 16), u.push(m)
                            } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', s.joints[h])
                        }
                        l.bind(new Qo(c, u), l.matrixWorld)
                    }), r
                })
            }).then(function(r) {
                e.add(r);
                const s = [];
                if (i.children) {
                    const o = i.children;
                    for (let l = 0, c = o.length; l < c; l++) {
                        const u = o[l];
                        s.push(wd(u, r, t, n))
                    }
                }
                return Promise.all(s)
            })
        }

        function z1(a, e, t) {
            const n = e.attributes,
                i = new jt;
            if (n.POSITION !== void 0) {
                const o = t.json.accessors[n.POSITION],
                    l = o.min,
                    c = o.max;
                if (l !== void 0 && c !== void 0) {
                    if (i.set(new E(l[0], l[1], l[2]), new E(c[0], c[1], c[2])), o.normalized) {
                        const u = lc(ks[o.componentType]);
                        i.min.multiplyScalar(u), i.max.multiplyScalar(u)
                    }
                } else {
                    console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
                    return
                }
            } else return;
            const r = e.targets;
            if (r !== void 0) {
                const o = new E,
                    l = new E;
                for (let c = 0, u = r.length; c < u; c++) {
                    const h = r[c];
                    if (h.POSITION !== void 0) {
                        const f = t.json.accessors[h.POSITION],
                            d = f.min,
                            m = f.max;
                        if (d !== void 0 && m !== void 0) {
                            if (l.setX(Math.max(Math.abs(d[0]), Math.abs(m[0]))), l.setY(Math.max(Math.abs(d[1]), Math.abs(m[1]))), l.setZ(Math.max(Math.abs(d[2]), Math.abs(m[2]))), f.normalized) {
                                const g = lc(ks[f.componentType]);
                                l.multiplyScalar(g)
                            }
                            o.max(l)
                        } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
                    }
                }
                i.expandByVector(o)
            }
            a.boundingBox = i;
            const s = new Ti;
            i.getCenter(s.center), s.radius = i.min.distanceTo(i.max) / 2, a.boundingSphere = s
        }

        function Sd(a, e, t) {
            const n = e.attributes,
                i = [];

            function r(s, o) {
                return t.getDependency("accessor", s).then(function(l) {
                    a.setAttribute(o, l)
                })
            }
            for (const s in n) {
                const o = ac[s] || s.toLowerCase();
                o in a.attributes || i.push(r(n[s], o))
            }
            if (e.indices !== void 0 && !a.index) {
                const s = t.getDependency("accessor", e.indices).then(function(o) {
                    a.setIndex(o)
                });
                i.push(s)
            }
            return Bi(a, e), z1(a, e, t), Promise.all(i).then(function() {
                return e.targets !== void 0 ? P1(a, e.targets, t) : a
            })
        }

        function Td(a, e) {
            let t = a.getIndex();
            if (t === null) {
                const s = [],
                    o = a.getAttribute("position");
                if (o !== void 0) {
                    for (let l = 0; l < o.count; l++) s.push(l);
                    a.setIndex(s), t = a.getIndex()
                } else return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), a
            }
            const n = t.count - 2,
                i = [];
            if (e === qc)
                for (let s = 1; s <= n; s++) i.push(t.getX(0)), i.push(t.getX(s)), i.push(t.getX(s + 1));
            else
                for (let s = 0; s < n; s++) s % 2 == 0 ? (i.push(t.getX(s)), i.push(t.getX(s + 1)), i.push(t.getX(s + 2))) : (i.push(t.getX(s + 2)), i.push(t.getX(s + 1)), i.push(t.getX(s)));
            i.length / 3 !== n && console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
            const r = a.clone();
            return r.setIndex(i), r
        }
        const Hs = new E;

        function tn(a, e, t, n, i, r) {
            const s = 2 * Math.PI * i / 4,
                o = Math.max(r - 2 * i, 0),
                l = Math.PI / 4;
            Hs.copy(e), Hs[n] = 0, Hs.normalize();
            const c = .5 * s / (s + o),
                u = 1 - Hs.angleTo(a) / l;
            return Math.sign(Hs[t]) === 1 ? u * c : o / (s + o) + c + c * (1 - u)
        }
        class N1 extends Yn {
            constructor(e = 1, t = 1, n = 1, i = 2, r = .1) {
                i = i * 2 + 1, r = Math.min(e / 2, t / 2, n / 2, r);
                super(1, 1, 1, i, i, i);
                if (i === 1) return;
                const s = this.toNonIndexed();
                this.index = null, this.attributes.position = s.attributes.position, this.attributes.normal = s.attributes.normal, this.attributes.uv = s.attributes.uv;
                const o = new E,
                    l = new E,
                    c = new E(e, t, n).divideScalar(2).subScalar(r),
                    u = this.attributes.position.array,
                    h = this.attributes.normal.array,
                    f = this.attributes.uv.array,
                    d = u.length / 6,
                    m = new E,
                    g = .5 / i;
                for (let v = 0, p = 0; v < u.length; v += 3, p += 2) switch (o.fromArray(u, v), l.copy(o), l.x -= Math.sign(l.x) * g, l.y -= Math.sign(l.y) * g, l.z -= Math.sign(l.z) * g, l.normalize(), u[v + 0] = c.x * Math.sign(o.x) + l.x * r, u[v + 1] = c.y * Math.sign(o.y) + l.y * r, u[v + 2] = c.z * Math.sign(o.z) + l.z * r, h[v + 0] = l.x, h[v + 1] = l.y, h[v + 2] = l.z, Math.floor(v / d)) {
                    case 0:
                        m.set(1, 0, 0), f[p + 0] = tn(m, l, "z", "y", r, n), f[p + 1] = 1 - tn(m, l, "y", "z", r, t);
                        break;
                    case 1:
                        m.set(-1, 0, 0), f[p + 0] = 1 - tn(m, l, "z", "y", r, n), f[p + 1] = 1 - tn(m, l, "y", "z", r, t);
                        break;
                    case 2:
                        m.set(0, 1, 0), f[p + 0] = 1 - tn(m, l, "x", "z", r, e), f[p + 1] = tn(m, l, "z", "x", r, n);
                        break;
                    case 3:
                        m.set(0, -1, 0), f[p + 0] = 1 - tn(m, l, "x", "z", r, e), f[p + 1] = 1 - tn(m, l, "z", "x", r, n);
                        break;
                    case 4:
                        m.set(0, 0, 1), f[p + 0] = 1 - tn(m, l, "x", "y", r, e), f[p + 1] = 1 - tn(m, l, "y", "x", r, t);
                        break;
                    case 5:
                        m.set(0, 0, -1), f[p + 0] = tn(m, l, "x", "y", r, e), f[p + 1] = 1 - tn(m, l, "y", "x", r, t);
                        break
                }
            }
        }

        function Qa(a, e, t, n, i) {
            return a < e ? n : a > t ? i : (a - e) / (t - e) * (i - n) + n
        }
        var wt;
        (function(a) {
            a[a.a0 = 1] = "a0", a[a.a1 = 2] = "a1", a[a.a2 = 3] = "a2"
        })(wt || (wt = {}));
        const ln = new gl,
            Ed = new un({
                color: "black"
            });
        var B1 = "struct q90{vec3 position;vec3 color;float distance;float decay;};uniform q90 l75[f74];uniform float d76;uniform float n77;uniform float c7;uniform float g78;void main(){",
            O1 = `#include <lights_fragment_begin>
vec3 k91=vec3(1.0,1.0,1.0);vec3 o92=k91*0.5;vec3 e93=geometry.normal;vec3 p94=normalize(geometry.viewDir);float y95=0.75;float w96=1.0;
#if (f74 > 0) && defined(RE_Direct)
for(int d97=0;d97<f74;++d97){q90 q98=l75[d97];vec3 j99=q98.position-geometry.position;vec3 o100=normalize(j99);float g101=length(j99);float g102=getDistanceAttenuation(g101,q98.distance,q98.decay);vec3 b103=normalize(o100+(e93*c7));float w104=pow(saturate(dot(p94,-b103)),d76)*n77;vec3 q105=g102*(w104+g78)*o92;reflectedLight.directDiffuse+=material.diffuseColor*q98.color*q105;}
#endif
`;
        const pc = class extends Te {
            constructor(e) {
                super();
                ee(this, "a1");
                ee(this, "a2");
                ee(this, "a3");
                ee(this, "a4");
                ee(this, "a5");
                ee(this, "a6");
                ee(this, "a7");
                ee(this, "a8");
                ee(this, "a9");
                ee(this, "a10");
                ee(this, "a11");
                if (pc.a0++) throw new Error;
                this.a1 = 0;
                const t = new N1(1.8, 1, 1, 1);
                this.a6 = new ni({
                    envMapIntensity: .1,
                    roughness: 0,
                    metalness: 0,
                    defines: {
                        f74: 1
                    }
                }), this.a7 = {
                    l75: {
                        value: [{
                            color: new ne,
                            position: new E,
                            distance: 0,
                            decay: 1
                        }]
                    },
                    d76: {
                        value: 2.7,
                        min: 0,
                        max: 10
                    },
                    n77: {
                        value: 1.06,
                        min: 0,
                        max: 5
                    },
                    c7: {
                        value: .19,
                        min: 0,
                        max: 1
                    },
                    g78: {
                        value: .1,
                        min: 0,
                        max: 1
                    }
                }, this.a6.onBeforeCompile = n => {
                    Object.assign(n.uniforms, this.a7), n.fragmentShader = n.fragmentShader.replace("void main() {", B1).replace("#include <lights_fragment_begin>", O1)
                }, this.a2 = new Ge(t, this.a6), this.a2.layers.enable(wt.a1), this.add(this.a2), this.a3 = this.a2.clone(), this.a3.layers.enable(wt.a1), this.a3.rotation.z = Math.PI / 2, this.add(this.a3), this.a4 = this.a2.clone(), this.a4.layers.enable(wt.a1), this.a4.rotation.y = Math.PI / 2, this.add(this.a4), this.a8 = new Ss("cyan", 0), this.add(this.a8), this.a2.onBeforeRender = (n, i, r) => {
                    const s = this.a7.l75.value[0];
                    s.color.copy(this.a8.color).multiplyScalar(this.a8.intensity), s.position.setFromMatrixPosition(this.a8.matrixWorld), s.position.applyMatrix4(r.matrixWorldInverse)
                }, this.scale.set(.7, .7, .7), this.position.y = 10.7, this.matrixAutoUpdate = !1, this.a9 = 1, this.a10 = 0, this.a11 = 0, this.a5 = new fe
            }
            a12(e) {
                this.a1 += e, this.rotation.y += e * this.a9, this.rotation.z += e * this.a9;
                const t = this.a5.compose(this.position, this.quaternion, this.scale);
                this.matrix.makeShear(Math.sin(this.a1) * this.a10, 0, 0, 0, 0, Math.cos(this.a1 * .5) * .7 * this.a10).multiply(t), this.a2.position.x = Math.sin(this.a1 * 2) * .1 * this.a11, this.a3.position.y = Math.cos(this.a1 * 4) * .1 * this.a11, this.a4.position.z = Math.cos(this.a1 * 2) * .1 * this.a11
            }
        };
        let cc = pc;
        ee(cc, "a0", 0);
        var U1 = "uniform float j0;uniform float k12;uniform float u79;uniform vec2 t80;uniform float f81;uniform float e82;uniform float c11;uniform float v83;uniform float f84;uniform float t85;varying float c106;varying float j107;vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x,289.0);}vec4 taylorInvSqrt(vec4 r){return 1.79284291400159-0.85373472095314*r;}vec3 fade(vec3 t){return t*t*t*(t*(t*6.0-15.0)+10.0);}float cnoise(vec3 P){vec3 Pi0=floor(P);vec3 Pi1=Pi0+vec3(1.0);Pi0=mod(Pi0,289.0);Pi1=mod(Pi1,289.0);vec3 Pf0=fract(P);vec3 Pf1=Pf0-vec3(1.0);vec4 ix=vec4(Pi0.x,Pi1.x,Pi0.x,Pi1.x);vec4 iy=vec4(Pi0.yy,Pi1.yy);vec4 iz0=Pi0.zzzz;vec4 iz1=Pi1.zzzz;vec4 ixy=permute(permute(ix)+iy);vec4 ixy0=permute(ixy+iz0);vec4 ixy1=permute(ixy+iz1);vec4 gx0=ixy0/7.0;vec4 gy0=fract(floor(gx0)/7.0)-0.5;gx0=fract(gx0);vec4 gz0=vec4(0.5)-abs(gx0)-abs(gy0);vec4 sz0=step(gz0,vec4(0.0));gx0-=sz0*(step(0.0,gx0)-0.5);gy0-=sz0*(step(0.0,gy0)-0.5);vec4 gx1=ixy1/7.0;vec4 gy1=fract(floor(gx1)/7.0)-0.5;gx1=fract(gx1);vec4 gz1=vec4(0.5)-abs(gx1)-abs(gy1);vec4 sz1=step(gz1,vec4(0.0));gx1-=sz1*(step(0.0,gx1)-0.5);gy1-=sz1*(step(0.0,gy1)-0.5);vec3 g000=vec3(gx0.x,gy0.x,gz0.x);vec3 g100=vec3(gx0.y,gy0.y,gz0.y);vec3 g010=vec3(gx0.z,gy0.z,gz0.z);vec3 g110=vec3(gx0.w,gy0.w,gz0.w);vec3 g001=vec3(gx1.x,gy1.x,gz1.x);vec3 g101=vec3(gx1.y,gy1.y,gz1.y);vec3 g011=vec3(gx1.z,gy1.z,gz1.z);vec3 g111=vec3(gx1.w,gy1.w,gz1.w);vec4 norm0=taylorInvSqrt(vec4(dot(g000,g000),dot(g010,g010),dot(g100,g100),dot(g110,g110)));g000*=norm0.x;g010*=norm0.y;g100*=norm0.z;g110*=norm0.w;vec4 norm1=taylorInvSqrt(vec4(dot(g001,g001),dot(g011,g011),dot(g101,g101),dot(g111,g111)));g001*=norm1.x;g011*=norm1.y;g101*=norm1.z;g111*=norm1.w;float n000=dot(g000,Pf0);float n100=dot(g100,vec3(Pf1.x,Pf0.yz));float n010=dot(g010,vec3(Pf0.x,Pf1.y,Pf0.z));float n110=dot(g110,vec3(Pf1.xy,Pf0.z));float n001=dot(g001,vec3(Pf0.xy,Pf1.z));float n101=dot(g101,vec3(Pf1.x,Pf0.y,Pf1.z));float n011=dot(g011,vec3(Pf0.x,Pf1.yz));float n111=dot(g111,Pf1);vec3 fade_xyz=fade(Pf0);vec4 n_z=mix(vec4(n000,n100,n010,n110),vec4(n001,n101,n011,n111),fade_xyz.z);vec2 n_yz=mix(n_z.xy,n_z.zw,fade_xyz.y);float n_xyz=mix(n_yz.x,n_yz.y,fade_xyz.x);return 2.2*n_xyz;}struct e108{vec3 i37;vec3 k45;};e108 x109(vec2 y47){float r24=mix(k12,k12*0.9,y47.y);float f110=r24*cos(PI*y47.x);float b111=-r24*sin(PI*y47.x);float g112=y47.y*u79-u79*0.5;vec3 i37=vec3(f110,g112,b111);vec3 k45=normalize(i37-vec3(0.0,g112,0.0));e108 e57;e57.i37=i37;e57.k45=k45;return e57;}float a113(vec2 y47){vec2 l114=y47+t80;float t67=cnoise(vec3(l114,j0*f81)*e82);float z115=abs(fract(t67*v83)-0.5);float b116=smoothstep(0.0,0.2,uv.y)*(1.0-smoothstep(0.8,1.0,uv.y));return smoothstep(0.0,f84,z115)*c11*b116;}void main(){",
            k1 = `#include <displacementmap_vertex>
e108 e57=x109(uv);float b117=a113(uv);c106=b117/c11;j107=clamp(1.0-c106,0.0,0.8);vec3 d118=e57.i37+e57.k45*b117;transformed=d118;vec2 y119=uv+vec2(t85,0.0);e108 p120=x109(y119);vec3 x121=p120.i37+p120.k45*a113(y119);vec2 e122=uv+vec2(0.0,t85);e108 u123=x109(e122);vec3 u124=u123.i37+u123.k45*a113(e122);vec3 r125=x121-d118;vec3 e126=u124-d118;vNormal=normalMatrix*normalize(cross(r125,e126));`,
            G1 = "struct q90{vec3 position;vec3 color;float distance;float decay;};uniform float j0;uniform vec2 resolution;uniform q90 l75[f74];uniform float d76;uniform float n77;uniform float c7;uniform float g78;uniform sampler2D a86;uniform float k87;uniform float p88;uniform float d89;varying float c106;varying float j107;vec2 d127(){vec2 n128=dFdx(vUv);vec2 q129=dFdy(vUv);vec3 p130=dFdx(-vViewPosition);vec3 a131=dFdy(-vViewPosition);vec3 t132=cross(a131,vNormal);vec3 b133=cross(vNormal,p130);float u134=dot(p130,t132);vec2 l135=(1.0/u134)*vec2(dot(t132,vViewPosition),dot(b133,vViewPosition));vec3 y136;y136.xy=n128*l135.x+q129*l135.y;y136.z=dot(vNormal,vViewPosition);return k87*y136.xy/y136.z;}float i137(){const int r138=10;vec2 b117=d127();float s139=1.0/float(r138);float e140=0.0;vec2 b141=b117/float(r138);vec2 x142=vUv+p88*b117;float j143=texture2D(a86,x142).r;for(int d97=0;d97<r138;d97++){if(e140>j143)break;x142-=b141;j143=texture2D(a86,x142).r;e140+=s139;}vec2 t144=x142+b141;float k145=j143-e140;float d146=texture2D(a86,t144).r-e140+s139;float g147=k145/(k145-d146);vec2 n148=mix(x142,t144,g147);return texture2D(a86,n148).r*d89;}void main(){",
            H1 = `#include <lights_fragment_begin>
float d149=i137();vec3 k91=vec3(1.0,1.0,1.0);vec3 o92=k91*j107-d149;vec3 e93=geometry.normal;vec3 p94=normalize(geometry.viewDir);float y95=0.75;float w96=1.0;
#if (f74 > 0) && defined(RE_Direct)
for(int d97=0;d97<f74;++d97){q90 q98=l75[d97];vec3 j99=q98.position-geometry.position;vec3 o100=normalize(j99);float g101=length(j99);float g102=getDistanceAttenuation(g101,q98.distance,q98.decay);vec3 b103=normalize(o100+(e93*c7));float w104=pow(saturate(dot(p94,-b103)),d76)*n77;vec3 q105=g102*(w104+g78)*o92;reflectedLight.directDiffuse+=material.diffuseColor*q98.color*q105;}
#endif
`,
            V1 = `#include <roughnessmap_fragment>
`,
            W1 = `#include <output_fragment>
outgoingLight=reflectedLight.directDiffuse+reflectedLight.indirectDiffuse+reflectedLight.directSpecular+reflectedLight.indirectSpecular+totalEmissiveRadiance;gl_FragColor=vec4(outgoingLight,diffuseColor.a);`;
        const mc = class extends Te {
            constructor(e) {
                super();
                ee(this, "a1");
                ee(this, "a2");
                ee(this, "a3");
                ee(this, "a4");
                ee(this, "a5");
                var i;
                if (mc.a0++) throw new Error;
                const t = new Zn(1, 1, 200, 200);
                this.a1 = {
                    j0: {
                        value: 0,
                        ignore: !0
                    },
                    k12: {
                        value: 4.4,
                        ignore: !0
                    },
                    u79: {
                        value: 12.5,
                        ignore: !0
                    },
                    t80: {
                        value: new X(0, 0),
                        min: 0,
                        max: Math.PI * 2
                    },
                    f81: {
                        value: .1,
                        min: 0,
                        max: 1
                    },
                    e82: {
                        value: 1.6,
                        min: 0,
                        max: 4
                    },
                    c11: {
                        value: .2,
                        min: -1,
                        max: 1
                    },
                    v83: {
                        value: 5,
                        min: 0,
                        max: 30
                    },
                    f84: {
                        value: .85,
                        min: 0,
                        max: 2
                    },
                    t85: {
                        value: .011,
                        min: 0,
                        max: .3
                    },
                    l75: {
                        value: Array.from(Array(2)).map(() => ({
                            color: new ne,
                            position: new E,
                            distance: 0,
                            decay: 1
                        }))
                    },
                    d76: {
                        value: 40,
                        min: 0,
                        max: 100
                    },
                    n77: {
                        value: 4,
                        min: 0,
                        max: 10
                    },
                    c7: {
                        value: .185,
                        min: 0,
                        max: 1
                    },
                    g78: {
                        value: 0,
                        min: 0,
                        max: 1
                    },
                    a86: {
                        value: (e == null ? void 0 : e.parallaxMapUrl) ? ln.load(e.parallaxMapUrl) : null
                    },
                    k87: {
                        value: .327,
                        min: 0,
                        max: 10
                    },
                    p88: {
                        value: .3,
                        min: -1,
                        max: 1
                    },
                    d89: {
                        value: .4,
                        min: 0,
                        max: 1
                    }
                }, this.a2 = new ni({
                    envMapIntensity: .2,
                    roughness: 10,
                    metalness: 0,
                    roughnessMap: (e == null ? void 0 : e.roughnessMapUrl) ? ln.load(e.roughnessMapUrl) : null,
                    normalMap: (e == null ? void 0 : e.normalMapUrl) ? ln.load(e.normalMapUrl) : null,
                    defines: {
                        USE_UV: !(e == null ? void 0 : e.roughnessMapUrl) && !(e == null ? void 0 : e.normalMapUrl),
                        f74: 2
                    }
                }), this.a2.onBeforeCompile = r => {
                    Object.assign(r.uniforms, this.a1), r.vertexShader = r.vertexShader.replace("void main() {", U1).replace("#include <displacementmap_vertex>", k1), r.fragmentShader = r.fragmentShader.replace("void main() {", G1).replace("#include <lights_fragment_begin>", H1).replace("#include <roughnessmap_fragment>", V1).replace("#include <output_fragment>", W1)
                };
                const n = new Ge(t, this.a2);
                this.position.y = -4.3, this.rotation.y = Math.PI, n.layers.enable(wt.a1), this.add(n), n.geometry.computeBoundingSphere(), (i = n.geometry.boundingSphere) == null || i.set(new E(0, 0, 0), Math.max(this.a1.k12.value, this.a1.u79.value / 2)), this.a3 = new Ss("cyan", 1), this.a3.position.z = 20, this.a3.visible = !1, this.add(this.a3), this.a4 = new Ss("yellow", 1), this.a4.position.z = 5, this.a4.visible = !1, this.add(this.a4), n.onBeforeRender = (r, s, o) => {
                    const [l, c] = this.a1.l75.value;
                    l.color.copy(this.a3.color).multiplyScalar(this.a3.intensity), l.position.setFromMatrixPosition(this.a3.matrixWorld), l.position.applyMatrix4(o.matrixWorldInverse), c.color.copy(this.a4.color).multiplyScalar(this.a4.intensity), c.position.setFromMatrixPosition(this.a4.matrixWorld), c.position.applyMatrix4(o.matrixWorldInverse)
                }, this.a5 = 0
            }
            a6(e) {
                this.a1.t80.value.x += e * .2 * this.a5, this.a1.t80.value.x > 2 * Math.PI && (this.a1.t80.value.x = 0), this.a1.j0.value += e
            }
        };
        let uc = mc;
        ee(uc, "a0", 0);
        const nn = class extends Te {
            constructor(e, t) {
                if (!nn.a3) throw new Error;
                super();
                ee(this, "a7");
                ee(this, "a8");
                ee(this, "a9");
                ee(this, "a10", null);
                ee(this, "a11", 0);
                ee(this, "a12", 0);
                ee(this, "a13", 20);
                ee(this, "a14");
                this.a14 = t, this.a9 = new Te, this.add(this.a9), e.updateMatrix(), this.a9.applyMatrix4(e.matrix), e.position.set(0, 0, 0), e.rotation.set(0, 0, 0), e.geometry.computeBoundingBox();
                const n = e.geometry.boundingBox;
                this.a9.add(this.a15(n)), nn.a5 && e.geometry.setAttribute("uv2", e.geometry.attributes.uv.clone()), this.a7 = nn.a1.clone(), e.material = this.a7, e.layers.enable(wt.a1), this.a9.add(e), this.a8 = 0
            }
            static a6(e) {
                if (nn.a3) throw new Error;
                this.a3 = !0, this.a5 = !!(e == null ? void 0 : e.aoMapUrl), nn.a1 = new ni({
                    envMapIntensity: .2,
                    map: (e == null ? void 0 : e.diffuseMapUrl) ? ln.load(e.diffuseMapUrl) : null,
                    roughnessMap: (e == null ? void 0 : e.roughnessMapUrl) ? ln.load(e.roughnessMapUrl) : null,
                    normalMap: (e == null ? void 0 : e.normalMapUrl) ? ln.load(e.normalMapUrl) : null,
                    normalMapType: kn,
                    aoMap: (e == null ? void 0 : e.aoMapUrl) ? ln.load(e.aoMapUrl) : null,
                    aoMapIntensity: .5,
                    emissiveMap: (e == null ? void 0 : e.emissiveMapUrl) ? ln.load(e.emissiveMapUrl) : null,
                    emissive: "cyan",
                    emissiveIntensity: 0
                }), nn.a2 = new Ge(new Yn(1, 1, 1), Ed), nn.a2.visible = !1, nn.a2.layers.enable(wt.a0), nn.a4 = (e == null ? void 0 : e.debug) || !1
            }
            a15(e) {
                const t = nn.a2.clone();
                t.userData.totemPart = this;
                const n = new E;
                return e.getSize(n), t.scale.copy(n), e.getCenter(n), t.position.copy(n), t
            }
            a16(e) {
                this.a11 += e / this.a13
            }
            a17(e, t) {
                this.a7.emissiveIntensity = Qa(Math.sin((t + this.a14) * 2), -1, 1, .2, 1) * this.a8, this.a10 != null && this.a16((this.a10 - this.rotation.y) * .1), this.a12 += this.a11, this.rotation.y += this.a12, this.a12 *= .95, this.a11 = 0
            }
        };
        let zn = nn;
        ee(zn, "a0", 0), ee(zn, "a1"), ee(zn, "a2"), ee(zn, "a3"), ee(zn, "a4"), ee(zn, "a5");
        class q1 extends Te {
            constructor(e) {
                super();
                ee(this, "a0");
                ee(this, "a1");
                ee(this, "a2");
                ee(this, "a3", []);
                this.a0 = new Te, this.add(this.a0), this.a1 = new cc(e.brain), this.a0.add(this.a1), this.a2 = new uc(e.core), this.a0.add(this.a2), new u1().load(e.modelUrl, t => {
                    zn.a6(e.parts);
                    const n = t.scene.children.sort((i, r) => i.name < r.name ? -1 : i.name > r.name ? 1 : 0).reverse();
                    for (let i = n.length - 1; i >= 0; --i) {
                        const r = n[i];
                        if (!(r instanceof Ge)) continue;
                        const s = new zn(r, Math.random() * 1e4);
                        this.a3.push(s), this.a0.add(s)
                    }
                    this.dispatchEvent({
                        type: "ready"
                    })
                })
            }
            a4(e, t) {
                this.a0.position.y = Math.sin(t) * .5, this.a0.position.x = Math.sin(t * .4) * .2, this.a1.a12(e), this.a2.a6(e), this.a3.forEach(n => n.a17(e, t))
            }
        }
        var X1 = "attribute vec3 position;attribute vec2 uv;uniform float j0;uniform vec3 y32;uniform vec3 k33;uniform vec3 c34;uniform vec3 j35;varying vec3 g66;vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x,289.0);}vec4 taylorInvSqrt(vec4 r){return 1.79284291400159-0.85373472095314*r;}vec3 fade(vec3 t){return t*t*t*(t*(t*6.0-15.0)+10.0);}float cnoise(vec3 P){vec3 Pi0=floor(P);vec3 Pi1=Pi0+vec3(1.0);Pi0=mod(Pi0,289.0);Pi1=mod(Pi1,289.0);vec3 Pf0=fract(P);vec3 Pf1=Pf0-vec3(1.0);vec4 ix=vec4(Pi0.x,Pi1.x,Pi0.x,Pi1.x);vec4 iy=vec4(Pi0.yy,Pi1.yy);vec4 iz0=Pi0.zzzz;vec4 iz1=Pi1.zzzz;vec4 ixy=permute(permute(ix)+iy);vec4 ixy0=permute(ixy+iz0);vec4 ixy1=permute(ixy+iz1);vec4 gx0=ixy0/7.0;vec4 gy0=fract(floor(gx0)/7.0)-0.5;gx0=fract(gx0);vec4 gz0=vec4(0.5)-abs(gx0)-abs(gy0);vec4 sz0=step(gz0,vec4(0.0));gx0-=sz0*(step(0.0,gx0)-0.5);gy0-=sz0*(step(0.0,gy0)-0.5);vec4 gx1=ixy1/7.0;vec4 gy1=fract(floor(gx1)/7.0)-0.5;gx1=fract(gx1);vec4 gz1=vec4(0.5)-abs(gx1)-abs(gy1);vec4 sz1=step(gz1,vec4(0.0));gx1-=sz1*(step(0.0,gx1)-0.5);gy1-=sz1*(step(0.0,gy1)-0.5);vec3 g000=vec3(gx0.x,gy0.x,gz0.x);vec3 g100=vec3(gx0.y,gy0.y,gz0.y);vec3 g010=vec3(gx0.z,gy0.z,gz0.z);vec3 g110=vec3(gx0.w,gy0.w,gz0.w);vec3 g001=vec3(gx1.x,gy1.x,gz1.x);vec3 g101=vec3(gx1.y,gy1.y,gz1.y);vec3 g011=vec3(gx1.z,gy1.z,gz1.z);vec3 g111=vec3(gx1.w,gy1.w,gz1.w);vec4 norm0=taylorInvSqrt(vec4(dot(g000,g000),dot(g010,g010),dot(g100,g100),dot(g110,g110)));g000*=norm0.x;g010*=norm0.y;g100*=norm0.z;g110*=norm0.w;vec4 norm1=taylorInvSqrt(vec4(dot(g001,g001),dot(g011,g011),dot(g101,g101),dot(g111,g111)));g001*=norm1.x;g011*=norm1.y;g101*=norm1.z;g111*=norm1.w;float n000=dot(g000,Pf0);float n100=dot(g100,vec3(Pf1.x,Pf0.yz));float n010=dot(g010,vec3(Pf0.x,Pf1.y,Pf0.z));float n110=dot(g110,vec3(Pf1.xy,Pf0.z));float n001=dot(g001,vec3(Pf0.xy,Pf1.z));float n101=dot(g101,vec3(Pf1.x,Pf0.y,Pf1.z));float n011=dot(g011,vec3(Pf0.x,Pf1.yz));float n111=dot(g111,Pf1);vec3 fade_xyz=fade(Pf0);vec4 n_z=mix(vec4(n000,n100,n010,n110),vec4(n001,n101,n011,n111),fade_xyz.z);vec2 n_yz=mix(n_z.xy,n_z.zw,fade_xyz.y);float n_xyz=mix(n_yz.x,n_yz.y,fade_xyz.x);return 2.2*n_xyz;}void main(){float t67=cnoise(vec3((uv+j0*0.1)*vec2(1.0,4.0),j0));t67*=smoothstep(0.0,0.2,uv.y)*(1.0-smoothstep(0.8,1.0,uv.y));t67*=0.5;vec3 v68=position;v68.y+=t67;v68.z-=uv.y;gl_Position=vec4(v68,1.0);float e69=cnoise(vec3(uv.y*4.0,j0,uv.x*0.5));float l70=cnoise(vec3(j0*0.5,uv*1.5));float b71=cnoise(vec3(uv.x*0.9,j0,uv.y*2.0));g66=y32;g66=mix(g66,k33,e69);g66=mix(g66,c34,l70);g66=mix(g66,j35,b71);}",
            j1 = "precision mediump float;uniform float z5;varying vec3 g66;void main(){gl_FragColor=vec4(g66,1.0)*z5;}";
        const gc = class extends Te {
            constructor(e) {
                super();
                ee(this, "a1");
                if (gc.a0++) throw new Error;
                const t = new Zn(2, 2, 40, 40);
                this.a1 = {
                    j0: {
                        value: 0,
                        ignore: !0
                    },
                    y32: {
                        value: new ne(15455187)
                    },
                    k33: {
                        value: new ne(3465656)
                    },
                    c34: {
                        value: new ne(16777215)
                    },
                    j35: {
                        value: new ne(724547)
                    },
                    z5: {
                        value: .3,
                        min: 0,
                        max: 1
                    }
                };
                const n = new An({
                        vertexShader: X1,
                        fragmentShader: j1,
                        uniforms: this.a1,
                        depthTest: !1
                    }),
                    i = new Ge(t, n);
                i.frustumCulled = !1, i.scale.set(20, 20, 20), i.layers.enable(wt.a2), i.renderOrder = -1, this.add(i)
            }
            a2(e) {
                this.a1.j0.value += e * .2
            }
        };
        let hc = gc;
        ee(hc, "a0", 0);
        var Y1 = "precision mediump float;attribute vec3 position;attribute vec2 uv;attribute vec3 offset;attribute vec2 uvOffset;attribute float scale;uniform mat4 projectionMatrix;uniform mat4 modelViewMatrix;uniform mat4 modelMatrix;uniform vec3 cameraPosition;uniform vec3 g10;varying vec2 w13;varying vec2 s39;varying vec3 n40;varying vec3 a41;void main(){w13=uv;s39=uvOffset;vec3 q42=(modelMatrix*vec4((position*scale*0.1)+offset,1.0)).xyz;n40=g10-q42;a41=cameraPosition-q42;gl_Position=projectionMatrix*modelViewMatrix*vec4((position*scale*0.1)+offset,1.0);}",
            Z1 = "precision mediump float;uniform float j0;uniform sampler2D i25;uniform sampler2D q26;uniform sampler2D i27;uniform vec3 e8;uniform vec3 b28;uniform vec3 g10;uniform float u29;uniform float j30;uniform mat3 normalMatrix;uniform float g31;varying vec2 w13;varying vec2 s39;varying vec3 n40;varying vec3 a41;struct n43{float x44;vec3 k45;};n43 j46(){vec2 y47=(w13+s39)*0.5;vec2 a48=y47+vec2(0.0,g31*j0);vec2 k49=(y47+vec2(-j0*0.1,j0*0.5))*0.5;vec2 z50=(y47+vec2(j0*0.2,g31*j0*0.7))*2.0;float u51=texture2D(i25,a48).r;float q52=texture2D(i25,k49).r;float z53=texture2D(i25,z50).r;vec3 x54=texture2D(q26,a48).rgb;vec3 x55=texture2D(q26,k49).rgb;vec3 d56=texture2D(q26,z50).rgb;n43 e57;e57.x44=(u51*q52)*z53*2.0;e57.k45=(x54*x55)*d56*2.0;e57.k45=normalize(x54);return e57;}void main(){n43 s58=j46();float x44=texture2D(i27,w13).r;vec3 w59=normalize(n40);vec3 f60=normalize(a41);vec3 l61=normalize(w59+f60);float u62=length(n40);float z63=clamp(1.0-u62/u29,0.0,1.0);z63*=z63;float b64=dot(s58.k45,w59);b64*=z63;float s65=0.0;if(b64>0.0){s65=pow(dot(s58.k45,l61),j30);}gl_FragColor=vec4(e8,s58.x44*x44);gl_FragColor.rgb=mix(gl_FragColor.rgb,b28,b64);}";
        const _c = class extends Te {
            constructor(e) {
                super();
                ee(this, "a1");
                ee(this, "a2");
                ee(this, "a3");
                if (_c.a0++) throw new Error;
                const t = e.particlesCount || 20,
                    n = new Zn(1, 1),
                    i = new Float32Array(t * 3),
                    r = new Float32Array(t * 2),
                    s = new Float32Array(t);
                for (let m = 0; m < t; ++m) {
                    const g = m * 2,
                        v = m * 3;
                    i[v] = Math.random() * 2 - 1, i[v + 1] = Math.random() * 2 - 1, i[v + 2] = Math.random() * 2 - 1, r[g] = Math.random() * 10, r[g + 1] = Math.random() * 10, s[m] = Math.random() * 50 + 1
                }
                const o = new Tr(i, 3).setUsage(Mi),
                    l = new Tr(r, 2).setUsage(Mi);
                this.a1 = new Tr(s, 1).setUsage(es), n.setAttribute("offset", o), n.setAttribute("uvOffset", l), n.setAttribute("scale", this.a1);
                const c = ln.load(e.diffuseMapUrl);
                c.wrapS = c.wrapT = xn;
                const u = ln.load(e.normalMapUrl);
                u.wrapS = u.wrapT = xn;
                const h = ln.load(e.maskMapUrl);
                h.wrapS = h.wrapT = xn, this.a2 = {
                    j0: {
                        value: 0,
                        ignore: !0
                    },
                    i25: {
                        value: c
                    },
                    q26: {
                        value: u
                    },
                    i27: {
                        value: h
                    },
                    e8: {
                        value: new ne(3225899)
                    },
                    b28: {
                        value: new ne(65535)
                    },
                    g10: {
                        value: new E(-1, 17, 19),
                        min: -100,
                        max: 100
                    },
                    u29: {
                        value: 47,
                        min: 0,
                        max: 200
                    },
                    j30: {
                        value: 150,
                        min: 0,
                        max: 200
                    },
                    g31: {
                        value: .2,
                        max: 1,
                        min: -1
                    }
                };
                const f = new An({
                        vertexShader: Y1,
                        fragmentShader: Z1,
                        depthWrite: !1,
                        depthTest: !1,
                        transparent: !0,
                        uniforms: this.a2
                    }),
                    d = new fh(n, f, t);
                d.scale.set(10, 10, 10), d.layers.enable(wt.a1), this.add(d)
            }
            a4(e) {
                var t;
                (t = this.a3) == null || t.position.copy(this.a2.lightPosition.value), this.a2.j0.value += e * .3
            }
        };
        let fc = _c;
        ee(fc, "a0", 0);
        var J1 = "varying vec2 w13;void main(){w13=uv;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}",
            $1 = "uniform float j0;uniform sampler2D x1;uniform sampler2D y2;uniform float v3;uniform float g4;uniform float z5;varying vec2 w13;float b14(vec2 m15){vec2 a16=vec2(23.14069263277926,2.665144142690225);return fract(cos(dot(m15,a16))*12345.6789);}float o17(float j18,float q19){return min(j18+q19,1.0);}vec3 o17(vec3 j18,vec3 q19){return min(j18+q19,vec3(1.0));}vec3 o17(vec3 j18,vec3 q19,float n20){return(o17(j18,q19)*n20+j18*(1.0-n20));}void main(){vec2 d21=w13;d21.y*=b14(vec2(d21.y,j0*v3));float c22=b14(d21);vec4 e8=texture2D(x1,w13);vec4 t23=texture2D(y2,w13);gl_FragColor=vec4(o17(e8.rgb,t23.rgb),1.0);gl_FragColor.rgb+=c22*g4;gl_FragColor.rgb*=z5;}",
            K1 = "attribute vec3 position;attribute vec2 uv;uniform mat4 projectionMatrix;uniform mat4 modelViewMatrix;varying vec2 w13;void main(){w13=uv;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}",
            Q1 = "precision mediump float;uniform vec3 e8;uniform float r24;uniform float v6;uniform float z5;varying vec2 w13;float u36(in vec2 i37,in float r24,in float v6){return 1.0-smoothstep(r24-(r24*v6),r24+(r24*v6),dot(i37,i37)*4.0);}void main(){float g38=u36(w13-0.5,r24,v6);gl_FragColor=vec4(e8,g38*w13.y);}";
        const vc = class extends Te {
            constructor(e) {
                super();
                ee(this, "a1");
                if (vc.a0++) throw new Error;
                const t = new Zn(1, 1);
                this.a1 = {
                    e8: {
                        value: new ne("white")
                    },
                    r24: {
                        value: .5,
                        min: 0,
                        max: 1
                    },
                    v6: {
                        value: .1,
                        min: 0,
                        max: 1
                    },
                    z5: {
                        value: 0,
                        min: 0,
                        max: 1
                    }
                };
                const n = new An({
                        vertexShader: K1,
                        fragmentShader: Q1,
                        uniforms: this.a1,
                        transparent: !0
                    }),
                    i = new Ge(t, n);
                i.layers.enable(wt.a1), i.scale.set(50, 50, 1), this.add(i), this.position.set(-20, 40, -100)
            }
        };
        let dc = vc;
        ee(dc, "a0", 0);
        var Ad = "attribute vec3 position;attribute vec2 uv;uniform mat4 projectionMatrix;uniform mat4 modelViewMatrix;varying vec2 w13;void main(){w13=uv;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}",
            eM = `precision mediump float;
#define a72 0.05
uniform float d9;varying vec2 w13;void main(){float m15=1.0-d9;float d73=smoothstep(m15,m15+a72*0.5,1.0-w13.x);d73*=smoothstep(0.0,a72,w13.x)*(1.0-smoothstep(1.0-a72,1.0,w13.x));d73*=smoothstep(0.0,a72,w13.y)*(1.0-smoothstep(1.0-a72,1.0,w13.y));gl_FragColor=vec4(vec3(1.0),d73);}`,
            tM = "precision mediump float;uniform float d9;varying vec2 w13;float u36(in vec2 i37,in float r24,in float v6){return 1.0-smoothstep(r24-(r24*v6),r24+(r24*v6),dot(i37,i37)*4.0);}void main(){float d73=u36(w13-0.5,d9,0.2);gl_FragColor=vec4(vec3(1.0),d73);}",
            Ld;
        (function(a) {
            a[a.a0 = 0] = "a0", a[a.a1 = 1] = "a1"
        })(Ld || (Ld = {}));
        class nM extends Te {
            constructor() {
                super();
                ee(this, "a0");
                ee(this, "a1");
                ee(this, "a2");
                ee(this, "a3");
                ee(this, "a4");
                ee(this, "a5");
                ee(this, "a6");
                ee(this, "a7");
                ee(this, "a8");
                this.a0 = 4, this.a1 = .2, this.a2 = .6, this.a3 = 3, this.a5 = new An({
                    vertexShader: Ad,
                    fragmentShader: eM,
                    uniforms: {
                        d9: {
                            value: 1
                        }
                    },
                    transparent: !0,
                    depthWrite: !1
                }), this.a6 = new An({
                    vertexShader: Ad,
                    fragmentShader: tM,
                    uniforms: {
                        d9: {
                            value: 1
                        }
                    },
                    transparent: !0,
                    depthWrite: !1
                });
                const e = new Zn(1, 1),
                    t = new Ge(e, this.a5);
                t.layers.enable(wt.a2);
                const n = new Ge(e, this.a6);
                n.layers.enable(wt.a2);
                const i = this.a9(t, n),
                    r = this.a10(t, n),
                    s = this.a11(t, n),
                    o = this.a12(t, n);
                this.a4 = [i, r, i.clone(), s, o], this.add(...this.a4)
            }
            a9(e, t) {
                const n = new Te,
                    i = e.clone();
                i.scale.set(this.a0 + this.a1, this.a1, 0), i.position.set(0, this.a0 / 2, 0), n.add(i);
                const r = t.clone();
                return r.scale.set(this.a2, this.a2, 0), n.add(r), n
            }
            a10(e, t) {
                const n = new Te,
                    i = e.clone();
                i.scale.set(this.a0 + this.a1, this.a1, 0), i.position.set(0, this.a0 / 2, 0), n.add(i);
                const r = e.clone();
                r.scale.set(this.a0 + this.a1, this.a1, 0), r.position.set(0, -this.a0 / 2, 0), r.rotation.z = Math.PI, n.add(r);
                const s = i.clone();
                s.position.set(-this.a0 / 2, 0, 0), s.rotation.z = -Math.PI / 2, n.add(s);
                const o = s.clone();
                o.position.set(this.a0 / 2, 0, 0), o.rotation.z = Math.PI / 2, n.add(o);
                const l = t.clone();
                return l.scale.set(this.a2, this.a2, 0), n.add(l), n
            }
            a11(e, t) {
                const n = new Te,
                    i = e.clone();
                i.scale.set(this.a0 + this.a1, this.a1, 0), i.position.set(0, this.a0 / 2, 0), n.add(i);
                const r = e.clone();
                r.scale.set(this.a0 + this.a1, this.a1, 0), r.position.set(0, -this.a0 / 2, 0), n.add(r);
                const s = i.clone();
                s.position.set(-this.a0 / 2, 0, 0), s.rotation.z = -Math.PI / 2, n.add(s);
                const o = t.clone();
                return o.scale.set(this.a2, this.a2, 0), n.add(o), n
            }
            a12(e, t) {
                const n = new Te,
                    i = e.clone();
                i.scale.set(this.a0 + this.a1, this.a1, 0), i.position.set(-this.a0 / 2, 0, 0), i.rotation.z = -Math.PI / 2, n.add(i);
                const r = e.clone();
                r.scale.set((this.a0 + this.a1) / 1.5, this.a1, 0), r.position.set(-this.a0 / 4, this.a0 / 4, 0), r.rotation.z = -45 * (Math.PI / 180), n.add(r);
                const s = i.clone();
                s.position.set(this.a0 / 2, 0, 0), s.rotation.z = Math.PI / 2, n.add(s);
                const o = t.clone();
                o.scale.set(this.a2, this.a2, 0), o.position.set(-this.a0 / 2, this.a0 / 2, 0), n.add(o);
                const l = t.clone();
                return l.scale.set(this.a2, this.a2, 0), n.add(l), n
            }
            a13(e) {
                let t, n;
                e < 500 ? (t = .5, n = 0) : e < 800 ? (t = .5, n = 1) : (t = 1, n = 1), this.a7 = n, this.scale.set(t, t, 1);
                const i = (this.a4.length - 1) * (this.a0 + this.a3),
                    r = new Array(this.a4.length);
                this.a4.forEach((s, o) => {
                    switch (n) {
                        case 0:
                            r[o] = (o % 2 == 0 ? 1 : -1) * (Math.random() * 2 - 1) * 10, s.position.x = 0, s.position.y = -(o * (this.a0 + this.a3)) + i / 2;
                            break;
                        case 1:
                            r[o] = Math.random() * 10, s.position.x = o * (this.a0 + this.a3) - i / 2, s.position.y = 0;
                            break
                    }
                }), this.a8 = r
            }
            a14(e) {
                if (!this.a7 != null) switch (this.position.z = Qa(e, 0, 1, 0, 10), this.a7) {
                    case 0:
                        this.a4.forEach((t, n) => {
                            t.position.x = Qa(e, 0, 1, 0, this.a8[n])
                        });
                        break;
                    case 1:
                        this.a4.forEach((t, n) => {
                            t.position.y = Qa(e, 0, 1, 0, this.a8[n])
                        });
                        break
                }
            }
        }
        class Rd {
            constructor(e, t) {
                ee(this, "a0");
                ee(this, "a26");
                ee(this, "a6");
                ee(this, "a34");
                ee(this, "a19");
                ee(this, "a5");
                ee(this, "a35");
                ee(this, "a18");
                ee(this, "a33");
                ee(this, "a7");
                ee(this, "a36");
                ee(this, "a1");
                ee(this, "a32");
                ee(this, "a25");
                ee(this, "a28");
                ee(this, "a31");
                ee(this, "a4");
                ee(this, "a27");
                ee(this, "a10");
                ee(this, "a22");
                ee(this, "a3");
                ee(this, "a14");
                ee(this, "a30");
                ee(this, "a17");
                ee(this, "a21");
                ee(this, "a11");
                ee(this, "a2");
                ee(this, "a13");
                this.a0 = new X(window.innerWidth, window.innerHeight), this.a26 = document.documentElement.scrollHeight || document.body.scrollHeight, this.a6 = 0, this.a34 = 0, this.a19 = new X(0, 0), this.a5 = new X(0, 0), this.a35 = new Qu, this.a35.physicallyCorrectLights = !0, this.a35.outputEncoding = Ot, this.a35.toneMapping = Pc, this.a35.setSize(this.a0.width, this.a0.height), this.a35.setPixelRatio(t.devicePixelRatio || Math.min(window.devicePixelRatio || 1, 2)), e.appendChild(this.a35.domElement), this.a18 = new wa;
                const n = new Mu(this.a35),
                    i = new c1(-1, -90);
                this.a18.environment = n.fromScene(i).texture, n.dispose(), i.a0(), this.a33 = new yt(45, this.a0.width / this.a0.height, 1, 1e3), this.a33.position.z = 40, this.a7 = new aa, this.a7.set(wt.a1), this.a36 = new aa, this.a36.set(wt.a2);
                const r = new Kx(this.a18, this.a33);
                this.a1 = new Fr(this.a0.clone().divideScalar(2), .6, 1, .2), this.a32 = new El({
                    vertexShader: J1,
                    fragmentShader: $1,
                    uniforms: {
                        j0: {
                            value: 0
                        },
                        x1: {
                            value: null
                        },
                        y2: {
                            value: null
                        },
                        v3: {
                            value: 1
                        },
                        g4: {
                            value: .1
                        },
                        z5: {
                            value: 1
                        }
                    }
                }, "x1"), this.a32.needsSwap = !1, this.a25 = new Qh(this.a35), this.a25.renderTarget1.texture.encoding = this.a25.renderTarget2.texture.encoding = Ot, this.a25.renderToScreen = !1, this.a25.addPass(r), this.a25.addPass(this.a1), this.a28 = new Qh(this.a35), this.a28.renderTarget1.texture.encoding = this.a28.renderTarget2.texture.encoding = Ot, this.a28.addPass(r), this.a28.addPass(this.a32), this.a28.renderToScreen = !0, this.a4 = new nM, this.a4.a13(this.a0.width), this.a18.add(this.a4), this.a31 = new hc(t.background), this.a18.add(this.a31), this.a27 = new q1(t.totem), this.a18.add(this.a27), this.a10 = new fc(t.smoke), this.a18.add(this.a10), this.a22 = new dc(t.sun), this.a18.add(this.a22), this.a3 = new xl(13161133, 0), this.a3.position.set(-.5, 0, -1), this.a18.add(this.a3), this.a17 = new jh, this.a21 = 0, this.a11 = new Xx, this.a11.layers.set(wt.a0), this.a27.addEventListener("ready", () => this.a2 = this.a8()), this.a17.start(), this.a24 = this.a24.bind(this), this.a12 = this.a12.bind(this), this.a15 = this.a15.bind(this), this.a9 = this.a9.bind(this), this.a20 = this.a20.bind(this), window.addEventListener("mousedown", this.a24), window.addEventListener("mousemove", this.a12), window.addEventListener("mouseup", this.a15), window.addEventListener("mouseleave", this.a23), window.addEventListener("resize", this.a9), window.requestAnimationFrame(this.a20)
            }
            a24(e) {
                this.a19.set(e.clientX / this.a0.width * 2 - 1, -(e.clientY / this.a0.height) * 2 + 1), this.a30 = this.a14
            }
            a12(e) {
                this.a5.set(e.clientX / this.a0.width * 2 - 1, -(e.clientY / this.a0.height) * 2 + 1), this.a30 && (this.a30.a16((this.a5.x - this.a19.x) * 4), this.a19.copy(this.a5))
            }
            a15() {
                this.a30 = null
            }
            a23() {
                this.a30 = null
            }
            a9() {
                var t, n;
                this.a0.set(window.innerWidth, window.innerHeight), this.a26 = document.documentElement.scrollHeight || document.body.scrollHeight, this.a35.setSize(this.a0.width, this.a0.height), this.a33.aspect = this.a0.width / this.a0.height, this.a33.updateProjectionMatrix(), this.a25.setSize(this.a0.width, this.a0.height), this.a28.setSize(this.a0.width, this.a0.height);
                const e = ((t = this.a2) == null ? void 0 : t.progress()) || 0;
                this.a4.a13(this.a0.width), (n = this.a2) == null || n.progress(e)
            }
            a20() {
                var t, n, i, r, s;
                window.requestAnimationFrame(this.a20), this.a34 = (document.documentElement.scrollTop || document.body.scrollTop) / (this.a26 - this.a0.height), this.a6 += (this.a34 - this.a6) * .05, (t = this.a2) == null || t.progress(this.a6);
                const e = this.a17.getDelta();
                if (this.a21 += e, !this.a30) {
                    this.a11.setFromCamera(this.a5, this.a33);
                    const o = this.a11.intersectObjects(this.a18.children);
                    document.body.style.cursor = o.length ? "grab" : "auto", this.a14 = (i = (n = o == null ? void 0 : o[0]) == null ? void 0 : n.object.userData) == null ? void 0 : i.totemPart
                }
                this.a31.a2(e), this.a27.a4(e, this.a21), (r = this.a10) == null || r.a4(e), this.a32.uniforms.j0.value += e, (s = this.a13) == null || s.update(), this.a29()
            }
            a29() {
                this.a16(!0), this.a25.render(), this.a16(!1), this.a32.uniforms.y2.value = this.a25.renderTarget2.texture, this.a28.render()
            }
            a16(e) {
                this.a18.traverse(t => {
                    !(t instanceof Ge) || this.a7.test(t.layers) || (this.a36.test(t.layers) ? t.visible = !e : e ? (t.userData.material = t.material, t.material = Ed) : t.material = t.userData.material)
                })
            }
            a8() {
                const e = 11,
                    t = 1,
                    n = md.timeline({
                        paused: !0,
                        defaults: {
                            ease: "sine.inOut",
                            duration: t
                        }
                    });
                Array.from(Array(e)).forEach((s, o) => n.addLabel(`section-${o}`, o * t)), n.set({}, {}, (e - 1) * t);
                const i = () => this.a33.updateProjectionMatrix();
                this.a4.position.y = 15, this.a4.rotation.x = .3, this.a22.position.set(-20, -15, -100), this.a22.a1.z5.value = .1, this.a22.a1.v6.value = 1, this.a27.position.set(0, 20, -10), this.a27.a1.a6.envMapIntensity = .05, this.a27.a2.a3.intensity = .1, this.a27.a2.a4.intensity = .1, this.a27.a2.a2.envMapIntensity = .05, this.a27.a2.a1.c7.value = 1, this.a27.a3.forEach(s => {
                    s.a7.envMapIntensity = .05, s.a7.emissiveIntensity = 0
                }), this.a31.a1.z5.value = .02, this.a33.position.y = -0, this.a33.lookAt(this.a27.position), this.a10.position.y = -10, this.a1.strength = 1, n.call(() => this.a10.a2.e8.value.set(1845276), [], 0), n.to(this.a4.a5.uniforms.d9, {
                    value: 0
                }, "section-0"), n.to(this.a4.a6.uniforms.d9, {
                    value: 0
                }, "section-0");
                const r = {
                    progress: 0
                };
                return n.to(r, {
                    progress: 1,
                    onUpdate: () => this.a4.a14(r.progress)
                }, "section-0"), n.to(this.a31.a1.z5, {
                    value: .1
                }, "section-0"), n.to(this.a22.position, {
                    y: 60,
                    duration: 1
                }, "section-0"), n.to(this.a22.a1.z5, {
                    value: 1,
                    duration: 1
                }, "section-0"), n.to(this.a22.a1.v6, {
                    value: .1,
                    duration: 1
                }, "section-0"), n.to(this.a27.position, {
                    y: -20,
                    ease: "sine.inOut",
                    duration: 2
                }, "section-0"), n.to(this.a27.rotation, {
                    y: -.3,
                    duration: 1.5,
                    delay: .7
                }, "section-0"), n.to(this.a27.position, {
                    z: 20,
                    duration: 2,
                    delay: .5
                }, "section-0"), n.to(this.a27.a1.a6, {
                    envMapIntensity: .2,
                    duration: 2
                }, "section-0"), n.to(this.a27.a2.a2, {
                    envMapIntensity: .2,
                    duration: 2
                }, "section-0"), this.a27.a3.forEach(s => n.to(s.a7, {
                    envMapIntensity: .2,
                    duration: 2
                }, "section-0")), n.to(this.a3, {
                    intensity: .7,
                    duration: 1
                }, "section-0"), n.to(this.a33.rotation, {
                    x: 0,
                    duration: 1.2
                }, "section-0"), n.to(this.a33.position, {
                    y: -90,
                    duration: 10
                }, "section-0"), n.to(this.a1, {
                    strength: .6,
                    duration: 2
                }, "section-0"), this.a27.a3.forEach((s, o, l) => {
                    n.to(s, {
                        a10: `+=${Math.PI}`,
                        delay: (l.length - 1 - o) * .1
                    }, "section-0+=0.4")
                }), n.to(this.a3, {
                    intensity: .2,
                    duration: 1
                }, "section-1"), n.to(this.a27.position, {
                    x: 5,
                    duration: 1
                }, "section-1"), n.to(this.a27.position, {
                    y: 3,
                    duration: 1,
                    delay: .5,
                    ease: "sine.in"
                }, "section-2"), n.to(this.a27.a1.a8, {
                    intensity: 1
                }, "section-2-=0.3"), n.to(this.a27.a1, {
                    a9: 2
                }, "section-2-=0.3"), n.to(this.a27.a3[0], {
                    a8: .5,
                    duration: .5
                }, "section-2"), n.to(this.a27.a3[1], {
                    a8: .5,
                    duration: .5
                }, "section-2"), n.to(this.a27.a3[2], {
                    a8: .5,
                    duration: .5,
                    delay: .3
                }, "section-2"), n.to(this.a27.a3[3], {
                    a8: .5,
                    duration: .5,
                    delay: .6
                }, "section-2"), n.to(this.a27.a3[4], {
                    a8: .5,
                    duration: .5,
                    delay: .75
                }, "section-2"), n.to(this.a27.a3[5], {
                    a8: .5,
                    duration: .5,
                    delay: 1
                }, "section-2"), n.to(this.a27.a2, {
                    a5: 1,
                    duration: .5,
                    delay: .6
                }, "section-2"), n.to(this.a27.a2.a3, {
                    intensity: .9,
                    duration: .5,
                    delay: .65
                }, "section-2"), n.to(this.a27.a2.a4, {
                    intensity: .3,
                    duration: .5,
                    delay: .65
                }, "section-2"), n.to(this.a27.a2.a1.c7, {
                    value: .34,
                    duration: .5,
                    delay: .55
                }, "section-2"), n.to(this.a1, {
                    strength: 2,
                    duration: .5
                }, "section-2"), n.to(this.a1, {
                    strength: 0,
                    delay: .5,
                    duration: .5
                }, "section-2"), n.set(this.a1, {
                    strength: 2
                }, "section-3+=0.5"), n.set(this.a27.position, {
                    x: 0,
                    y: -51
                }, "section-3+=0.5"), n.set(this.a27.rotation, {
                    y: 0
                }, "section-3+=0.5"), n.to(this.a27.position, {
                    y: -42,
                    duration: .5
                }, "section-3+=0.5"), n.set(this.a27.a1, {
                    a11: 1,
                    a10: 1
                }, "section-3+=0.5"), this.a27.a3.forEach(s => n.set(s, {
                    a8: .1
                }, "section-3+=0.5")), n.to(this.a1, {
                    strength: 0
                }, "section-4"), n.to(this.a27.position, {
                    y: -90,
                    duration: 6
                }, "section-4"), n.to(this.a33, {
                    fov: 30,
                    duration: 2,
                    onUpdate: i
                }, "section-5"), n.to(this.a31.a1.z5, {
                    value: .02
                }, "section-5"), this.a27.a3.forEach(s => n.to(s.a7, {
                    envMapIntensity: 0,
                    duration: 1
                }, "section-5")), n.set(this.a10.position, {
                    x: -5,
                    y: -80
                }, "section-5"), n.call(() => this.a10.a2.e8.value.set(593672), [], "section-5"), n.set(this.a10.a2.g10.value, {
                    y: -100
                }, "section-5"), n.to(this.a3, {
                    intensity: .1,
                    duration: 2
                }, "section-5"), n.to(this.a3.position, {
                    x: -.5,
                    z: .1,
                    duration: 2
                }, "section-5"), n.to(this.a27.a2.a1.c11, {
                    value: .6
                }, "section-6"), n.to(this.a27.a2.a1.k12, {
                    value: 4
                }, "section-6"), n.to(this.a33, {
                    fov: 45,
                    duration: 3,
                    onUpdate: i
                }, "section-7"), n.to(this.a27.position, {
                    x: -10,
                    z: -10,
                    duration: 2
                }, "section-7"), n.to(this.a27.rotation, {
                    y: .3,
                    duration: 2
                }, "section-7"), n.to(this.a1, {
                    strength: 1
                }, "section-8"), this.a27.a3.forEach(s => n.to(s, {
                    a8: .8
                }, "section-8")), this.a27.a3.forEach((s, o) => {
                    n.to(s, {
                        a10: 0,
                        duration: 2,
                        delay: o * .1
                    }, "section-7")
                }), n
            }
        }
        return window.TotemScene = Rd, window.onTotemSceneLoaded && window.onTotemSceneLoaded(), Rt.Scene = Rd, Object.defineProperty(Rt, "__esModule", {
            value: !0
        }), Rt[Symbol.toStringTag] = "Module", Rt
    }({});
})();